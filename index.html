<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ·±å¾„ï¼šä½™çƒ¬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    
    <style>
        :root {
            --color-bg: #111827; /* æ·±ç°è“ */
            --color-surface: #1f2937; /* è¡¨é¢ */
            --color-border: #374151; /* è¾¹æ¡† */
            --color-text: #e5e7eb; /* æ–‡æœ¬ */
            --color-text-dim: #9ca3af; /* æš—æ–‡æœ¬ */
            --color-accent: #22d3ee; /* é’è‰² (èƒ½é‡) */
            --color-accent-dark: #0e7490;
            --color-red: #ef4444; /* çº¢è‰² (ä¼¤å®³) */
            --color-blue: #3b82f6; /* è“è‰² (æ ¼æŒ¡) */
            --color-yellow: #eab308; /* é»„è‰² (å¥–åŠ±) */
            --color-green: #22c55e; /* ç»¿è‰² (å‡çº§) */
            --color-orange: #f97316; /* æ©™è‰² (æ˜“ä¼¤) */
            --color-gray: #6b7280; /* ç°è‰² (è™šå¼±) */
            --color-purple: #a855f7; /* ç´«è‰² (è¯…å’’) */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            overscroll-behavior: none; /* ç¦æ­¢"æ‹‰åŠ¨åˆ·æ–°" */
            -webkit-user-select: none; /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent; 
        }

        /* æ¸¸æˆä¸»å®¹å™¨ï¼Œæ¨¡æ‹Ÿç«–å±æ‰‹æœº */
        .game-container {
            width: 100%;
            height: 100vh;
            max-width: 420px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
            position: relative;
        }
        
        /* æ¸¸æˆä¸»å®¹å™¨å†…çš„ç»å¯¹å®šä½å±‚ï¼Œç”¨äºåŠ¨ç”» */
        #animation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 40; /* å¿…é¡»åœ¨UIä¸‹é¢ï¼Œä½†åœ¨èƒŒæ™¯ä¹‹ä¸Š */
        }

        /* éšè—çš„å±å¹• */
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 1; /* ä¿è¯å±å¹•åœ¨åŠ¨ç”»å±‚ä¹‹ä¸Š */
        }
        .screen.active {
            display: flex;
            opacity: 1;
            position: relative;
            pointer-events: auto;
            z-index: 2; /* æ¿€æ´»çš„å±å¹•åœ¨æœ€å‰ */
        }
        
        /* æ¨¡æ€æ¡† (ç”¨äºé”»é€ ) */
        .modal-screen {
            position: absolute;
            z-index: 10;
            background-color: rgba(0,0,0,0.5); /* åŠé€æ˜é®ç½© */
            backdrop-filter: blur(4px);
            display: flex; /* é»˜è®¤éšè— */
        }
        .modal-screen.active {
            display: flex; /* æ¿€æ´»æ—¶æ˜¾ç¤º */
            opacity: 1;
            pointer-events: auto;
            z-index: 11; /* æ¨¡æ€æ¡†åœ¨æ‰€æœ‰ä¹‹ä¸Š */
        }
        .modal-content {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
        }

        /* å¡ç‰Œæ ·å¼ */
        .card {
            width: 80px;
            height: 110px;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease, margin 0.2s ease; /* V1.14: å¢åŠ  margin è¿‡æ¸¡ */
            cursor: pointer;
            flex-shrink: 0;
            position: relative; 
        }
        .card-cost {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--color-accent);
            color: var(--color-bg);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            border: 1px solid var(--color-accent-dark);
        }
        .card.curse .card-cost {
            background-color: var(--color-purple);
            border-color: var(--color-purple);
            color: var(--color-text);
        }
        .card-name {
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
        }
        .card-name.upgraded {
            color: var(--color-green);
        }
        .card-desc {
            font-size: 0.75rem;
            text-align: center;
            color: var(--color-text-dim);
        }
        .card-desc .keyword {
            color: var(--color-yellow);
            font-weight: 600;
            cursor: help;
        }
        .card.upgraded {
            border-color: var(--color-green);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        .card.exhaust .card-desc::after {
            content: " (æ¶ˆè€—)";
            font-style: italic;
            color: var(--color-text-dim);
        }
        .card.curse {
            border-color: var(--color-purple);
        }
        
        /* V1.14: æ‰‹ç‰ŒåŒºåŸŸé‡æ„ */
        #hand-area {
            height: 160px; /* å¢åŠ ä¸€ç‚¹é«˜åº¦ */
            background-color: var(--color-bg); /* æ”¹ä¸ºæ›´æ·±çš„èƒŒæ™¯ */
            border-top: 2px solid var(--color-border);
            padding: 10px 40px; /* V1.14: å¢åŠ å·¦å³å†…è¾¹è·ï¼Œç¡®ä¿æ»šåŠ¨åˆ°è¾¹ç¼˜ */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: auto; /* å…è®¸æ°´å¹³æ»šåŠ¨ */
            position: relative;
        }
        .hand-card {
            margin-left: -30px; /* V1.14: è´Ÿå¤–è¾¹è·å®ç°å¡ç‰Œé‡å  */
        }
        .hand-card:first-child {
            margin-left: 0; /* ç¬¬ä¸€å¼ å¡æ²¡æœ‰è´Ÿå¤–è¾¹è· */
        }
        /* V1.14: æ‚¬åœ/é€‰ä¸­æ—¶ï¼Œç§»é™¤è´Ÿå¤–è¾¹è·ï¼Œä½¿å…¶â€œå¼¹å‡ºâ€ */
        .hand-card:hover {
            transform: translateY(-10px) scale(1.05);
            margin-left: 0;
            margin-right: -30px; /* è¡¥å¿å³ä¾§å¡ç‰Œ */
            z-index: 10;
        }
        .hand-card:hover + .hand-card {
            margin-left: 0; /* æ‚¬åœæ—¶ï¼Œå³ä¾§çš„å¡ç‰Œä¹Ÿå±•å¼€ */
        }
        .hand-card.selected {
            transform: translateY(-20px) scale(1.1);
            border-color: var(--color-accent);
            box-shadow: 0 0 20px 5px rgba(34, 211, 238, 0.3);
            margin-left: 0;
            margin-right: -30px;
            z-index: 20;
        }
        .hand-card.selected + .hand-card {
            margin-left: 0;
        }
        
        .hand-card.playable {
            border-color: var(--color-accent);
        }
        .hand-card.unplayable {
            opacity: 0.6;
            background-color: #333;
        }
        /* V1.14: æŠ½å¡åŠ¨ç”»çš„èµ·å§‹çŠ¶æ€ */
        .hand-card.drawing {
            opacity: 0;
            position: absolute; /* V1.14: åŠ¨ç”»æ—¶è„±ç¦»å¸ƒå±€ */
            z-index: 30;
            transition: all 0.4s ease-out;
        }

        /* å¡ç‰Œå¥–åŠ± UI */
        #card-reward-options {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 20px; 
        }
        .reward-card {
            transition: all 0.2s ease-out;
        }
        .reward-card:hover {
            transform: scale(1.1) translateY(-16px) !important; 
            z-index: 20 !important;
            border-color: var(--color-yellow);
        }
        .reward-card:nth-child(1) { transform: rotate(-6deg); z-index: 8; margin-left: -10px; } 
        .reward-card:nth-child(2) { transform: scale(1.05); z-index: 10; }
        .reward-card:nth-child(3) { transform: rotate(6deg); z-index: 9; margin-left: -10px; } 

        /* æ•Œäºº */
        .enemy-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s ease-in-out;
        }
        .enemy-container.targeted {
            transform: scale(1.05);
        }
        .enemy-sprite {
            font-size: 6rem; /* Emoji as sprite */
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        /* ç©å®¶ */
        .player-container {
            transition: transform 0.1s ease-in-out;
            position: relative; /* ä¸ºçŠ¶æ€å›¾æ ‡å®šä½ */
        }
        .player-container.targeted {
            transform: scale(1.05);
        }

        /* çŠ¶æ€æ¡ (HP) */
        .hp-bar-bg {
            background-color: #4b5563;
            border-radius: 99px;
            overflow: hidden;
        }
        .hp-bar-fg {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #ef4444);
            transition: width 0.3s ease;
        }

        /* æ•ŒäººçŠ¶æ€å›¾æ ‡ */
        .enemy-container .status-icon-container {
            position: absolute;
            left: auto;
            right: -10px;
            bottom: 20px;
            display: flex;
            gap: 4px;
        }
        /* V1.13: ç©å®¶çŠ¶æ€å›¾æ ‡ (ç§»å‡º player-container) */
        #player-status-area {
            min-height: 38px; /* ç•™å‡ºç©ºé—´ */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 4px 0;
            background-color: rgba(0,0,0,0.2);
            border-top: 1px solid var(--color-border);
        }
        
        .status-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 0.9rem; 
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(0,0,0,0.5);
            color: white;
            text-shadow: 0 0 3px black;
            cursor: pointer; 
            transition: transform 0.1s ease;
        }
        .status-icon:active { 
            transform: scale(1.15);
        }
        .status-icon.status-orange { background-color: var(--color-orange); }
        .status-icon.status-gray { background-color: var(--color-gray); }
        .status-icon.status-red { background-color: var(--color-red); }

        /* æŒ‰é’®æ ·å¼ */
        .btn {
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-align: center;
            cursor: pointer;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: var(--color-accent);
            color: var(--color-bg);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #67e8f9;
        }
        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-border);
        }
        .btn-yellow {
            background: var(--color-yellow);
            color: var(--color-bg);
        }
        .btn-yellow:hover:not(:disabled) {
            background-color: #facc15;
        }
        
        /* ä¼¤å®³/æ ¼æŒ¡ æµ®åŠ¨æ–‡å­— */
        .damage-float, .block-float {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 1;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .damage-float { color: var(--color-red); }
        .damage-float.vulnerable {
            color: var(--color-orange);
            font-size: 1.8rem;
            transform: scale(1.2);
        }
        .block-float { color: var(--color-blue); }
        
        @keyframes floatUp {
            from { transform: translateY(0) scale(1); opacity: 1; }
            to { transform: translateY(-60px) scale(1.2); opacity: 0; }
        }
        
        /* åŠ¨ç”» */
        .anim-shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translateX(-4px); }
            20%, 80% { transform: translateX(4px); }
            30%, 50%, 70% { transform: translateX(-4px); }
            40%, 60% { transform: translateX(4px); }
        }
        .anim-lunge {
            animation: lunge 0.5s ease-in-out;
        }
        @keyframes lunge {
            0% { transform: translateY(0); }
            50% { transform: translateY(30px) scale(1.1); }
            100% { transform: translateY(0); }
        }
        .anim-block-shield {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 4rem;
            opacity: 0;
            animation: block-pop 0.6s ease-out;
            transform-origin: center;
        }
        @keyframes block-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; }
        }
        .anim-pulse {
            animation: pulse 0.6s ease-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: var(--color-yellow); }
            100% { transform: scale(1); }
        }
        .anim-projectile {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            z-index: 45;
            transition: all 0.5s cubic-bezier(0.5, -0.5, 0.5, 1.5); /* Så‹æ›²çº¿ */
        }
        
        #enemy-intent-0 {
            cursor: help; /* æç¤ºå¯ä»¥ç‚¹å‡» */
        }

        /* è·¯å¾„èŠ‚ç‚¹ */
        .path-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--color-text-dim);
            flex-shrink: 0;
        }
        .path-node.current {
            border-color: var(--color-accent);
            color: var(--color-accent);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .path-node.cleared {
            background-color: var(--color-border);
            opacity: 0.5;
        }
        
        /* é”»é€ ç•Œé¢å¡ç‰Œå®¹å™¨ */
        #smith-deck-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }
        #smith-deck-container .card {
            cursor: pointer;
        }
        #smith-deck-container .card:not(.can-upgrade) {
            opacity: 0.4;
            cursor: not-allowed;
        }
        #smith-deck-container .card.can-upgrade:hover {
            transform: scale(1.05);
            border-color: var(--color-green);
        }
        
        /* Tooltip æç¤ºæ¡† */
        #tooltip {
            position: absolute; 
            z-index: 50;
            padding: 12px;
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            max-width: 250px;
            width: max-content; 
            text-align: center;
            pointer-events: none; 
            opacity: 0; 
            transition: opacity 0.1s ease;
        }
        #tooltip.visible {
            opacity: 1; 
        }
        #tooltip-title {
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 4px;
        }
        #tooltip-desc {
            font-size: 0.875rem;
            color: var(--color-text-dim);
        }
        
    </style>
</head>
<body>
    <div id="game-container" class="game-container bg-gray-900">
        
        <div id="animation-layer"></div>

        <!-- 1. ä¸»èœå•å±å¹• -->
        <div id="main-menu-screen" class="screen active p-6 justify-between">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-white">æ·±å¾„ï¼šä½™çƒ¬</h1>
                <p class="text-lg text-gray-400 mt-2">The Deep Path: Embers</p>
            </div>
            
            <div class="space-y-4">
                <button id="continue-run-btn" class="btn btn-primary w-full text-lg hidden">ç»§ç»­æ¢ç´¢</button>
                <button id="start-run-btn" class="btn btn-primary w-full text-lg">å¼€å§‹æ¢ç´¢</button>
                <button id="upgrades-menu-btn" class="btn btn-secondary w-full text-lg">æ°¸ä¹…å‡çº§</button>
            </div>
            
            <div class="text-center text-gray-500 text-sm">
                <p>æœ€é«˜å±‚æ•°: <span id="high-score-display">0</span></p>
            </div>
        </div>

        <!-- 2. å‡çº§å±å¹• -->
        <div id="upgrade-screen" class="screen p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold text-white">æ°¸ä¹…å‡çº§</h2>
                <button id="upgrade-back-btn" class="btn btn-secondary">è¿”å›</button>
            </div>
            
            <div class="text-center p-4 bg-gray-800 rounded-lg">
                <p class="text-gray-400">å¯ç”¨ä½™çƒ¬</p>
                <p id="currency-display" class="text-3xl font-bold text-yellow-400">0 ğŸ”¥</p>
            </div>
            
            <!-- å‡çº§é€‰é¡¹ -->
            <div id="upgrade-options-container" class="space-y-3 flex-grow overflow-y-auto">
                <!-- å‡çº§é¡¹å°†ç”±JSåŠ¨æ€å¡«å…… -->
            </div>
        </div>

        <!-- 3. æ¸¸æˆä¸»å±å¹• -->
        <div id="game-screen" class="screen">
            <!-- è·¯å¾„æ˜¾ç¤º -->
            <div id="path-display" class="w-full p-2 flex justify-center space-x-1 bg-gray-900/80 backdrop-blur-sm border-b border-gray-700 overflow-x-auto">
                <!-- JSåŠ¨æ€å¡«å……è·¯å¾„èŠ‚ç‚¹ -->
            </div>
            
            <!-- æ•ŒäººåŒºåŸŸ -->
            <div id="enemy-area" class="flex-grow flex flex-col justify-center items-center space-y-2 p-4">
                <div id="enemy-container-0" class="enemy-container">
                    <div id="enemy-intent-0" class="p-1 px-3 bg-gray-700 rounded-full text-lg font-semibold flex items-center space-x-1.5">
                        <!-- âš”ï¸ 5 -->
                    </div>
                    <div id="enemy-sprite-0" class="enemy-sprite">ğŸ˜ˆ</div>
                    <div id="enemy-hp-bar-0" class="w-2/3 hp-bar-bg h-4">
                        <div class="hp-bar-fg"></div>
                    </div>
                    <div id="enemy-hp-text-0" class="text-sm">15 / 15</div>
                    <div id="enemy-block-text-0" class="absolute -right-4 top-1/2 text-xl font-bold text-blue-400 bg-gray-800 p-1 px-2 rounded-full hidden">
                        ğŸ›¡ï¸ 0
                    </div>
                    <!-- æ•ŒäººçŠ¶æ€å›¾æ ‡ -->
                    <div id="enemy-status-icons-0" class="status-icon-container"></div>
                </div>
            </div>
            
            <!-- ç©å®¶åŒºåŸŸ -->
            <div id="player-area" class="p-4 border-t border-gray-700 bg-gray-800">
                <div id="player-container" class="player-container flex items-center justify-between">
                    <!-- ç©å®¶çŠ¶æ€ -->
                    <div class="space-y-2 w-2/3">
                        <div id="player-hp-bar" class="w-full hp-bar-bg h-5">
                            <div class="hp-bar-fg"></div>
                        </div>
                        <div class="flex justify-between text-sm">
                            <div id="player-hp-text" class="font-bold">50 / 50</div>
                            <div id="player-block-text" class="font-bold text-blue-400">ğŸ›¡ï¸ 0</div>
                        </div>
                    </div>
                    <!-- èƒ½é‡ -->
                    <div class="flex flex-col items-center">
                        <div id="player-energy-text" class="text-5xl font-bold text-accent">3/3</div>
                        <div class="text-xs text-gray-400">èƒ½é‡ âš¡</div>
                    </div>
                </div>
            </div>
            
            <!-- V1.13: ç©å®¶çŠ¶æ€å›¾æ ‡åŒº (æ–°å¸ƒå±€) -->
            <div id="player-status-area">
                <!-- JSåŠ¨æ€å¡«å…… -->
            </div>

            <!-- V1.14: æ‰‹ç‰ŒåŒºåŸŸ (CSS é‡æ„) -->
            <div id="hand-area">
                <!-- å¡ç‰Œç”±JSåŠ¨æ€å¡«å…… -->
            </div>
            
            <!-- åº•éƒ¨æ“ä½œæ  -->
            <div class="p-3 bg-gray-800 border-t border-gray-700 flex justify-between items-center">
                <div class="text-center relative">
                    <div id="deck-count" class="font-bold text-lg">10</div>
                    <div class="text-xs text-gray-400">ç‰Œå †</div>
                </div>
                <button id="end-turn-btn" class="btn btn-primary text-lg px-8 py-3">ç»“æŸå›åˆ</button>
                <div class="text-center relative">
                    <div id="discard-count" class="font-bold text-lg">0</div>
                    <div class="text-xs text-gray-400">å¼ƒç‰Œå †</div>
                </div>
            </div>
        </div>
        
        <!-- 4. å¥–åŠ±å±å¹• -->
        <div id="reward-screen" class="screen p-6 justify-center space-y-6">
            <div class="text-center">
                <h2 class="text-3xl font-bold text-white">æ·±å¾„çš„å›å“</h2>
                <p class="text-lg text-yellow-400">è·å¾— <span id="reward-currency">0</span> ğŸ”¥</p>
            </div>
            
            <div id="card-reward-options" class="flex-grow">
                <!-- 3å¼ å¡ç‰Œé€‰é¡¹(æ‰‡å½¢)ç”±JSå¡«å…… -->
            </div>
            
            <div class="flex space-x-4 w-full">
                <button id="skip-reward-btn" class="btn btn-secondary w-1/2">è·³è¿‡</button>
                <button id="reroll-reward-btn" class="btn btn-yellow w-1/2 hidden">é‡æŠ½ (1)</button>
            </div>
        </div>

        <!-- 5. äº‹ä»¶å±å¹• -->
        <div id="event-screen" class="screen p-6 justify-center items-center space-y-6 text-center">
            <h2 id="event-title" class="text-3xl font-bold text-white">é­é‡äº‹ä»¶</h2>
            <p id="event-description" class="text-lg text-gray-300">ä¸€ä¸ªå¤è€çš„ç¯ç«åœ¨æ‘‡æ›³ã€‚</p>
            <div id="event-options" class="w-full space-y-3">
                <!-- äº‹ä»¶é€‰é¡¹ç”±JSå¡«å…… -->
            </div>
        </div>

        <!-- 6. æ¸¸æˆç»“æŸå±å¹• -->
        <div id="game-over-screen" class="screen p-6 justify-center items-center text-center space-y-6">
            <h2 id="game-over-title" class="text-4xl font-bold text-red-500">ä½ å€’ä¸‹äº†</h2>
            <div class="text-lg space-y-2">
                <p>ä½ æ·±å…¥åˆ°äº†ç¬¬ <span id="final-floor" class="font-bold text-xl text-white">0</span> å±‚</p>
                <p>ä½ æ”¶é›†äº† <span id="final-currency" class="font-bold text-xl text-yellow-400">0</span> ğŸ”¥ ä½™çƒ¬</p>
            </div>
            <button id="game-over-back-btn" class="btn btn-primary w-full text-lg">è¿”å›ä¸»èœå•</button>
        </div>
        
        <!-- 7. é”»é€ å±å¹• (æ¨¡æ€æ¡†) -->
        <div id="smith-screen" class="screen modal-screen p-4 justify-center items-center">
            <div class="modal-content w-full max-w-sm h-3/4 flex flex-col rounded-lg overflow-hidden">
                <h2 class="text-2xl font-bold text-white text-center p-4">é€‰æ‹©ä¸€å¼ å¡ç‰Œè¿›è¡Œé”»é€ </h2>
                <div id="smith-deck-container" class="flex-grow">
                    <!-- å¡ç‰Œåˆ—è¡¨ç”±JSå¡«å…… -->
                </div>
                <div class="p-4 border-t border-gray-700">
                    <button id="smith-back-btn" class="btn btn-secondary w-full">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

    </div>

    <!-- V1.13: Tooltip æç¤ºæ¡† (HTML) -->
    <div id="tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-desc"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- å…¨å±€çŠ¶æ€å’ŒDOMå¼•ç”¨ ---
            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);
            
            const PROFILE_KEY = 'deepPathEmbersProfile';
            const RUN_KEY = 'deepPathEmbersRun';

            let playerProfile = {}; // å±€å¤–æˆé•¿
            let runState = {}; // å½“å‰å±€å†…çŠ¶æ€
            let cardDefinitions = {}; // å¡ç‰Œå®šä¹‰
            let enemyDefinitions = {}; // æ•Œäººå®šä¹‰
            let pathDefinition = []; // è·¯å¾„å®šä¹‰
            let upgradeDefinitions = {}; // å‡çº§å®šä¹‰
            let statusDefinitions = {}; // çŠ¶æ€å®šä¹‰
            let intentDefinitions = {}; // V1.13: æ„å›¾å®šä¹‰
            
            const GAME_STATES = {
                MAIN_MENU: 'MAIN_MENU',
                UPGRADES: 'UPGRADES',
                GAME_OVER: 'GAME_OVER',
                EVENT: 'EVENT',
                REWARD: 'REWARD',
                SMITHING: 'SMITHING',
                // Combat Sub-states
                PLAYER_TURN: 'PLAYER_TURN', // ç­‰å¾…ç©å®¶è¾“å…¥
                PROCESSING_LOGIC: 'PROCESSING_LOGIC', // ä»»ä½•å¡ç‰Œ/å›åˆé€»è¾‘ç»“ç®—ä¸­
                COMBAT_OVER: 'COMBAT_OVER', // æˆ˜æ–—èƒœåˆ©ï¼Œç­‰å¾…å¥–åŠ±
            };

            const D = { // DOM å¼•ç”¨
                gameContainer: $('#game-container'), 
                animationLayer: $('#animation-layer'), 
                screens: {
                    mainMenu: $('#main-menu-screen'),
                    upgrades: $('#upgrade-screen'),
                    game: $('#game-screen'),
                    rewards: $('#reward-screen'),
                    event: $('#event-screen'),
                    gameOver: $('#game-over-screen'),
                    smith: $('#smith-screen'), 
                },
                mainMenu: {
                    continueBtn: $('#continue-run-btn'),
                    startBtn: $('#start-run-btn'),
                    upgradesBtn: $('#upgrades-menu-btn'),
                    highScore: $('#high-score-display'),
                },
                upgrades: {
                    backBtn: $('#upgrade-back-btn'),
                    currency: $('#currency-display'),
                    optionsContainer: $('#upgrade-options-container'),
                },
                game: {
                    pathDisplay: $('#path-display'),
                    enemyArea: $('#enemy-area'),
                    playerArea: $('#player-area'),
                    handArea: $('#hand-area'),
                    endTurnBtn: $('#end-turn-btn'),
                    playerHPBar: $('#player-hp-bar .hp-bar-fg'),
                    playerHPText: $('#player-hp-text'),
                    playerBlockText: $('#player-block-text'),
                    playerEnergyText: $('#player-energy-text'),
                    playerContainer: $('#player-container'),
                    playerStatusIcons: $('#player-status-area'), 
                    deckCount: $('#deck-count'),
                    discardCount: $('#discard-count'),
                },
                rewards: {
                    options: $('#card-reward-options'),
                    skipBtn: $('#skip-reward-btn'),
                    rerollBtn: $('#reroll-reward-btn'),
                    currency: $('#reward-currency'),
                },
                event: {
                    title: $('#event-title'),
                    description: $('#event-description'),
                    options: $('#event-options'),
                },
                gameOver: {
                    screen: $('#game-over-screen'),
                    title: $('#game-over-title'),
                    backBtn: $('#game-over-back-btn'),
                    finalFloor: $('#final-floor'),
                    finalCurrency: $('#final-currency'),
                },
                smith: { 
                    container: $('#smith-deck-container'),
                    backBtn: $('#smith-back-btn'),
                },
                tooltip: { 
                    el: $('#tooltip'),
                    title: $('#tooltip-title'),
                    desc: $('#tooltip-desc'),
                }
            };

            // --- æ¸¸æˆæ•°æ®å®šä¹‰ ---

            function defineStatus() {
                statusDefinitions = {
                    'vulnerable': {
                        name: 'æ˜“ä¼¤',
                        icon: 'ğŸ›¡ï¸',
                        desc: 'å—åˆ°çš„ <strong>æ”»å‡»</strong> ä¼¤å®³ +50%ã€‚',
                        color: 'orange' 
                    },
                    'weak': {
                        name: 'è™šå¼±',
                        icon: 'âš”ï¸',
                        desc: 'é€ æˆçš„ <strong>æ”»å‡»</strong> ä¼¤å®³ -50%ã€‚',
                        color: 'gray'
                    },
                    'strength': {
                        name: 'åŠ›é‡',
                        icon: 'ğŸ’ª',
                        desc: 'å¢åŠ  <strong>æ”»å‡»</strong> é€ æˆçš„ä¼¤å®³ã€‚',
                        color: 'red'
                    },
                    'exhaust': { 
                        name: 'æ¶ˆè€—',
                        icon: 'ğŸ”¥',
                        desc: 'æ­¤å¡ç‰Œä½¿ç”¨åï¼Œåœ¨æœ¬åœºæˆ˜æ–—ä¸­è¢«ç§»é™¤ç‰Œç»„ï¼ˆä¸ä¼šè¿›å…¥å¼ƒç‰Œå †ï¼‰ã€‚'
                    },
                    'curse': { 
                        name: 'è¯…å’’',
                        icon: 'ğŸŸ£',
                        desc: 'ä¸€å¼ å¹²æ‰°ä½ ç‰Œåº“çš„å¡ç‰Œã€‚'
                    }
                };
            }
            
            function defineIntents() {
                intentDefinitions = {
                    'attack': {
                        name: 'æ”»å‡»',
                        desc: (val) => `æ•Œäººå°†é€ æˆ <strong>${val}</strong> ç‚¹ä¼¤å®³ã€‚`
                    },
                    'attack_multi': {
                        name: 'å¤šæ®µæ”»å‡»',
                        desc: (val, count) => `æ•Œäººå°†é€ æˆ <strong>${val}</strong> ç‚¹ä¼¤å®³ï¼Œå…± <strong>${count}</strong> æ¬¡ã€‚`
                    },
                    'defend': {
                        name: 'é˜²å¾¡',
                        desc: (val) => `æ•Œäººå°†è·å¾— <strong>${val}</strong> ç‚¹æ ¼æŒ¡ã€‚`
                    },
                    'buff': {
                        name: 'å¼ºåŒ– (Buff)',
                        desc: (val) => `æ•Œäººå°†è·å¾— <strong>${val}</strong> å±‚ <strong>åŠ›é‡</strong>ã€‚`
                    },
                    'debuff_vulnerable': {
                        name: 'å‡ç›Š (Debuff)',
                        desc: (val) => `æ•Œäººå°†å¯¹ä½ æ–½åŠ  <strong>${val}</strong> å›åˆ <strong>æ˜“ä¼¤</strong>ã€‚`
                    },
                    'debuff_weak': {
                        name: 'å‡ç›Š (Debuff)',
                        desc: (val) => `æ•Œäººå°†å¯¹ä½ æ–½åŠ  <strong>${val}</strong> å›åˆ <strong>è™šå¼±</strong>ã€‚`
                    },
                    'pollute': {
                        name: 'æ±¡æŸ“',
                        desc: (val) => `æ•Œäººå°† <strong>${val}</strong> å¼  <strong>é»æ¶²</strong> å¡å…¥ä½ çš„å¼ƒç‰Œå †ã€‚`
                    }
                };
            }
            
            function defineCards() {
                cardDefinitions = {
                    // --- åˆå§‹å¡ç‰Œ ---
                    'strike': {
                        id: 'strike', name: 'æ‰“å‡»', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 6 ç‚¹ä¼¤å®³ã€‚',
                        upgradesTo: 'strike_plus',
                        effect: (caster, target) => dealDamage(target, 6, caster),
                    },
                    'strike_plus': {
                        id: 'strike_plus', name: 'æ‰“å‡»+', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 9 ç‚¹ä¼¤å®³ã€‚',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 9, caster),
                    },
                    'defend': {
                        id: 'defend', name: 'é˜²å¾¡', cost: 1, type: 'skill',
                        desc: 'è·å¾— 5 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self',
                        upgradesTo: 'defend_plus',
                        effect: (caster) => addBlock(caster, 5),
                    },
                    'defend_plus': {
                        id: 'defend_plus', name: 'é˜²å¾¡+', cost: 1, type: 'skill',
                        desc: 'è·å¾— 8 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self',
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 8),
                    },
                    
                    // --- æ™®é€šå¡ç‰Œ ---
                    'heavy_strike': {
                        id: 'heavy_strike', name: 'é‡å‡»', cost: 2, type: 'attack',
                        desc: 'é€ æˆ 12 ç‚¹ä¼¤å®³ã€‚',
                        upgradesTo: 'heavy_strike_plus',
                        effect: (caster, target) => dealDamage(target, 12, caster),
                    },
                    'heavy_strike_plus': {
                        id: 'heavy_strike_plus', name: 'é‡å‡»+', cost: 2, type: 'attack',
                        desc: 'é€ æˆ 16 ç‚¹ä¼¤å®³ã€‚',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 16, caster),
                    },
                    'double_hit': {
                        id: 'double_hit', name: 'äºŒè¿å‡»', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 4 ç‚¹ä¼¤å®³ï¼Œ2æ¬¡ã€‚',
                        upgradesTo: 'double_hit_plus',
                        effect: (caster, target) => {
                            dealDamage(target, 4, caster, 0); // V1.14: å»¶è¿Ÿ
                            dealDamage(target, 4, caster, 150);
                        },
                    },
                    'double_hit_plus': {
                        id: 'double_hit_plus', name: 'äºŒè¿å‡»+', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 6 ç‚¹ä¼¤å®³ï¼Œ2æ¬¡ã€‚',
                        upgraded: true,
                        effect: (caster, target) => {
                            dealDamage(target, 6, caster, 0);
                            dealDamage(target, 6, caster, 150);
                        },
                    },
                    'iron_wall': {
                        id: 'iron_wall', name: 'é“å£', cost: 2, type: 'skill',
                        desc: 'è·å¾— 10 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self',
                        upgradesTo: 'iron_wall_plus',
                        effect: (caster) => addBlock(caster, 10),
                    },
                    'iron_wall_plus': {
                        id: 'iron_wall_plus', name: 'é“å£+', cost: 2, type: 'skill',
                        desc: 'è·å¾— 14 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self',
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 14),
                    },
                    'quick_slash': {
                        id: 'quick_slash', name: 'å¿«æ–©', cost: 0, type: 'attack',
                        desc: 'é€ æˆ 3 ç‚¹ä¼¤å®³ã€‚',
                        upgradesTo: 'quick_slash_plus',
                        effect: (caster, target) => dealDamage(target, 3, caster),
                    },
                    'quick_slash_plus': {
                        id: 'quick_slash_plus', name: 'å¿«æ–©+', cost: 0, type: 'attack',
                        desc: 'é€ æˆ 5 ç‚¹ä¼¤å®³ã€‚',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 5, caster),
                    },
                    'vampiric_touch': {
                        id: 'vampiric_touch', name: 'å¸è¡€', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 5 ç‚¹ä¼¤å®³ã€‚å›å¤ 2 ç‚¹ç”Ÿå‘½ã€‚',
                        upgradesTo: 'vampiric_touch_plus',
                        effect: (caster, target) => { 
                            dealDamage(target, 5, caster); 
                            setTimeout(() => healDamage(caster, 2), 200); // ä¼¤å®³åå›è¡€
                        },
                    },
                    'vampiric_touch_plus': {
                        id: 'vampiric_touch_plus', name: 'å¸è¡€+', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 7 ç‚¹ä¼¤å®³ã€‚å›å¤ 3 ç‚¹ç”Ÿå‘½ã€‚',
                        upgraded: true,
                        effect: (caster, target) => { 
                            dealDamage(target, 7, caster);
                            setTimeout(() => healDamage(caster, 3), 200);
                        },
                    },
                    'battle_focus': {
                        id: 'battle_focus', name: 'ä¸“æ³¨', cost: 1, type: 'skill',
                        desc: 'æŠ½ 2 å¼ ç‰Œã€‚',
                        target: 'self',
                        upgradesTo: 'battle_focus_plus',
                        effect: (caster, target, card) => drawCards(2, card),
                    },
                    'battle_focus_plus': {
                        id: 'battle_focus_plus', name: 'ä¸“æ³¨+', cost: 1, type: 'skill',
                        desc: 'æŠ½ 3 å¼ ç‰Œã€‚',
                        target: 'self',
                        upgraded: true,
                        effect: (caster, target, card) => drawCards(3, card),
                    },
                    'break': {
                        id: 'break', name: 'ç ´ç»½', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  2 å±‚<k>æ˜“ä¼¤</k>ã€‚',
                        target: 'enemy', 
                        upgradesTo: 'break_plus',
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 2, caster),
                    },
                    'break_plus': {
                        id: 'break_plus', name: 'ç ´ç»½+', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  3 å±‚<k>æ˜“ä¼¤</k>ã€‚',
                        target: 'enemy',
                        upgraded: true,
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 3, caster),
                    },
                    'demoralize': {
                        id: 'demoralize', name: 'æŒ«å¿—', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  1 å±‚<k>è™šå¼±</k>ã€‚',
                        target: 'enemy',
                        upgradesTo: 'demoralize_plus',
                        effect: (caster, target) => applyStatus(target, 'weak', 1, caster),
                    },
                    'demoralize_plus': {
                        id: 'demoralize_plus', name: 'æŒ«å¿—+', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  2 å±‚<k>è™šå¼±</k>ã€‚',
                        target: 'enemy',
                        upgraded: true,
                        effect: (caster, target) => applyStatus(target, 'weak', 2, caster),
                    },
                    'bulwark': {
                        id: 'bulwark', name: 'å£å’', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 7 ç‚¹ä¼¤å®³ã€‚è‹¥ä½ æœ‰æ ¼æŒ¡ï¼ŒæŠ½ 1 å¼ ç‰Œã€‚',
                        upgradesTo: 'bulwark_plus',
                        effect: (caster, target, card) => {
                            dealDamage(target, 7, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200); // ä¼¤å®³åæŠ½å¡
                            }
                        },
                    },
                    'bulwark_plus': {
                        id: 'bulwark_plus', name: 'å£å’+', cost: 1, type: 'attack',
                        desc: 'é€ æˆ 10 ç‚¹ä¼¤å®³ã€‚è‹¥ä½ æœ‰æ ¼æŒ¡ï¼ŒæŠ½ 1 å¼ ç‰Œã€‚',
                        upgraded: true,
                        effect: (caster, target, card) => {
                            dealDamage(target, 10, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200);
                            }
                        },
                    },
                    'energy_burst': {
                        id: 'energy_burst', name: 'èƒ½é‡çˆ†å‘', cost: 0, type: 'skill',
                        desc: 'è·å¾— 2 ç‚¹èƒ½é‡ âš¡ã€‚',
                        target: 'self',
                        upgradesTo: 'energy_burst_plus',
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 2;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },
                    'energy_burst_plus': {
                        id: 'energy_burst_plus', name: 'èƒ½é‡çˆ†å‘+', cost: 0, type: 'skill',
                        desc: 'è·å¾— 3 ç‚¹èƒ½é‡ âš¡ã€‚',
                        target: 'self',
                        upgraded: true,
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 3;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },
                    'slime_curse': {
                        id: 'slime_curse', name: 'é»æ¶²', cost: 0, type: 'curse',
                        desc: 'æ— ç”¨ã€‚',
                        target: 'self',
                        exhaust: true,
                        effect: () => {}, 
                    }
                };
            }
            
            function defineEnemies() {
                enemyDefinitions = {
                    'goblin': {
                        name: 'å“¥å¸ƒæ—', hp: 20, sprite: 'ğŸ‘º', currency: 3,
                        moves: [
                            { type: 'attack', val: 6, intent: 'âš”ï¸ 6', intentKey: 'attack' },
                            { type: 'attack', val: 8, intent: 'âš”ï¸ 8', intentKey: 'attack' },
                        ]
                    },
                    'slime': {
                        name: 'å²è±å§†', hp: 15, sprite: 'ğŸ¦ ', currency: 2,
                        moves: [
                            { type: 'attack', val: 5, intent: 'âš”ï¸ 5', intentKey: 'attack' },
                            { type: 'defend', val: 3, intent: 'ğŸ›¡ï¸ 3', intentKey: 'defend' }, 
                            { type: 'pollute', val: 1, intent: 'ğŸ¤® 1', intentKey: 'pollute' }, 
                        ]
                    },
                    'orc': {
                        name: 'å…½äºº', hp: 40, sprite: 'ğŸ‘¹', currency: 8,
                        moves: [
                            { type: 'attack', val: 10, intent: 'âš”ï¸ 10', intentKey: 'attack' },
                            { type: 'defend', val: 8, intent: 'ğŸ›¡ï¸ 8', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 2, intent: 'ğŸ’ª+2', intentKey: 'buff' }, 
                        ]
                    },
                    'shadow': {
                        name: 'æš—å½±', hp: 30, sprite: 'ğŸ‘»', currency: 7,
                        moves: [
                            { type: 'attack', val: 7, intent: 'âš”ï¸ 7', intentKey: 'attack' },
                            { type: 'attack', val: 7, intent: 'âš”ï¸ 7', intentKey: 'attack' },
                            { type: 'debuff', status: 'weak', val: 1, intent: 'ğŸ˜µâ€ğŸ’« 1', intentKey: 'debuff_weak' }, 
                        ]
                    },
                    'guardian': {
                        name: 'å®ˆå«', hp: 60, sprite: 'ğŸ—¿', currency: 15,
                        moves: [
                            { type: 'attack', val: 12, intent: 'âš”ï¸ 12', intentKey: 'attack' },
                            { type: 'debuff', status: 'vulnerable', val: 1, intent: 'ğŸ˜µ 1', intentKey: 'debuff_vulnerable' }, 
                            { type: 'defend', val: 15, intent: 'ğŸ›¡ï¸ 15', intentKey: 'defend' },
                        ]
                    },
                    'golem': {
                        name: 'é­”åƒ', hp: 120, sprite: 'ğŸ¤–', currency: 50,
                        moves: [
                            { type: 'attack', val: 15, intent: 'âš”ï¸ 15', intentKey: 'attack' },
                            { type: 'attack_multi', val: 8, count: 2, intent: 'âš”ï¸ 8 (2æ¬¡)', intentKey: 'attack_multi' },
                            { type: 'defend', val: 20, intent: 'ğŸ›¡ï¸ 20', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 3, intent: 'ğŸ’ª+3', intentKey: 'buff' }, 
                            { type: 'pollute', val: 2, intent: 'ğŸ¤® 2', intentKey: 'pollute' }, 
                        ],
                        onTurn: (enemy, onEndCallback) => { 
                            const move = enemy.nextMove;
                            if (move.intentKey === 'attack_multi') { 
                                playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                    takeDamage(runState.player, move.val, enemy, 0); // ç¬¬ä¸€æ¬¡æ”»å‡»
                                    setTimeout(() => {
                                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                            takeDamage(runState.player, move.val, enemy, 0); // ç¬¬äºŒæ¬¡æ”»å‡»
                                            onEndCallback(); // ä¸¤æ¬¡æ”»å‡»åç»“æŸ
                                        });
                                    }, 300); // ä¸¤æ¬¡æ”»å‡»çš„é—´éš”
                                });
                            } else {
                                executeDefaultEnemyMove(enemy, onEndCallback);
                            }
                        }
                    },
                }
            }
            
            function definePath() {
                pathDefinition = [
                    { type: 'M', sprite: 'ğŸ‘º', enemies: ['goblin', 'slime'] },
                    { type: 'M', sprite: 'ğŸ‘º', enemies: ['goblin', 'slime'] },
                    { type: 'M', sprite: 'ğŸ‘º', enemies: ['goblin', 'slime'] },
                    { type: 'R', sprite: 'ğŸ”¥', event: 'rest' },
                    { type: 'M', sprite: 'ğŸ‘¹', enemies: ['orc', 'shadow'] },
                    { type: 'M', sprite: 'ğŸ‘¹', enemies: ['orc', 'shadow'] },
                    { type: 'E', sprite: 'ğŸ—¿', enemies: ['guardian'] },
                    { type: 'R', sprite: 'ğŸ”¥', event: 'rest' },
                    { type: 'M', sprite: 'ğŸ‘¹', enemies: ['orc', 'shadow', 'guardian'] },
                    { type: 'B', sprite: 'ğŸ¤–', enemies: ['golem'] },
                ];
            }
            
            function defineUpgrades() {
                upgradeDefinitions = {
                    'max_hp': {
                        name: 'å¼ºåŒ–ä½“è´¨',
                        desc: 'æœ€å¤§ç”Ÿå‘½å€¼ +5',
                        baseCost: 50,
                        costIncrease: 25,
                        maxLevel: 10,
                        apply: (profile) => profile.baseHp += 5,
                    },
                    'start_energy': {
                        name: 'æ´»åŠ›æºæ³‰',
                        desc: 'åˆå§‹èƒ½é‡ +1',
                        baseCost: 300,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.baseEnergy += 1,
                    },
                    'start_heal': {
                        name: 'åˆå§‹å›å¤',
                        desc: 'å¼€å§‹æ—¶å›å¤ 10 ç‚¹ç”Ÿå‘½',
                        baseCost: 100,
                        costIncrease: 50,
                        maxLevel: 3,
                        apply: (profile) => profile.startHeal += 10,
                    },
                    'greed': { 
                        name: 'è´ªå©ª',
                        desc: 'æˆ˜æ–—èƒœåˆ©æ—¶é¢å¤–è·å¾— 2% ä½™çƒ¬',
                        baseCost: 80,
                        costIncrease: 40,
                        maxLevel: 10,
                        apply: (profile) => profile.greedBonus += 0.02,
                    },
                    'smith_chance': { 
                        name: 'å·¥åŒ ç²¾ç¥',
                        desc: 'é”»é€ æ—¶æœ‰ 5% å‡ ç‡ä¸æ¶ˆè€—ç¯ç«',
                        baseCost: 150,
                        costIncrease: 75,
                        maxLevel: 5,
                        apply: (profile) => profile.smithChance += 0.05,
                    },
                    'reroll_charges': { 
                        name: 'å‘½è¿ä¹‹æ‰‹',
                        desc: 'å¡ç‰Œå¥–åŠ±ç•Œé¢è·å¾— 1 æ¬¡é‡æŠ½æœºä¼š',
                        baseCost: 250,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.rerollCharges += 1,
                    },
                };
            }

            // --- å±€å¤–æˆé•¿ (Profile) & å­˜æ¡£ (Run) ---

            function loadPlayerProfile() {
                const profile = localStorage.getItem(PROFILE_KEY);
                if (profile) {
                    playerProfile = JSON.parse(profile);
                    // ç¡®ä¿æ‰€æœ‰å‡çº§å±æ€§éƒ½å­˜åœ¨
                    if (!playerProfile.upgrades.start_heal) playerProfile.upgrades.start_heal = 0;
                    if (!playerProfile.startHeal) playerProfile.startHeal = 0;
                    if (!playerProfile.upgrades.greed) playerProfile.upgrades.greed = 0;
                    if (!playerProfile.greedBonus) playerProfile.greedBonus = 0;
                    if (!playerProfile.upgrades.smith_chance) playerProfile.upgrades.smith_chance = 0;
                    if (!playerProfile.smithChance) playerProfile.smithChance = 0;
                    if (!playerProfile.upgrades.reroll_charges) playerProfile.upgrades.reroll_charges = 0;
                    if (!playerProfile.rerollCharges) playerProfile.rerollCharges = 0;
                } else {
                    playerProfile = {
                        totalCurrency: 0,
                        highScore: 0,
                        upgrades: { 
                            'max_hp': 0,
                            'start_energy': 0,
                            'start_heal': 0,
                            'greed': 0,
                            'smith_chance': 0,
                            'reroll_charges': 0,
                        },
                        baseHp: 50,
                        baseEnergy: 3,
                        startHeal: 0,
                        greedBonus: 0,
                        smithChance: 0,
                        rerollCharges: 0,
                    };
                    savePlayerProfile();
                }
                updateMainMenuUI();
            }

            function savePlayerProfile() {
                localStorage.setItem(PROFILE_KEY, JSON.stringify(playerProfile));
            }

            function saveRunState() {
                if (!runState || runState.gameState === GAME_STATES.MAIN_MENU || runState.gameState === GAME_STATES.GAME_OVER) {
                    return;
                }
                
                const savableState = { ...runState };
                if (savableState.enemy) {
                    const { dom, ...savableEnemy } = savableState.enemy;
                    savableState.enemy = savableEnemy;
                }
                localStorage.setItem(RUN_KEY, JSON.stringify(savableState));
            }

            function loadRunState() {
                const savedRun = localStorage.getItem(RUN_KEY);
                if (!savedRun) return;

                runState = JSON.parse(savedRun);

                // é‡æ–° "é™„åŠ " (Hydrate) DOM å¼•ç”¨
                if (runState.enemy) {
                    runState.enemy.dom = {
                        container: $(`#enemy-container-0`),
                        intent: $(`#enemy-intent-0`),
                        sprite: $(`#enemy-sprite-0`),
                        hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                        hpText: $(`#enemy-hp-text-0`),
                        blockText: $(`#enemy-block-text-0`),
                        statusIcons: $(`#enemy-status-icons-0`),
                    };
                }
                
                // æ¢å¤æ¸¸æˆ
                updatePathDisplay();
                updateAllUI();
                setGameState(runState.gameState); 
            }
            
            function updateMainMenuUI() {
                D.mainMenu.highScore.textContent = playerProfile.highScore;
            }
            
            function showUpgradeScreen() {
                D.upgrades.currency.textContent = `${playerProfile.totalCurrency} ğŸ”¥`;
                const container = D.upgrades.optionsContainer;
                container.innerHTML = '';
                
                for (const id in upgradeDefinitions) {
                    const def = upgradeDefinitions[id];
                    const level = playerProfile.upgrades[id] || 0;
                    const cost = def.baseCost + (def.costIncrease * level);
                    const canBuy = playerProfile.totalCurrency >= cost && level < def.maxLevel;

                    let buttonText;
                    if (level >= def.maxLevel) {
                        buttonText = 'å·²è¾¾ä¸Šé™';
                    } else {
                        buttonText = `è´­ä¹° (èŠ±è´¹ ${cost} ğŸ”¥)`;
                    }

                    const el = document.createElement('div');
                    el.className = 'p-4 bg-gray-800 rounded-lg border border-gray-700';
                    el.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="text-lg font-bold text-white">${def.name} (Lv ${level}/${def.maxLevel})</h4>
                                <p class="text-sm text-gray-400">${def.desc}</p>
                            </div>
                            <button class="btn ${canBuy ? 'btn-primary' : 'btn-secondary opacity-50'}" data-upgrade-id="${id}" ${!canBuy ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    `;
                    container.appendChild(el);
                }
                
                container.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', (e) => buyUpgrade(e.target.dataset.upgradeId));
                });
                
                setGameState(GAME_STATES.UPGRADES);
            }

            function buyUpgrade(id) {
                const def = upgradeDefinitions[id];
                const level = playerProfile.upgrades[id] || 0;
                const cost = def.baseCost + (def.costIncrease * level);
                
                if (playerProfile.totalCurrency >= cost && level < def.maxLevel) {
                    playerProfile.totalCurrency -= cost;
                    playerProfile.upgrades[id] += 1;
                    def.apply(playerProfile); // åº”ç”¨æ°¸ä¹…å±æ€§
                    
                    savePlayerProfile();
                    showUpgradeScreen(); // åˆ·æ–°UI
                }
            }

            // --- å±€å†…æ¸¸æˆ (Run) ---

            function startNewRun() {
                runState = {
                    player: {
                        maxHp: playerProfile.baseHp,
                        hp: Math.min(playerProfile.baseHp, playerProfile.baseHp + playerProfile.startHeal),
                        maxEnergy: playerProfile.baseEnergy,
                        energy: playerProfile.baseEnergy,
                        block: 0,
                        isPlayer: true,
                        status: { vulnerable: 0, weak: 0, strength: 0 }, 
                        greedBonus: playerProfile.greedBonus,
                        smithChance: playerProfile.smithChance,
                        rerollCharges: playerProfile.rerollCharges,
                    },
                    deck: createStartDeck(),
                    hand: [],
                    discard: [],
                    exhaustPile: [],
                    currentFloor: 0,
                    runCurrency: 0,
                    gameState: null,
                    selectedCardId: null,
                };
                
                updatePathDisplay();
                startNextEncounter();
            }
            
            function setGameState(newState) {
                if (runState.gameState === GAME_STATES.GAME_OVER && newState !== GAME_STATES.MAIN_MENU) {
                    return; 
                }
                
                runState.gameState = newState;
                
                Object.values(D.screens).forEach(screen => screen.classList.remove('active'));
                
                switch (newState) {
                    case GAME_STATES.MAIN_MENU:
                        D.screens.mainMenu.classList.add('active');
                        break;
                    case GAME_STATES.UPGRADES:
                        D.screens.upgrades.classList.add('active');
                        break;
                    case GAME_STATES.GAME_OVER:
                        D.screens.gameOver.classList.add('active');
                        break;
                    case GAME_STATES.EVENT:
                        D.screens.event.classList.add('active');
                        break;
                    case GAME_STATES.REWARD:
                        D.screens.rewards.classList.add('active');
                        break;
                    case GAME_STATES.SMITHING:
                        D.screens.smith.classList.add('active');
                        break;
                    case GAME_STATES.PLAYER_TURN:
                    case GAME_STATES.PROCESSING_LOGIC:
                    case GAME_STATES.COMBAT_OVER:
                        D.screens.game.classList.add('active');
                        break;
                }
                
                if (newState === GAME_STATES.PLAYER_TURN) {
                    D.game.endTurnBtn.disabled = false;
                    D.game.endTurnBtn.classList.add('btn-primary');
                    D.game.endTurnBtn.classList.remove('opacity-50');
                } else {
                    D.game.endTurnBtn.disabled = true;
                    D.game.endTurnBtn.classList.remove('btn-primary');
                    D.game.endTurnBtn.classList.add('opacity-50');
                }
                
                if (newState === GAME_STATES.REWARD) {
                    if (runState.player.rerollCharges > 0) {
                        D.rewards.rerollBtn.classList.remove('hidden');
                        D.rewards.rerollBtn.textContent = `é‡æŠ½ (${runState.player.rerollCharges})`;
                        D.rewards.rerollBtn.disabled = false;
                    } else {
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                }
            }

            function createStartDeck() {
                let deck = [];
                for(let i=0; i<6; i++) deck.push(createCardInstance(cardDefinitions.strike));
                for(let i=0; i<4; i++) deck.push(createCardInstance(cardDefinitions.defend));
                return shuffle(deck);
            }
            
            function createCardInstance(cardDef) {
                return { ...cardDef, instanceId: Math.random().toString(36).substring(2, 9) };
            }

            function startNextEncounter() {
                const floorData = pathDefinition[runState.currentFloor];
                if (!floorData) {
                    gameOver(true); // æ¸¸æˆèƒœåˆ©
                    return;
                }
                
                if (floorData.type === 'M' || floorData.type === 'E' || floorData.type === 'B') {
                    const enemyId = floorData.enemies[Math.floor(Math.random() * floorData.enemies.length)];
                    const enemyDef = enemyDefinitions[enemyId];
                    
                    runState.enemy = {
                        ...enemyDef,
                        hp: enemyDef.hp, maxHp: enemyDef.hp,
                        block: 0, nextMove: null, isPlayer: false,
                        status: { vulnerable: 0, weak: 0, strength: 0 }, 
                        dom: { 
                            container: $(`#enemy-container-0`),
                            intent: $(`#enemy-intent-0`),
                            sprite: $(`#enemy-sprite-0`),
                            hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                            hpText: $(`#enemy-hp-text-0`),
                            blockText: $(`#enemy-block-text-0`),
                            statusIcons: $(`#enemy-status-icons-0`),
                        }
                    };
                    startPlayerTurn();
                } else if (floorData.type === 'R') {
                    showEventScreen(floorData.event);
                }
            }
            
            function showEventScreen(eventId) {
                if (eventId === 'rest') {
                    D.event.title.textContent = 'ç¯ç«';
                    D.event.description.textContent = 'ä¸€ä¸ªå¤è€çš„ç¯ç«åœ¨æ‘‡æ›³ã€‚ä½ æ„Ÿåˆ°ä¸€é˜µæ¸©æš–ã€‚';
                    D.event.options.innerHTML = `
                        <button class="btn btn-primary w-full" data-choice="rest">ä¼‘æ¯ (å›å¤ 30% HP)</button>
                        <button class="btn btn-secondary w-full" data-choice="smith">é”»é€  (å‡çº§ä¸€å¼ å¡)</button>
                        <button class="btn btn-secondary w-full" data-choice="skip">ç¦»å¼€</button>
                    `;
                    D.event.options.querySelector('[data-choice="rest"]').onclick = () => {
                        healDamage(runState.player, Math.floor(runState.player.maxHp * 0.3));
                        proceedToNextFloor();
                    };
                    D.event.options.querySelector('[data-choice="smith"]').onclick = () => {
                        showSmithScreen();
                    };
                     D.event.options.querySelector('[data-choice="skip"]').onclick = proceedToNextFloor;
                }
                setGameState(GAME_STATES.EVENT);
            }
            
            function showSmithScreen() {
                const container = D.smith.container;
                container.innerHTML = '';
                const allCards = [...runState.deck, ...runState.discard, ...runState.hand]
                                 .filter(c => c.type !== 'curse'); 
                
                allCards.forEach(card => {
                    const cardEl = createCardElement(card, card.instanceId);
                    const canUpgrade = !card.upgraded && card.upgradesTo;
                    
                    if (canUpgrade) {
                        cardEl.classList.add('can-upgrade');
                        cardEl.addEventListener('click', () => upgradeCard(card.instanceId));
                    }
                    container.appendChild(cardEl);
                });
                setGameState(GAME_STATES.SMITHING);
            }
            
            function upgradeCard(instanceId) {
                const locations = ['deck', 'discard', 'hand'];
                for (const loc of locations) {
                    const index = runState[loc].findIndex(c => c.instanceId === instanceId);
                    if (index !== -1) {
                        const oldCard = runState[loc][index];
                        if (oldCard.upgradesTo) {
                            const newCardDef = cardDefinitions[oldCard.upgradesTo];
                            runState[loc][index] = { ...newCardDef, instanceId: oldCard.instanceId };
                            
                            if (Math.random() < runState.player.smithChance) {
                                D.event.description.textContent = "ä½ çµå…‰ä¸€é—ªï¼Œé”»é€ æœªæ¶ˆè€—ç¯ç«ï¼";
                                setGameState(GAME_STATES.EVENT);
                            } else {
                                proceedToNextFloor(); 
                            }
                            return; 
                        }
                    }
                }
            }
            
            function clearPlayerCombatStatus() {
                runState.player.block = 0;
                // V1.14: ä¿®æ­£ï¼Œåªæ¸…é™¤ä¼šè¡°å‡çš„çŠ¶æ€
                runState.player.status.vulnerable = 0;
                runState.player.status.weak = 0;
                // runState.player.status.strength = 0; // åŠ›é‡æ˜¯æ°¸ä¹…çš„
                
                updateEntityUI(runState.player);
            }
            
            function proceedToNextFloor() {
                // ã€V1.13 BUG FIXã€‘: åœ¨è¿›å…¥ä¸‹ä¸€å±‚æ—¶æ¸…é™¤ç©å®¶çš„æˆ˜æ–—çŠ¶æ€
                clearPlayerCombatStatus(); 
                
                runState.currentFloor++;
                updatePathDisplay();
                saveRunState(); // ä¿å­˜è¿›åº¦
                startNextEncounter();
            }

            function startPlayerTurn() {
                setGameState(GAME_STATES.PROCESSING_LOGIC); // V1.14: å›åˆå¼€å§‹æ—¶é”å®šï¼Œé˜²æ­¢æŠ½å¡æ—¶ç‚¹å‡»
                runState.player.energy = runState.player.maxEnergy;
                runState.player.block = 0; // é‡ç½®ç©å®¶æ ¼æŒ¡
                
                runState.selectedCardId = null;
                
                if (runState.enemy && runState.enemy.hp > 0) { 
                    runState.enemy.nextMove = runState.enemy.moves[Math.floor(Math.random() * runState.enemy.moves.length)];
                }
                
                updateAllUI(); // å…ˆæ›´æ–°ä¸€æ¬¡UI (æ˜¾ç¤ºæ•Œäººæ„å›¾ç­‰)
                
                // V1.14: drawCards ç°åœ¨æœ‰åŠ¨ç”», å¹¶åœ¨ç»“æŸåè®¾ç½®ç©å®¶å›åˆ
                drawCards(5, null, () => {
                    setGameState(GAME_STATES.PLAYER_TURN); // <-- è½®åˆ°ç©å®¶ï¼Œè§£é”è¾“å…¥
                }); 
            }

            function endPlayerTurn() {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); // <-- é”å®šæ¸¸æˆ
                saveRunState(); // ä¿å­˜è¿›åº¦
                
                runState.selectedCardId = null;
                
                runState.discard = [...runState.discard, ...runState.hand];
                runState.hand = [];
                
                // åœ¨ç©å®¶å›åˆç»“æŸæ—¶ç»“ç®—ç©å®¶çŠ¶æ€
                tickDownStatus(runState.player);
                
                updateHandUI(); // æ¸…ç©ºæ‰‹ç‰ŒUI
                updateEntityUI(runState.player); // æ›´æ–°UIä»¥æ˜¾ç¤ºï¼ˆå¯èƒ½ï¼‰å‡å°‘çš„çŠ¶æ€
                
                setTimeout(() => enemyTurn(), 500); // 0.5ç§’åæ•Œäººè¡ŒåŠ¨
            }
            
            function enemyTurn() {
                const enemy = runState.enemy;
                let onEndCallback = null; 

                onEndCallback = () => {
                    updateAllUI(); // ç¡®ä¿åŠ¨ç”»åçš„UIæ˜¯æœ€ç»ˆçŠ¶æ€
                    
                    if (runState.player.hp <= 0) {
                        gameOver(false); // ç©å®¶æ­»äº¡
                    } else {
                        // å°†çŠ¶æ€ç»“ç®—å’ŒUIæ›´æ–°ç§»åˆ° setTimeout *å†…éƒ¨*
                        setTimeout(() => {
                            if (enemy) {
                                tickDownStatus(enemy); // åœ¨æ­¤ç»“ç®—æ•ŒäººçŠ¶æ€
                                updateEntityUI(enemy); // æ›´æ–°æ•ŒäººUI
                            }
                            startPlayerTurn(); // ç„¶åå¼€å§‹ç©å®¶å›åˆ
                        }, 500); 
                    }
                };
                
                if (enemy) {
                    enemy.block = 0; // åœ¨æ•Œäººè¡ŒåŠ¨ *ä¹‹å‰* æ¸…é™¤ä»–ä»¬ä¸Šä¸€å›åˆçš„æ ¼æŒ¡
                    updateEntityUI(enemy); // ç«‹å³æ›´æ–°UI
                }
                
                if (enemy && enemy.hp > 0) { // æ•Œäººå¿…é¡»æ´»ç€æ‰èƒ½è¡ŒåŠ¨
                    if (enemy.onTurn) { 
                        enemy.onTurn(enemy, onEndCallback); 
                    } else if (enemy.nextMove) {
                        executeDefaultEnemyMove(enemy, onEndCallback); 
                    } else {
                        onEndCallback(); // æ•Œäººæ²¡åŠ¨ä½œ (e.g. çœ©æ™•)
                    }
                } else {
                    onEndCallback(); // æ•Œäººå·²æ­»
                }
            }
            
            function executeDefaultEnemyMove(enemy, onEndCallback) {
                const move = enemy.nextMove;
                if (!move) {
                    onEndCallback();
                    return;
                }
                
                let animationDone = false;
                let logicDone = false;
                
                const checkEnd = () => {
                    if (animationDone && logicDone) onEndCallback();
                };
                
                // 1. æ‰§è¡ŒåŠ¨ç”»
                switch (move.type) {
                    case 'attack':
                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                            animationDone = true;
                            checkEnd();
                        });
                        break;
                    case 'defend':
                        addBlock(enemy, move.val); // addBlock å†…éƒ¨æœ‰åŠ¨ç”»
                        animationDone = true;
                        break;
                    case 'buff':
                    case 'debuff':
                    case 'pollute':
                        executeEnemyLogic(move, enemy, () => {
                            animationDone = true; // åŠ¨ç”»åœ¨é€»è¾‘å†…éƒ¨å¤„ç†
                            checkEnd();
                        });
                        logicDone = true; // é€»è¾‘å’ŒåŠ¨ç”»æ˜¯ä¸€ä½“çš„
                        return; // æå‰è¿”å›
                    default:
                        animationDone = true;
                }
                
                // 2. æ‰§è¡Œé€»è¾‘ (åœ¨çŸ­æš‚å»¶è¿Ÿå, æ¨¡æ‹Ÿæ”»å‡»å‘½ä¸­)
                setTimeout(() => {
                    executeEnemyLogic(move, enemy, () => {
                        logicDone = true;
                        checkEnd();
                    });
                }, 250); // æ”»å‡»åŠ¨ç”»ä¸­ç‚¹
            }
            
            function executeEnemyLogic(move, enemy, onLogicEnd = () => {}) {
                switch (move.type) {
                    case 'attack':
                        takeDamage(runState.player, move.val, enemy);
                        onLogicEnd();
                        break;
                    case 'defend':
                        // addBlock å·²ç»åœ¨ move æ‰§è¡Œæ—¶è°ƒç”¨äº†
                        onLogicEnd();
                        break;
                    case 'buff':
                        applyStatus(enemy, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'debuff':
                        applyStatus(runState.player, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'pollute':
                        addCardToDiscard(cardDefinitions.slime_curse, move.val, enemy, onLogicEnd);
                        break;
                    default:
                        onLogicEnd();
                }
            }

            // --- å¡ç‰Œé€»è¾‘ ---
            
            // V1.14: é‡æ„æŠ½å¡åŠ¨ç”»
            function drawCards(amount, sourceCard = null, onAllCardsDrawn = () => {}) {
                let handRect = D.game.handArea.getBoundingClientRect();
                let deckRect = D.game.deckCount.getBoundingClientRect();
                let drawnCardsData = []; // å­˜å‚¨å¡ç‰Œæ•°æ®
                
                for (let i = 0; i < amount; i++) {
                    if (runState.deck.length === 0) {
                        if (runState.discard.length === 0) break; 
                        runState.deck = shuffle(runState.discard);
                        runState.discard = [];
                        updateDeckDiscardUI();
                    }
                    const card = runState.deck.pop();
                    runState.hand.push(card);
                    drawnCardsData.push(card);
                }
                
                updateDeckDiscardUI(); // æ›´æ–°ç‰Œå †æ•°é‡

                if (drawnCardsData.length === 0) {
                    onAllCardsDrawn();
                    return;
                }

                // V1.14: æ’­æ”¾åŠ¨ç”»
                drawnCardsData.forEach((card, index) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    cardEl.classList.add('drawing'); // åˆå§‹çŠ¶æ€ (é€æ˜, åœ¨ç‰Œå †)
                    
                    const startX = (deckRect.left + deckRect.width / 2) - (handRect.left + handRect.width / 2);
                    const startY = (deckRect.top + deckRect.height / 2) - (handRect.top + handRect.height / 2);
                    cardEl.style.transform = `translate(${startX}px, ${startY}px) scale(0.5)`;
                    
                    D.game.handArea.appendChild(cardEl); // V1.14: ç›´æ¥æ·»åŠ åˆ° handArea

                    // å»¶è¿Ÿæ’­æ”¾
                    setTimeout(() => {
                        cardEl.classList.remove('drawing'); // ç§»é™¤åˆå§‹çŠ¶æ€
                        cardEl.style.transform = ``; // V1.14: æ¸…é™¤ transform, è®© CSS flexbox æ¥ç®¡
                        cardEl.style.position = 'relative'; 
                        
                        // åŠ¨ç”»ç»“æŸåï¼Œé‡æ–°å¸ƒå±€
                        if (index === drawnCardsData.length - 1) { // ä»…æœ€åä¸€å¼ å¡
                            setTimeout(() => {
                                updateHandUI(); // V1.14: é‡æ–°æ¸²æŸ“æ‰€æœ‰å¡ç‰Œä»¥è·å¾—æ­£ç¡®çš„ flex å¸ƒå±€
                                onAllCardsDrawn(); // V1.14: è°ƒç”¨å›è°ƒ
                            }, 400); // åŠ¨ç”»æ—¶é•¿
                        }
                    }, (sourceCard ? 0 : index * 100) + 50); // å¦‚æœæ˜¯å¡ç‰Œæ•ˆæœæŠ½å¡ï¼Œåˆ™ç«‹å³æ’­æ”¾
                });
            }
            
            function addCardToDiscard(cardDef, amount, source = null, onEndCallback = () => {}) {
                const targetEl = D.game.discardCount.parentElement; // å¼ƒç‰Œå †çš„DOM
                const sourceEl = source?.dom?.container || D.game.enemyArea;
                
                for(let i = 0; i < amount; i++) {
                    createAndFireProjectile(sourceEl, targetEl, 'ğŸŸ£', () => {
                        runState.discard.push(createCardInstance(cardDef));
                        updateDeckDiscardUI();
                        if (i === amount - 1) onEndCallback();
                    });
                }
            }
            
            function onCardClick(cardInstanceId) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                const card = runState.hand.find(c => c.instanceId === cardInstanceId);
                if (!card || runState.player.energy < card.cost) return;
                if (card.type === 'curse') return;

                if (card.target === 'self') {
                    playCard(card, runState.player);
                    return;
                }
                
                if (card.target === 'enemy') { 
                    if (runState.selectedCardId === cardInstanceId) {
                        runState.selectedCardId = null;
                        updateHandUI();
                        updateTargetHighlights(null);
                    } else {
                        runState.selectedCardId = cardInstanceId;
                        updateHandUI();
                        updateTargetHighlights('enemy_skill');
                    }
                     return;
                }
                
                if (card.type === 'attack') {
                    if (runState.selectedCardId === cardInstanceId) {
                        runState.selectedCardId = null;
                        updateHandUI();
                        updateTargetHighlights(null);
                    } else {
                        runState.selectedCardId = cardInstanceId;
                        updateHandUI();
                        updateTargetHighlights(card.type);
                    }
                }
            }
            
            function onEnemyClick(enemy) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
                
                const card = runState.hand.find(c => c.instanceId === runState.selectedCardId);
                if (!card) return;
                
                if (card.type === 'attack' || card.target === 'enemy') {
                    playCard(card, enemy);
                }
            }
            
            function onPlayerClick() {
                 if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
            }

            function playCard(card, target) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); // <-- é”å®šæ¸¸æˆ
                
                runState.player.energy -= card.cost;
                runState.hand = runState.hand.filter(c => c.instanceId !== card.instanceId);
                
                if (card.exhaust) {
                    runState.exhaustPile.push(card);
                } else {
                    runState.discard.push(card);
                }
                
                runState.selectedCardId = null;
                updateTargetHighlights(null);
                updateHandUI(); // ç«‹å³ä»æ‰‹ä¸­ç§»é™¤å¡ç‰Œ

                card.effect(runState.player, target, card);
                
                // V1.14: åŠ¨ç”»æ—¶é—´è®¡ç®—
                let animationTime = 200; // é»˜è®¤
                if (card.type === 'attack') animationTime = 500;
                if (card.id.includes('double_hit')) animationTime = 700;
                if (card.id.includes('bulwark') && runState.player.block > 0) animationTime = 700; // æ”»å‡»+æŠ½å¡
                if (card.id.includes('battle_focus')) animationTime = 1000; // æŠ½å¡
                
                setTimeout(() => {
                    updateAllUI(); // æ›´æ–°UIä»¥æ˜¾ç¤ºèƒ½é‡å˜åŒ–å’Œå¡ç‰Œæ•ˆæœ
                    
                    if (runState.enemy.hp <= 0) {
                        setGameState(GAME_STATES.COMBAT_OVER);
                        enemyKilled();
                    } else if (runState.player.hp <= 0) {
                        gameOver(false);
                    } else {
                        updateHandUI(); // åˆ·æ–°èƒ½é‡é«˜äº®
                        setGameState(GAME_STATES.PLAYER_TURN); // æˆ˜æ–—ç»§ç»­
                    }
                }, animationTime); 
            }
            
            function enemyKilled() {
                clearPlayerCombatStatus(); 
                
                const currencyGained = Math.floor(runState.enemy.currency * (1 + runState.player.greedBonus));
                runState.runCurrency += currencyGained;
                setTimeout(() => showRewardScreen(currencyGained), 1000); 
            }
            
            function showRewardScreen(currencyGained) {
                D.rewards.currency.textContent = `${currencyGained} ğŸ”¥`;
                generateRewardOptions();
                setGameState(GAME_STATES.REWARD);
            }
            
            function generateRewardOptions() {
                const optionsContainer = D.rewards.options;
                optionsContainer.innerHTML = '';
                
                const cardPool = [
                    'heavy_strike', 'double_hit', 'iron_wall', 'quick_slash', 
                    'vampiric_touch', 'battle_focus',
                    'break', 'demoralize', 'bulwark', 'energy_burst' 
                ];
                const options = shuffle(cardPool).slice(0, 3); 
                
                options.forEach(cardId => {
                    const cardDef = cardDefinitions[cardId];
                    const cardEl = createCardElement(cardDef);
                    cardEl.classList.add('reward-card'); 
                    cardEl.addEventListener('click', () => selectReward(cardDef));
                    optionsContainer.appendChild(cardEl);
                });
            }
            
            function selectReward(cardDef) {
                if (cardDef) { 
                    runState.deck.push(createCardInstance(cardDef)); 
                }
                proceedToNextFloor();
            }
            
            // --- æˆ˜æ–—æ•°å€¼ ---
            
            function applyStatus(target, status, duration, source, onEndCallback = () => {}) {
                const def = statusDefinitions[status];
                const sourceEl = source.isPlayer ? D.game.playerContainer : source.dom.container;
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                
                let iconHTML = '...';
                switch(status) {
                    case 'vulnerable': iconHTML = 'ğŸŸ '; break;
                    case 'weak': iconHTML = 'ğŸ”˜'; break;
                    case 'strength': iconHTML = 'ğŸ”´'; break;
                }
                
                createAndFireProjectile(sourceEl, targetEl, iconHTML, () => {
                    if (status === 'strength') {
                        target.status.strength = (target.status.strength || 0) + duration;
                    } else {
                        target.status[status] = (target.status[status] || 0) + duration;
                    }
                    updateEntityUI(target);
                    onEndCallback();
                });
            }

            function tickDownStatus(target) {
                if (target.status.vulnerable > 0) target.status.vulnerable--;
                if (target.status.weak > 0) target.status.weak--;
                // Strength (åŠ›é‡) ä¸ä¼šè¡°å‡
            }
            
            // V1.14: å¢åŠ  delay
            function dealDamage(target, amount, source, delay = 0) {
                setTimeout(() => {
                    let modifiedAmount = amount;
                    
                    if (source && source.status.strength > 0) {
                        modifiedAmount += source.status.strength;
                    }
                    
                    if (source && source.status.weak > 0) {
                        modifiedAmount = Math.floor(modifiedAmount * 0.5);
                    }
                    
                    let isVulnerable = target.status.vulnerable > 0;
                    if (isVulnerable) {
                        modifiedAmount = Math.floor(modifiedAmount * 1.5);
                    }

                    let damageDealt = modifiedAmount;
                    if (target.block > 0) {
                        if (target.block >= damageDealt) {
                            target.block -= damageDealt;
                            damageDealt = 0;
                        } else {
                            damageDealt -= target.block;
                            target.block = 0;
                        }
                    }
                    
                    target.hp -= damageDealt;
                    if (target.hp < 0) target.hp = 0; 
                    
                    if (damageDealt > 0) {
                        const floatType = isVulnerable ? 'damage vulnerable' : 'damage';
                        showFloatingText(`-${damageDealt}`, target.isPlayer ? D.game.playerContainer : target.dom.container, floatType);
                        playAnimation(target.isPlayer ? D.game.playerContainer : target.dom.sprite, 'anim-shake');
                    }
                    
                    updateEntityUI(target);
                }, delay);
            }
            
            function takeDamage(target, amount, source) {
                dealDamage(target, amount, source, 0);
            }
            
            function addBlock(target, amount) {
                target.block += amount;
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block');
                
                const animEl = document.createElement('div');
                animEl.className = 'anim-block-shield';
                animEl.innerHTML = 'ğŸ›¡ï¸';
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                targetEl.appendChild(animEl);
                animEl.addEventListener('animationend', () => animEl.remove());
                
                updateEntityUI(target);
            }
            
            function healDamage(target, amount) {
                target.hp = Math.min(target.maxHp, target.hp + amount);
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block-float text-green-500'); // ç»¿è‰²
                updateEntityUI(target);
            }
            
            function gameOver(isWin) {
                if (runState.gameState === GAME_STATES.GAME_OVER) return; 
                
                localStorage.removeItem(RUN_KEY); // æ¸…é™¤å­˜æ¡£
                
                playerProfile.totalCurrency += runState.runCurrency;
                if (runState.currentFloor > playerProfile.highScore) {
                    playerProfile.highScore = runState.currentFloor;
                }
                savePlayerProfile();
                
                if (isWin) {
                    D.gameOver.title.textContent = 'ä½ èƒœåˆ©äº†ï¼';
                    D.gameOver.title.classList.remove('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} ğŸ”¥`;
                } else {
                    D.gameOver.title.textContent = 'ä½ å€’ä¸‹äº†';
                    D.gameOver.title.classList.add('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} ğŸ”¥`;
                }
                setGameState(GAME_STATES.GAME_OVER);
            }

            // --- æ¸²æŸ“ / UI ---
            
            function updateAllUI() {
                if (!runState || !runState.player) return; 

                updateEntityUI(runState.player);
                D.game.playerEnergyText.textContent = `${runState.player.energy}/${runState.player.maxEnergy}`;
                
                if (runState.enemy) {
                    updateEntityUI(runState.enemy);
                    const e = runState.enemy;
                    e.dom.sprite.textContent = e.sprite;
                    if (e.hp > 0 && e.nextMove) {
                        e.dom.intent.innerHTML = `<span>${e.nextMove.intent}</span>`;
                        e.dom.intent.dataset.intentKey = e.nextMove.intentKey;
                        e.dom.intent.dataset.intentVal = e.nextMove.val || 0;
                        e.dom.intent.dataset.intentCount = e.nextMove.count || 0;
                        e.dom.intent.classList.remove('hidden');
                    } else {
                        e.dom.intent.classList.add('hidden');
                    }
                }
                
                updateDeckDiscardUI();
            }
            
            function updateEntityUI(entity) {
                if (!entity) return;

                let hpBar, hpText, blockText, statusIconContainer;
                
                if (entity.isPlayer) {
                    hpBar = D.game.playerHPBar;
                    hpText = D.game.playerHPText;
                    blockText = D.game.playerBlockText;
                    statusIconContainer = D.game.playerStatusIcons; 
                } else if (entity.dom) {
                    hpBar = entity.dom.hpBar;
                    hpText = entity.dom.hpText;
                    blockText = entity.dom.blockText;
                    statusIconContainer = entity.dom.statusIcons;
                } else {
                    return; 
                }
                
                // HP
                if (hpBar) {
                    hpBar.style.width = `${Math.max(0, (entity.hp / entity.maxHp) * 100)}%`;
                }
                if (hpText) {
                    hpText.textContent = `${entity.hp} / ${entity.maxHp}`;
                }
                
                // Block
                if (blockText) {
                    if (entity.block > 0) {
                        blockText.textContent = `ğŸ›¡ï¸ ${entity.block}`;
                        blockText.classList.remove('hidden');
                    } else {
                        blockText.classList.add('hidden');
                    }
                }
                
                // Status Icons
                if (statusIconContainer) {
                    statusIconContainer.innerHTML = ''; // æ¸…ç©ºæ—§å›¾æ ‡
                    for (const statusId in entity.status) {
                        const duration = entity.status[statusId];
                        if (duration > 0) { // åªæ¸²æŸ“æ¿€æ´»çš„çŠ¶æ€
                            const def = statusDefinitions[statusId];
                            if (!def) continue; 

                            let durationText = duration;
                            if (statusId === 'strength') {
                                durationText = `+${duration}`; // åŠ›é‡æ˜¾ç¤ºå±‚æ•°
                            }

                            const iconEl = document.createElement('div');
                            iconEl.className = `status-icon status-${def.color}`; 
                            iconEl.innerHTML = `<span>${durationText}</span>`; 
                            iconEl.dataset.statusId = statusId; // ç”¨äº tooltip
                            
                            statusIconContainer.appendChild(iconEl);
                        }
                    }
                }
            }
            
            // V1.14: é‡æ„æ‰‹ç‰ŒUI
            function updateHandUI() {
                const hand = runState.hand;
                const handArea = D.game.handArea;
                
                // 1. æ¸…ç©º (V1.14: ç®€å•ç²—æš´, ä¿è¯æ¸…ç©ºåŠ¨ç”»æ®‹ç•™)
                handArea.innerHTML = ''; 
                
                // 2. é‡æ–°æ¸²æŸ“
                hand.forEach((card, index) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    
                    // æ›´æ–°é«˜äº®
                    const isPlayable = runState.player.energy >= card.cost;
                    if (isPlayable) cardEl.classList.add('playable');
                    else cardEl.classList.add('unplayable');
                    
                    if (card.instanceId === runState.selectedCardId) {
                        cardEl.classList.add('selected');
                    }
                    
                    handArea.appendChild(cardEl);
                });
            }
            
            function createCardElement(cardDef, instanceId = null) {
                const el = document.createElement('div');
                el.className = 'card';
                if(instanceId) {
                    el.classList.add('hand-card');
                    el.id = `hand-card-${instanceId}`; 
                    el.dataset.instanceId = instanceId;
                }
                if(cardDef.upgraded) el.classList.add('upgraded');
                if(cardDef.exhaust) el.classList.add('exhaust');
                if(cardDef.type === 'curse') el.classList.add('curse');
                
                let typeText = '';
                let typeColor = '';
                switch(cardDef.type) {
                    case 'attack': typeText = 'æ”»å‡»'; typeColor = 'text-red-400'; break;
                    case 'skill': typeText = 'æŠ€èƒ½'; typeColor = 'text-blue-400'; break;
                    case 'curse': typeText = 'è¯…å’’'; typeColor = 'text-purple-400'; break;
                }
                
                let descHTML = cardDef.desc;
                if (cardDef.exhaust) descHTML += " (<k>æ¶ˆè€—</k>)";
                if (cardDef.type === 'curse') descHTML += " (<k>è¯…å’’</k>)";
                
                descHTML = descHTML.replace(/<k>æ˜“ä¼¤<\/k>/g, '<span class="keyword" data-keyword="vulnerable">æ˜“ä¼¤</span>');
                descHTML = descHTML.replace(/<k>è™šå¼±<\/k>/g, '<span class="keyword" data-keyword="weak">è™šå¼±</span>');
                descHTML = descHTML.replace(/<k>æ¶ˆè€—<\/k>/g, '<span class="keyword" data-keyword="exhaust">æ¶ˆè€—</span>');
                descHTML = descHTML.replace(/<k>è¯…å’’<\/k>/g, '<span class="keyword" data-keyword="curse">è¯…å’’</span>');
                
                el.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="card-cost">${cardDef.cost}</div>
                        <div class="text-xs ${typeColor}">${typeText}</div>
                    </div>
                    <div class="card-name ${cardDef.upgraded ? 'upgraded' : ''}">${cardDef.name}</div>
                    <div class="card-desc">${descHTML}</div>
                `;
                return el;
            }
            
            function updateDeckDiscardUI() {
                D.game.deckCount.textContent = runState.deck.length;
                D.game.discardCount.textContent = runState.discard.length;
            }
            
            function updatePathDisplay() {
                D.game.pathDisplay.innerHTML = '';
                pathDefinition.forEach((node, index) => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'path-node';
                    if (index < runState.currentFloor) nodeEl.classList.add('cleared');
                    else if (index === runState.currentFloor) nodeEl.classList.add('current');
                    nodeEl.textContent = node.sprite;
                    D.game.pathDisplay.appendChild(nodeEl);
                });
            }
            
            function updateTargetHighlights(cardType) {
                $$('.targeted').forEach(el => el.classList.remove('targeted'));
                
                if (cardType === 'attack' || cardType === 'enemy_skill') {
                    if (runState.enemy) runState.enemy.dom.container.classList.add('targeted');
                } else if (cardType === 'skill') { 
                    D.game.playerContainer.classList.add('targeted');
                }
            }
            
            function showFloatingText(text, targetElement, type) {
                const floatEl = document.createElement('div');
                floatEl.className = `damage-float ${type}`; 
                
                floatEl.textContent = text;
                const xOffset = (Math.random() - 0.5) * 40; 
                floatEl.style.left = `calc(50% + ${xOffset}px)`;
                targetElement.appendChild(floatEl);
                floatEl.addEventListener('animationend', () => floatEl.remove());
            }
            
            function playAnimation(target, animationClass, onEndCallback = null) {
                if (!target) {
                    if (onEndCallback) onEndCallback();
                    return;
                }
                target.classList.add(animationClass);
                const onAnimEnd = () => {
                    target.classList.remove(animationClass);
                    target.removeEventListener('animationend', onAnimEnd);
                    if (onEndCallback) onEndCallback();
                };
                target.addEventListener('animationend', onAnimEnd);
            }
            
            function createAndFireProjectile(sourceEl, targetEl, iconHTML, onEndCallback) {
                const proj = document.createElement('div');
                proj.className = 'anim-projectile';
                proj.innerHTML = iconHTML;
                
                const startRect = sourceEl.getBoundingClientRect();
                const endRect = targetEl.getBoundingClientRect();
                const gameRect = D.gameContainer.getBoundingClientRect();
                
                // èµ·ç‚¹ (ç›¸å¯¹äº game-container)
                const startX = (startRect.left + startRect.width / 2) - gameRect.left;
                const startY = (startRect.top + startRect.height / 2) - gameRect.top;
                
                // ç»ˆç‚¹ (ç›¸å¯¹äº game-container)
                const endX = (endRect.left + endRect.width / 2) - gameRect.left;
                const endY = (endRect.top + endRect.height / 2) - gameRect.top;
                
                proj.style.left = `${startX}px`;
                proj.style.top = `${startY}px`;
                proj.style.transform = 'translate(-50%, -50%)';

                D.animationLayer.appendChild(proj);

                requestAnimationFrame(() => {
                    proj.style.transform = `translate(-50%, -50%) translate(${endX - startX}px, ${endY - startY}px)`;
                });
                
                proj.addEventListener('transitionend', () => {
                    proj.remove();
                    if (onEndCallback) onEndCallback();
                });
            }

            // --- å·¥å…·å‡½æ•° ---
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // --- äº‹ä»¶ç»‘å®š ---

            function initTooltipListeners() {
                const tooltip = D.tooltip.el;
                let currentTarget = null; 

                function showTooltip(e) {
                    if (!currentTarget) return;
                    
                    let title = '';
                    let desc = '';
                    let targetRect = currentTarget.getBoundingClientRect();

                    // 1. æ£€æŸ¥æ˜¯ä»€ä¹ˆç±»å‹çš„ç›®æ ‡
                    if (currentTarget.dataset.statusId) {
                        // --- çŠ¶æ€å›¾æ ‡ ---
                        const statusId = currentTarget.dataset.statusId;
                        const def = statusDefinitions[statusId];
                        if (!def) return;
                        
                        const isPlayer = currentTarget.closest('#player-status-area');
                        const entity = isPlayer ? runState.player : runState.enemy;
                        const duration = entity.status[statusId];
                        
                        title = `${def.name} ${def.icon}`;
                        if (statusId !== 'strength') {
                            title += ` (å‰©ä½™ ${duration} å›åˆ)`;
                        } else {
                            title += ` (${duration} å±‚)`;
                        }
                        desc = def.desc;
                        
                    } else if (currentTarget.dataset.intentKey) {
                        // --- æ•Œäººæ„å›¾ ---
                        const key = currentTarget.dataset.intentKey;
                        const val = currentTarget.dataset.intentVal;
                        const count = currentTarget.dataset.intentCount;
                        const def = intentDefinitions[key];
                        if (!def) return;
                        
                        title = def.name;
                        desc = def.desc(val, count); // ä¼ é€’å‚æ•°
                        
                    } else if (currentTarget.dataset.keyword) {
                         // --- å¡ç‰Œå…³é”®å­— ---
                        const key = currentTarget.dataset.keyword;
                        const def = statusDefinitions[key]; // å¤ç”¨ statusDefinitions
                        if (!def) return;
                        
                        title = `${def.name} ${def.icon || ''}`;
                        desc = def.desc;
                    } else {
                        return; // ä¸æ˜¯æœ‰æ•ˆç›®æ ‡
                    }

                    // 2. å¡«å……å†…å®¹
                    D.tooltip.title.innerHTML = title;
                    D.tooltip.desc.innerHTML = desc;
                    
                    tooltip.classList.add('visible'); 

                    // 3. å®‰å…¨å®šä½ (å±å¹•è¾¹ç¼˜æ£€æµ‹)
                    const gameRect = D.gameContainer.getBoundingClientRect();
                    const ttRect = tooltip.getBoundingClientRect(); 
                    
                    const targetTop = targetRect.top - gameRect.top;
                    const targetLeft = targetRect.left - gameRect.left;
                    
                    let ttLeft = targetLeft + (targetRect.width / 2); // é»˜è®¤å±…ä¸­
                    let ttTop = targetTop - 8; // é»˜è®¤åœ¨ä¸Šæ–¹
                    let transform = 'translate(-50%, -100%)'; // é»˜è®¤å‘ä¸Š
                    
                    // æ£€æŸ¥ä¸Šæ–¹
                    if ((targetRect.top - ttRect.height) < gameRect.top) {
                        ttTop = targetTop + targetRect.height + 8; // ç§»åˆ°ä¸‹æ–¹
                        transform = 'translate(-50%, 0)';
                    }
                    
                    // æ£€æŸ¥å·¦ä¾§
                    if ((targetRect.left - (ttRect.width / 2)) < gameRect.left) {
                        ttLeft = 5; // 5px è¾¹è·
                        transform = transform.replace('translate(-50%', 'translate(0%');
                    }
                    
                    // æ£€æŸ¥å³ä¾§
                    if ((targetRect.left + (ttRect.width / 2)) > gameRect.right) {
                        ttLeft = gameRect.width - 5; // 5px è¾¹è·
                        transform = transform.replace('translate(-50%', 'translate(-100%');
                    }

                    tooltip.style.left = `${ttLeft}px`;
                    tooltip.style.top = `${ttTop}px`;
                    tooltip.style.transform = transform;
                }

                function hideTooltip() {
                    tooltip.classList.remove('visible'); 
                    currentTarget = null;
                }

                function handlePressStart(e) {
                    const target = e.target.closest('.status-icon, [data-intent-key], .keyword');
                    if (target) {
                        e.preventDefault(); 
                        currentTarget = target; // å­˜å‚¨ç›®æ ‡
                        showTooltip(); // ç«‹å³æ˜¾ç¤º
                    }
                }

                const gameScreen = D.screens.game;
                
                gameScreen.addEventListener('mousedown', handlePressStart);
                gameScreen.addEventListener('touchstart', handlePressStart, { passive: false });

                window.addEventListener('mouseup', hideTooltip);
                window.addEventListener('touchend', hideTooltip);
                window.addEventListener('touchcancel', hideTooltip);
            }
            
            D.mainMenu.continueBtn.addEventListener('click', () => loadRunState());
            D.mainMenu.startBtn.addEventListener('click', () => {
                localStorage.removeItem(RUN_KEY); 
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = 'å¼€å§‹æ¢ç´¢';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                startNewRun();
            });
            D.mainMenu.upgradesBtn.addEventListener('click', () => showUpgradeScreen());
            
            D.upgrades.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            D.game.endTurnBtn.addEventListener('click', () => endPlayerTurn());
            
            D.game.enemyArea.addEventListener('click', (e) => {
                const enemyContainer = e.target.closest('.enemy-container');
                if (enemyContainer && enemyContainer.id === 'enemy-container-0') {
                    onEnemyClick(runState.enemy);
                }
            });
            D.game.playerContainer.addEventListener('click', () => onPlayerClick());
            
            // V1.14: é‡æ„æ‰‹ç‰Œç‚¹å‡»
            D.game.handArea.addEventListener('click', (e) => {
                const cardEl = e.target.closest('.hand-card');
                if (cardEl && !e.target.closest('.keyword')) { // ç¡®ä¿æ²¡ç‚¹ä¸­å…³é”®å­—
                    onCardClick(cardEl.dataset.instanceId);
                }
            });


            D.rewards.skipBtn.addEventListener('click', () => selectReward(null));
            D.rewards.rerollBtn.addEventListener('click', () => {
                if (runState.player.rerollCharges > 0) {
                    runState.player.rerollCharges--;
                    generateRewardOptions(); 
                    D.rewards.rerollBtn.textContent = `é‡æŠ½ (${runState.player.rerollCharges})`;
                    if (runState.player.rerollCharges === 0) {
                        D.rewards.rerollBtn.disabled = true;
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                }
            });

            D.gameOver.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = 'å¼€å§‹æ¢ç´¢';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            D.smith.backBtn.addEventListener('click', () => setGameState(GAME_STATES.EVENT));

            // --- æ¸¸æˆå¯åŠ¨ ---
            function init() {
                defineStatus();
                defineIntents(); 
                defineCards();
                defineEnemies();
                definePath();
                defineUpgrades();
                initTooltipListeners();
                loadPlayerProfile();
                
                const savedRun = localStorage.getItem(RUN_KEY);
                if (savedRun) {
                    const loadedState = JSON.parse(savedRun);
                    D.mainMenu.startBtn.textContent = 'å¼€å§‹æ–°æ¢ç´¢'; 
                    D.mainMenu.startBtn.classList.replace('btn-primary', 'btn-secondary'); 
                    
                    D.mainMenu.continueBtn.textContent = `ç»§ç»­æ¢ç´¢ (ç¬¬ ${loadedState.currentFloor + 1} å±‚)`;
                    D.mainMenu.continueBtn.classList.remove('hidden');
                }
                
                setGameState(GAME_STATES.MAIN_MENU);
            }
            
            init();
        });
    </script>
</body>
</html>
