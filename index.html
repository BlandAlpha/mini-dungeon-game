<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿·ä½ åœ°ç‰¢ (V1.1)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    
    <style>
        :root {
            --color-bg: #111827; /* æ·±ç°è“ */
            --color-surface: #1f2937; /* è¡¨é¢ */
            --color-border: #374151; /* è¾¹æ¡† */
            --color-text: #e5e7eb; /* æ–‡æœ¬ */
            --color-text-dim: #9ca3af; /* æš—æ–‡æœ¬ */
            --color-accent: #22d3ee; /* é’è‰² (èƒ½é‡) */
            --color-accent-dark: #0e7490;
            --color-red: #ef4444; /* çº¢è‰² (ä¼¤å®³) */
            --color-blue: #3b82f6; /* è“è‰² (æ ¼æŒ¡) */
            --color-yellow: #eab308; /* é»„è‰² (å¥–åŠ±) */
            --color-green: #22c55e; /* ç»¿è‰² (å‡çº§) */
            --color-orange: #f97316; /* æ©™è‰² (æ˜“ä¼¤) */
            --color-gray: #6b7280; /* ç°è‰² (è™šå¼±) */
            --color-purple: #a855f7; /* ç´«è‰² (è¯…å’’) */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            overscroll-behavior: none; /* ç¦æ­¢"æ‹‰åŠ¨åˆ·æ–°" */
            -webkit-user-select: none; /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent; 
        }

        /* æ¸¸æˆä¸»å®¹å™¨ï¼Œæ¨¡æ‹Ÿç«–å±æ‰‹æœº */
        .game-container {
            width: 100%;
            height: 100vh;
            max-width: 420px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
            position: relative;
        }
        
        #animation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 40; 
        }

        /* éšè—çš„å±å¹• */
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 1; 
        }
        .screen.active {
            display: flex;
            opacity: 1;
            position: relative;
            pointer-events: auto;
            z-index: 2; 
        }
        
        /* æ¨¡æ€æ¡† (ç”¨äºé”»é€ ) */
        .modal-screen {
            position: absolute;
            z-index: 10;
            background-color: rgba(0,0,0,0.5); 
            backdrop-filter: blur(4px);
            display: flex; 
        }
        .modal-screen.active {
            display: flex; 
            opacity: 1;
            pointer-events: auto;
            z-index: 11; 
        }
        .modal-content {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
        }
        
        /* V1.0: ä¸»å†…å®¹åŒºåŸŸ (ç”¨äºåˆ‡æ¢) */
        #main-content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* ç¡®ä¿å†…å®¹åŒºä¸ä¼šæº¢å‡º */
        }
        #combat-container, #event-container, #reward-container {
            display: none; /* JSæ§åˆ¶æ˜¾ç¤º/éšè— */
            flex-grow: 1;
            flex-direction: column;
        }
        #event-container, #reward-container {
            justify-content: center;
        }

        /* å¡ç‰Œæ ·å¼ */
        .card {
            width: 80px;
            height: 110px;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 8px;
            padding: 6px; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            flex-shrink: 0;
            position: relative; 
        }
        .card.rarity-common { border-color: var(--color-border); }
        .card.rarity-rare { 
            border-color: var(--color-yellow); 
            box-shadow: 0 0 10px rgba(234, 179, 8, 0.3);
        }
        .card.upgraded {
            border-color: var(--color-green);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        .card.curse { border-color: var(--color-purple); }

        .card-cost {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--color-accent);
            color: var(--color-bg);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            border: 1px solid var(--color-accent-dark);
        }
        .card.curse .card-cost {
            background-color: var(--color-purple);
            border-color: var(--color-purple);
            color: var(--color-text);
        }
        .card-name {
            font-size: 0.85rem; 
            font-weight: 600;
            text-align: center;
        }
        .card-name.rarity-rare { color: var(--color-yellow); }
        .card-name.upgraded { color: var(--color-green); }

        .card-desc {
            font-size: 0.7rem; 
            line-height: 1.3; 
            text-align: center;
            color: var(--color-text-dim);
        }
        .card-desc .keyword {
            color: var(--color-yellow);
            font-weight: 600;
            cursor: help;
        }
        .card.exhaust .card-desc::after {
            content: " (æ¶ˆè€—)";
            font-style: italic;
            color: var(--color-text-dim);
        }

        /* æ‰‹ç‰ŒåŒºåŸŸ (Layout V2) */
        #hand-area {
            height: 140px; 
            background-color: var(--color-bg);
            border-top: 2px solid var(--color-border);
            padding: 10px; 
            display: flex;
            justify-content: flex-start; 
            align-items: center;
            overflow-x: auto; 
            position: relative;
            flex-shrink: 0; /* V1.0: é˜²æ­¢æ‰‹ç‰ŒåŒºè¢«å‹ç¼© */
        }
        .hand-card {
            margin-right: 8px; 
        }
        .hand-card:hover {
            transform: translateY(-10px) scale(1.05);
            z-index: 10;
        }
        .hand-card.selected {
            transform: translateY(-20px) scale(1.1);
            border-color: var(--color-accent);
            box-shadow: 0 0 20px 5px rgba(34, 211, 238, 0.3);
            z-index: 20;
        }
        
        .hand-card.playable {
            border-color: var(--color-accent);
        }
        .hand-card.unplayable {
            opacity: 0.6;
            background-color: #333;
        }
        .hand-card.drawing {
            opacity: 0;
            position: absolute;
            z-index: 30;
            transition: all 0.4s ease-out;
        }

        /* å¡ç‰Œå¥–åŠ± UI (Reward Screen Rework) */
        #card-reward-options {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 20px; 
            gap: 10px; 
            flex-grow: 1; /* V1.0: å¡«å……ç©ºé—´ */
        }
        .reward-card {
            transition: all 0.2s ease-out;
        }
        .reward-card:hover {
            transform: scale(1.05); 
            z-index: 20;
            border-color: var(--color-yellow);
        }
        .reward-card.selected-reward {
            transform: scale(1.05);
            border-color: var(--color-yellow);
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.4);
        }

        /* æ•Œäºº */
        .enemy-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s ease-in-out;
        }
        .enemy-container.targeted {
            transform: scale(1.05);
            filter: drop-shadow(0 0 10px var(--color-accent));
        }
        .enemy-sprite {
            font-size: 6rem; 
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        #enemy-area {
            flex-grow: 1; /* V1.0: ç¡®ä¿æ•ŒäººåŒºåŸŸå¡«å…… */
        }
        
        /* ç©å®¶ */
        .player-container {
            transition: transform 0.1s ease-in-out;
            position: relative; 
        }
        .player-container.targeted {
            transform: scale(1.05);
            filter: drop-shadow(0 0 10px var(--color-accent));
        }

        /* çŠ¶æ€æ¡ (HP) */
        .hp-bar-bg {
            background-color: #4b5563;
            border-radius: 99px;
            overflow: hidden;
        }
        .hp-bar-fg {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #ef4444);
            transition: width 0.3s ease;
        }

        /* çŠ¶æ€å›¾æ ‡ */
        .enemy-container .status-icon-container {
            position: absolute;
            left: auto;
            right: -10px;
            bottom: 20px;
            display: flex;
            gap: 4px;
        }
        #player-status-area {
            min-height: 38px; 
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 4px 0;
            background-color: rgba(0,0,0,0.2);
            border-top: 1px solid var(--color-border);
            flex-shrink: 0; /* V1.0: é˜²æ­¢å‹ç¼© */
        }
        .status-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 0.9rem; 
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(0,0,0,0.5);
            color: white;
            text-shadow: 0 0 3px black;
            cursor: pointer; 
            transition: transform 0.1s ease;
        }
        .status-icon:active { 
            transform: scale(1.15);
        }
        .status-icon.status-orange { background-color: var(--color-orange); }
        .status-icon.status-gray { background-color: var(--color-gray); }
        .status-icon.status-red { background-color: var(--color-red); }
        .status-icon.status-blue { background-color: var(--color-blue); } 

        /* æŒ‰é’®æ ·å¼ */
        .btn {
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-align: center;
            cursor: pointer;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: var(--color-accent);
            color: var(--color-bg);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #67e8f9;
        }
        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-border);
        }
        .btn-yellow {
            background: var(--color-yellow);
            color: var(--color-bg);
        }
        .btn-yellow:hover:not(:disabled) {
            background-color: #facc15;
        }
        .btn-event {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            text-align: left;
            padding: 12px;
        }
        .btn-event:hover:not(:disabled) {
            background-color: var(--color-border);
        }
        .btn-event.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .btn-event .event-cost {
            color: var(--color-red);
            font-weight: 600;
        }
        
        /* ä¼¤å®³/æ ¼æŒ¡ æµ®åŠ¨æ–‡å­— */
        .damage-float, .block-float {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 1;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .damage-float { color: var(--color-red); }
        .damage-float.vulnerable {
            color: var(--color-orange);
            font-size: 1.8rem;
            transform: scale(1.2);
        }
        .block-float { color: var(--color-blue); }
        
        @keyframes floatUp {
            from { transform: translateY(0) scale(1); opacity: 1; }
            to { transform: translateY(-60px) scale(1.2); opacity: 0; }
        }
        
        /* åŠ¨ç”» */
        .anim-shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translateX(-4px); }
            20%, 80% { transform: translateX(4px); }
            30%, 50%, 70% { transform: translateX(-4px); }
            40%, 60% { transform: translateX(4px); }
        }
        .anim-lunge {
            animation: lunge 0.5s ease-in-out;
        }
        @keyframes lunge {
            0% { transform: translateY(0); }
            50% { transform: translateY(30px) scale(1.1); }
            100% { transform: translateY(0); }
        }
        .anim-block-shield {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 4rem;
            opacity: 0;
            animation: block-pop 0.6s ease-out;
            transform-origin: center;
        }
        @keyframes block-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; }
        }
        .anim-pulse {
            animation: pulse 0.6s ease-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: var(--color-yellow); }
            100% { transform: scale(1); }
        }
        .anim-projectile {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            z-index: 45;
            transition: all 0.5s cubic-bezier(0.5, -0.5, 0.5, 1.5); /* Så‹æ›²çº¿ */
        }
        
        #enemy-intent-0 {
            cursor: pointer;
        }

        /* è·¯å¾„èŠ‚ç‚¹ (Path Rework) */
        #path-container { /* V1.0: æ–°å®¹å™¨ */
            flex-shrink: 0;
        }
        #path-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
            font-size: 1.25rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--color-border);
        }
        #path-display {
            display: flex;
            justify-content: center;
            gap: 6px; /* èŠ‚ç‚¹é—´è· */
            padding: 10px;
            overflow-x: auto;
            background-color: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--color-border);
        }
        .path-node {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--color-text-dim);
            flex-shrink: 0;
            font-weight: 600;
        }
        .path-node.current {
            border-color: var(--color-accent);
            color: var(--color-accent);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
            transform: scale(1.1);
        }
        .path-node.cleared {
            background-color: var(--color-border);
            opacity: 0.5;
        }
        .path-node.boss {
            border-color: var(--color-red);
            color: var(--color-red);
        }
        
        /* é”»é€ ç•Œé¢å¡ç‰Œå®¹å™¨ */
        #smith-deck-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }
        #smith-deck-container .card {
            cursor: pointer;
        }
        #smith-deck-container .card:not(.can-upgrade) {
            opacity: 0.4;
            cursor: not-allowed;
        }
        #smith-deck-container .card.can-upgrade:hover {
            transform: scale(1.05);
            border-color: var(--color-green);
        }
        
        /* Tooltip æç¤ºæ¡† */
        #tooltip {
            position: absolute; 
            z-index: 50;
            padding: 12px;
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            max-width: 250px;
            width: max-content; 
            text-align: center;
            pointer-events: none; 
            opacity: 0; 
            transition: opacity 0.1s ease;
        }
        #tooltip.visible {
            opacity: 1; 
        }
        #tooltip-title {
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 4px;
        }
        #tooltip-desc {
            font-size: 0.875rem;
            color: var(--color-text-dim);
        }
        #tooltip-desc .keyword {
            color: var(--color-yellow);
            font-weight: 600;
            pointer-events: all; 
            cursor: help;
        }
        
    </style>
</head>
<body>
    <div id="game-container" class="game-container bg-gray-900">
        
        <div id="animation-layer"></div>

        <!-- 1. ä¸»èœå•å±å¹• -->
        <div id="main-menu-screen" class="screen active p-6 justify-between">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-white">è¿·ä½ åœ°ç‰¢</h1>
                <p class="text-lg text-gray-400 mt-2">Mini Dungeon</p>
            </div>
            
            <div class="space-y-4">
                <button id="continue-run-btn" class="btn btn-primary w-full text-lg hidden">ç»§ç»­æ¢ç´¢</button>
                <button id="start-run-btn" class="btn btn-primary w-full text-lg">å¼€å§‹æ¢ç´¢</button>
                <button id="upgrades-menu-btn" class="btn btn-secondary w-full text-lg">æ°¸ä¹…å‡çº§</button>
            </div>
            
            <div class="text-center text-gray-500 text-sm">
                <p>æœ€é«˜å±‚æ•°: <span id="high-score-display">0</span></p>
            </div>
        </div>

        <!-- 2. å‡çº§å±å¹• -->
        <div id="upgrade-screen" class="screen p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold text-white">æ°¸ä¹…å‡çº§</h2>
                <button id="upgrade-back-btn" class="btn btn-secondary">è¿”å›</button>
            </div>
            
            <div class="text-center p-4 bg-gray-800 rounded-lg">
                <p class="text-gray-400">å¯ç”¨ä½™çƒ¬</p>
                <p id="currency-display" class="text-3xl font-bold text-yellow-400">0 ğŸ”¥</p>
            </div>
            
            <!-- å‡çº§é€‰é¡¹ -->
            <div id="upgrade-options-container" class="space-y-3 flex-grow overflow-y-auto">
                <!-- å‡çº§é¡¹å°†ç”±JSåŠ¨æ€å¡«å…… -->
            </div>
        </div>

        <!-- 3. æ¸¸æˆä¸»å±å¹• (V1.0: ç»“æ„é‡æ„) -->
        <div id="game-screen" class="screen">
            
            <!-- V1.0: è·¯å¾„å®¹å™¨ (å§‹ç»ˆå¯è§) -->
            <div id="path-container">
                <div id="path-header">
                    <span id="floor-display">ç¬¬ 1 å±‚</span>
                </div>
                <div id="path-display">
                    <!-- JSåŠ¨æ€å¡«å……è·¯å¾„èŠ‚ç‚¹ -->
                </div>
            </div>
            
            <!-- V1.0: ä¸»å†…å®¹åŒº (åˆ‡æ¢æˆ˜æ–—/äº‹ä»¶/å¥–åŠ±) -->
            <div id="main-content-area">
                
                <!-- 3a. æˆ˜æ–—å®¹å™¨ -->
                <div id="combat-container" class="overflow-hidden">
                    <!-- æ•ŒäººåŒºåŸŸ -->
                    <div id="enemy-area" class="flex-grow flex flex-col justify-center items-center space-y-2 p-4">
                        <div id="enemy-container-0" class="enemy-container">
                            <div id="enemy-intent-0" class="p-1 px-3 bg-gray-700 rounded-full text-lg font-semibold flex items-center space-x-1.5">
                                <!-- âš”ï¸ 5 -->
                            </div>
                            <div id="enemy-sprite-0" class="enemy-sprite">ğŸ˜ˆ</div>
                            <div id="enemy-hp-bar-0" class="w-2/3 hp-bar-bg h-4">
                                <div class="hp-bar-fg"></div>
                            </div>
                            <div id="enemy-hp-text-0" class="text-sm">15 / 15</div>
                            <div id="enemy-block-text-0" class="absolute -right-4 top-1/2 text-xl font-bold text-blue-400 bg-gray-800 p-1 px-2 rounded-full hidden">
                                ğŸ›¡ï¸ 0
                            </div>
                            <div id="enemy-status-icons-0" class="status-icon-container"></div>
                        </div>
                    </div>
                    
                    <!-- ç©å®¶åŒºåŸŸ -->
                    <div id="player-area" class="p-4 border-t border-gray-700 bg-gray-800 flex-shrink-0">
                        <div id="player-container" class="player-container flex items-center justify-between">
                            <!-- ç©å®¶çŠ¶æ€ -->
                            <div class="space-y-2 w-2/3">
                                <div id="player-hp-bar" class="w-full hp-bar-bg h-5">
                                    <div class="hp-bar-fg"></div>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <div id="player-hp-text" class="font-bold">50 / 50</div>
                                    <div id="player-block-text" class="font-bold text-blue-400">ğŸ›¡ï¸ 0</div>
                                </div>
                            </div>
                            <!-- èƒ½é‡ -->
                            <div class="flex flex-col items-center">
                                <div id="player-energy-text" class="text-5xl font-bold text-accent">3/3</div>
                                <div class="text-xs text-gray-400">èƒ½é‡ âš¡</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ç©å®¶çŠ¶æ€å›¾æ ‡åŒº -->
                    <div id="player-status-area">
                        <!-- JSåŠ¨æ€å¡«å…… -->
                    </div>

                    <!-- æ‰‹ç‰ŒåŒºåŸŸ (Layout V2) -->
                    <div id="hand-area">
                        <!-- å¡ç‰Œç”±JSåŠ¨æ€å¡«å…… -->
                    </div>
                    
                    <!-- åº•éƒ¨æ“ä½œæ  -->
                    <div id="bottom-bar" class="p-3 bg-gray-800 border-t border-gray-700 flex justify-between items-center flex-shrink-0">
                        <div class="text-center relative">
                            <div id="deck-count" class="font-bold text-lg">10</div>
                            <div class="text-xs text-gray-400">ç‰Œå †</div>
                        </div>
                        <button id="end-turn-btn" class="btn btn-primary text-lg px-8 py-3">ç»“æŸå›åˆ</button>
                        <div class="text-center relative">
                            <div id="discard-count" class="font-bold text-lg">0</div>
                            <div class="text-xs text-gray-400">å¼ƒç‰Œå †</div>
                        </div>
                    </div>
                </div>
                
                <!-- 3b. äº‹ä»¶å®¹å™¨ (V1.0: ä» #event-screen ç§»å…¥) -->
                <div id="event-container" class="p-6 space-y-6 text-center">
                    <h2 id="event-title" class="text-3xl font-bold text-white">é­é‡äº‹ä»¶</h2>
                    <p id="event-description" class="text-lg text-gray-300">...</p>
                    <div id="event-options" class="w-full max-w-sm mx-auto space-y-3">
                        <!-- äº‹ä»¶é€‰é¡¹ç”±JS (btn-event) å¡«å…… -->
                    </div>
                </div>
                
                <!-- 3c. å¥–åŠ±å®¹å™¨ (V1.0: ä» #reward-screen ç§»å…¥) -->
                <div id="reward-container" class="p-6 space-y-6">
                    <div class="text-center">
                        <h2 id="reward-title" class="text-3xl font-bold text-white">æˆ˜æ–—èƒœåˆ©ï¼</h2> 
                        <p class="text-lg text-yellow-400">è·å¾— <span id="reward-currency">0</span> ğŸ”¥</p>
                    </div>
                    
                    <div id="card-reward-options">
                        <!-- 3å¼ å¡ç‰Œé€‰é¡¹(æ°´å¹³)ç”±JSå¡«å…… -->
                    </div>
                    
                    <!-- å¥–åŠ±æŒ‰é’® -->
                    <div class="w-full max-w-sm mx-auto space-y-3">
                        <button id="confirm-reward-btn" class="btn btn-primary w-full hidden">ç¡®è®¤é€‰æ‹©</button>
                        <div class="flex space-x-4 w-full">
                            <button id="skip-reward-btn" class="btn btn-secondary w-1/2">è·³è¿‡</button>
                            <button id="reroll-reward-btn" class="btn btn-yellow w-1/2 hidden">é‡æŠ½ (1)</button>
                        </div>
                    </div>
                </div>

            </div> <!-- End #main-content-area -->

        </div> <!-- End #game-screen -->
        
        <!-- 4. å¥–åŠ±å±å¹• (V1.0: å·²åˆ é™¤) -->
        
        <!-- 5. äº‹ä»¶å±å¹• (V1.0: å·²åˆ é™¤) -->

        <!-- 6. æ¸¸æˆç»“æŸå±å¹• -->
        <div id="game-over-screen" class="screen p-6 justify-center items-center text-center space-y-6">
            <h2 id="game-over-title" class="text-4xl font-bold text-red-500">ä½ å€’ä¸‹äº†</h2>
            <div class="text-lg space-y-2">
                <p>ä½ æ·±å…¥åˆ°äº†ç¬¬ <span id="final-floor" class="font-bold text-xl text-white">0</span> å±‚</p> 
                <p>ä½ æ”¶é›†äº† <span id="final-currency" class="font-bold text-xl text-yellow-400">0</span> ğŸ”¥ ä½™çƒ¬</p>
            </div>
            <button id="game-over-back-btn" class="btn btn-primary w-full text-lg">è¿”å›ä¸»èœå•</button>
        </div>
        
        <!-- 7. é”»é€ å±å¹• (æ¨¡æ€æ¡†) -->
        <div id="smith-screen" class="screen modal-screen p-4 justify-center items-center">
            <div class="modal-content w-full max-w-sm h-3/4 flex flex-col rounded-lg overflow-hidden">
                <h2 class="text-2xl font-bold text-white text-center p-4">é€‰æ‹©ä¸€å¼ å¡ç‰Œè¿›è¡Œé”»é€ </h2>
                <div id="smith-deck-container" class="flex-grow">
                    <!-- å¡ç‰Œåˆ—è¡¨ç”±JSå¡«å…… -->
                </div>
                <div class="p-4 border-t border-gray-700">
                    <button id="smith-back-btn" class="btn btn-secondary w-full">ç¦»å¼€</button> <!-- V1.1: æ–‡æœ¬æ›´æ”¹ -->
                </div>
            </div>
        </div>

    </div>

    <!-- Tooltip æç¤ºæ¡† -->
    <div id="tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-desc"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- å…¨å±€çŠ¶æ€å’ŒDOMå¼•ç”¨ ---
            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);
            
            const PROFILE_KEY = 'miniDungeonProfile'; 
            const RUN_KEY = 'miniDungeonRun'; 

            let playerProfile = {}; // å±€å¤–æˆé•¿
            let runState = {}; // å½“å‰å±€å†…çŠ¶æ€
            let cardDefinitions = {}; // å¡ç‰Œå®šä¹‰
            let enemyDefinitions = {}; // æ•Œäººå®šä¹‰
            let eventDefinitions = {}; // äº‹ä»¶å®šä¹‰
            let upgradeDefinitions = {}; // å‡çº§å®šä¹‰
            let statusDefinitions = {}; // çŠ¶æ€å®šä¹‰
            let intentDefinitions = {}; // æ„å›¾å®šä¹‰
            
            const GAME_STATES = {
                MAIN_MENU: 'MAIN_MENU',
                UPGRADES: 'UPGRADES',
                GAME_OVER: 'GAME_OVER',
                EVENT: 'EVENT',
                REWARD: 'REWARD',
                SMITHING: 'SMITHING',
                // Combat Sub-states
                PLAYER_TURN: 'PLAYER_TURN', // ç­‰å¾…ç©å®¶è¾“å…¥
                PROCESSING_LOGIC: 'PROCESSING_LOGIC', // ä»»ä½•å¡ç‰Œ/å›åˆé€»è¾‘ç»“ç®—ä¸­
                COMBAT_OVER: 'COMBAT_OVER', // æˆ˜æ–—èƒœåˆ©ï¼Œç­‰å¾…å¥–åŠ±
            };

            const NODE_TYPE = {
                MONSTER: 'M',
                ELITE: 'E',
                EVENT: 'R',
                BOSS: 'B',
            };
            const NODE_SPRITES = {
                [NODE_TYPE.MONSTER]: 'ğŸ‘º',
                [NODE_TYPE.ELITE]: 'ğŸ—¿',
                [NODE_TYPE.EVENT]: 'ğŸ”¥', 
                [NODE_TYPE.BOSS]: 'ğŸ¤–',
                FOG: '?', 
            };
            
            const CARD_RARITY = {
                BASIC: 'basic',
                COMMON: 'common',
                RARE: 'rare',
                CURSE: 'curse',
            };

            const D = { // DOM å¼•ç”¨
                gameContainer: $('#game-container'), 
                animationLayer: $('#animation-layer'), 
                screens: {
                    mainMenu: $('#main-menu-screen'),
                    upgrades: $('#upgrade-screen'),
                    game: $('#game-screen'),
                    gameOver: $('#game-over-screen'),
                    smith: $('#smith-screen'), 
                },
                mainMenu: {
                    continueBtn: $('#continue-run-btn'),
                    startBtn: $('#start-run-btn'),
                    upgradesBtn: $('#upgrades-menu-btn'),
                    highScore: $('#high-score-display'),
                },
                upgrades: {
                    backBtn: $('#upgrade-back-btn'),
                    currency: $('#currency-display'),
                    optionsContainer: $('#upgrade-options-container'),
                },
                game: {
                    pathContainer: $('#path-container'),
                    mainContentArea: $('#main-content-area'),
                    combatContainer: $('#combat-container'),
                    eventContainer: $('#event-container'),
                    rewardContainer: $('#reward-container'),
                    bottomBar: $('#bottom-bar'),
                    
                    floorDisplay: $('#floor-display'), 
                    pathDisplay: $('#path-display'),
                    enemyArea: $('#enemy-area'),
                    playerArea: $('#player-area'),
                    handArea: $('#hand-area'),
                    endTurnBtn: $('#end-turn-btn'),
                    playerHPBar: $('#player-hp-bar .hp-bar-fg'),
                    playerHPText: $('#player-hp-text'),
                    playerBlockText: $('#player-block-text'),
                    playerEnergyText: $('#player-energy-text'),
                    playerContainer: $('#player-container'),
                    playerStatusIcons: $('#player-status-area'), 
                    deckCount: $('#deck-count'),
                    discardCount: $('#discard-count'),
                },
                rewards: {
                    title: $('#reward-title'), 
                    options: $('#card-reward-options'),
                    confirmBtn: $('#confirm-reward-btn'), 
                    skipBtn: $('#skip-reward-btn'),
                    rerollBtn: $('#reroll-reward-btn'),
                    currency: $('#reward-currency'),
                },
                event: {
                    title: $('#event-title'),
                    description: $('#event-description'),
                    options: $('#event-options'),
                },
                gameOver: {
                    screen: $('#game-over-screen'),
                    title: $('#game-over-title'),
                    backBtn: $('#game-over-back-btn'),
                    finalFloor: $('#final-floor'),
                    finalCurrency: $('#final-currency'),
                },
                smith: { 
                    container: $('#smith-deck-container'),
                    backBtn: $('#smith-back-btn'),
                },
                tooltip: { 
                    el: $('#tooltip'),
                    title: $('#tooltip-title'),
                    desc: $('#tooltip-desc'),
                }
            };

            // --- æ¸¸æˆæ•°æ®å®šä¹‰ ---

            function defineStatus() {
                statusDefinitions = {
                    'vulnerable': {
                        name: 'æ˜“ä¼¤',
                        icon: 'ğŸ›¡ï¸',
                        desc: 'å—åˆ°çš„ <strong>æ”»å‡»</strong> ä¼¤å®³ +50%ã€‚',
                        color: 'orange' 
                    },
                    'weak': {
                        name: 'è™šå¼±',
                        icon: 'âš”ï¸',
                        desc: 'é€ æˆçš„ <strong>æ”»å‡»</strong> ä¼¤å®³ -50%ã€‚',
                        color: 'gray'
                    },
                    'strength': {
                        name: 'åŠ›é‡',
                        icon: 'ğŸ’ª',
                        desc: 'å¢åŠ  <strong>æ”»å‡»</strong> é€ æˆçš„ä¼¤å®³ã€‚',
                        color: 'red'
                    },
                    'barricade': { 
                        name: 'å£å’',
                        icon: 'ğŸ›¡ï¸',
                        desc: 'ä½ çš„ <strong>æ ¼æŒ¡</strong> ä¸ä¼šåœ¨å›åˆç»“æŸæ—¶æ¶ˆå¤±ã€‚',
                        color: 'blue'
                    },
                    'exhaust': { 
                        name: 'æ¶ˆè€—',
                        icon: 'ğŸ”¥',
                        desc: 'æ­¤å¡ç‰Œä½¿ç”¨åï¼Œåœ¨æœ¬åœºæˆ˜æ–—ä¸­è¢«ç§»é™¤ç‰Œç»„ï¼ˆä¸ä¼šè¿›å…¥å¼ƒç‰Œå †ï¼‰ã€‚'
                    },
                    'curse': { 
                        name: 'è¯…å’’',
                        icon: 'ğŸŸ£',
                        desc: 'ä¸€å¼ å¹²æ‰°ä½ ç‰Œåº“çš„å¡ç‰Œã€‚'
                    }
                };
            }
            
            function defineIntents() {
                intentDefinitions = {
                    'attack': {
                        name: 'æ”»å‡»',
                        desc: (val) => `æ•Œäººå°†é€ æˆ <strong>${val}</strong> ç‚¹ä¼¤å®³ã€‚`
                    },
                    'attack_multi': {
                        name: 'å¤šæ®µæ”»å‡»',
                        desc: (val, count) => `æ•Œäººå°†é€ æˆ <strong>${val}</strong> ç‚¹ä¼¤å®³ï¼Œå…± <strong>${count}</strong> æ¬¡ã€‚`
                    },
                    'defend': {
                        name: 'é˜²å¾¡',
                        desc: (val) => `æ•Œäººå°†è·å¾— <strong>${val}</strong> ç‚¹æ ¼æŒ¡ã€‚`
                    },
                    'buff': {
                        name: 'å¼ºåŒ– (Buff)',
                        desc: (val) => `æ•Œäººå°†è·å¾— <strong>${val}</strong> å±‚ <strong>åŠ›é‡</strong>ã€‚`
                    },
                    'debuff_vulnerable': {
                        name: 'å‡ç›Š (Debuff)',
                        desc: (val) => `æ•Œäººå°†å¯¹ä½ æ–½åŠ  <strong>${val}</strong> å›åˆ <k>æ˜“ä¼¤</k>ã€‚`
                    },
                    'debuff_weak': {
                        name: 'å‡ç›Š (Debuff)',
                        desc: (val) => `æ•Œäººå°†å¯¹ä½ æ–½åŠ  <strong>${val}</strong> å›åˆ <k>è™šå¼±</k>ã€‚`
                    },
                    'pollute': {
                        name: 'æ±¡æŸ“',
                        desc: (val) => `æ•Œäººå°† <strong>${val}</strong> å¼  <strong>é»æ¶²</strong> å¡å…¥ä½ çš„å¼ƒç‰Œå †ã€‚`
                    }
                };
            }
            
            function defineCards() {
                cardDefinitions = {
                    // --- åŸºç¡€å¡ç‰Œ (Basic) ---
                    'strike': {
                        id: 'strike', name: 'æ‰“å‡»', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.BASIC,
                        desc: 'é€ æˆ 6 ç‚¹ä¼¤å®³ã€‚',
                        upgradesTo: 'strike_plus',
                        effect: (caster, target) => dealDamage(target, 6, caster),
                    },
                    'strike_plus': {
                        id: 'strike_plus', name: 'æ‰“å‡»+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.BASIC,
                        desc: 'é€ æˆ 9 ç‚¹ä¼¤å®³ã€‚',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 9, caster),
                    },
                    'defend': {
                        id: 'defend', name: 'é˜²å¾¡', cost: 1, type: 'skill',
                        desc: 'è·å¾— 5 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self', rarity: CARD_RARITY.BASIC,
                        upgradesTo: 'defend_plus',
                        effect: (caster) => addBlock(caster, 5),
                    },
                    'defend_plus': {
                        id: 'defend_plus', name: 'é˜²å¾¡+', cost: 1, type: 'skill',
                        desc: 'è·å¾— 8 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self', rarity: CARD_RARITY.BASIC,
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 8),
                    },
                    
                    // --- æ™®é€šå¡ç‰Œ (Common) ---
                    'heavy_strike': {
                        id: 'heavy_strike', name: 'é‡å‡»', cost: 2, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 12 ç‚¹ä¼¤å®³ã€‚',
                        upgradesTo: 'heavy_strike_plus',
                        effect: (caster, target) => dealDamage(target, 12, caster),
                    },
                    'heavy_strike_plus': {
                        id: 'heavy_strike_plus', name: 'é‡å‡»+', cost: 2, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 16 ç‚¹ä¼¤å®³ã€‚',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 16, caster),
                    },
                    'double_hit': {
                        id: 'double_hit', name: 'äºŒè¿å‡»', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 4 ç‚¹ä¼¤å®³ï¼Œ2æ¬¡ã€‚',
                        upgradesTo: 'double_hit_plus',
                        effect: (caster, target) => {
                            dealDamage(target, 4, caster, 0); 
                            dealDamage(target, 4, caster, 150);
                        },
                    },
                    'double_hit_plus': {
                        id: 'double_hit_plus', name: 'äºŒè¿å‡»+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 6 ç‚¹ä¼¤å®³ï¼Œ2æ¬¡ã€‚',
                        upgraded: true,
                        effect: (caster, target) => {
                            dealDamage(target, 6, caster, 0);
                            dealDamage(target, 6, caster, 150);
                        },
                    },
                    'iron_wall': {
                        id: 'iron_wall', name: 'é“å£', cost: 2, type: 'skill',
                        desc: 'è·å¾— 10 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'iron_wall_plus',
                        effect: (caster) => addBlock(caster, 10),
                    },
                    'iron_wall_plus': {
                        id: 'iron_wall_plus', name: 'é“å£+', cost: 2, type: 'skill',
                        desc: 'è·å¾— 14 ç‚¹æ ¼æŒ¡ã€‚',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 14),
                    },
                    'quick_slash': {
                        id: 'quick_slash', name: 'å¿«æ–©', cost: 0, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 3 ç‚¹ä¼¤å®³ã€‚',
                        upgradesTo: 'quick_slash_plus',
                        effect: (caster, target) => dealDamage(target, 3, caster),
                    },
                    'quick_slash_plus': {
                        id: 'quick_slash_plus', name: 'å¿«æ–©+', cost: 0, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 5 ç‚¹ä¼¤å®³ã€‚',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 5, caster),
                    },
                    'vampiric_touch': {
                        id: 'vampiric_touch', name: 'å¸è¡€', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 5 ç‚¹ä¼¤å®³ã€‚å›å¤ 2 ç‚¹ç”Ÿå‘½ã€‚',
                        upgradesTo: 'vampiric_touch_plus',
                        effect: (caster, target) => { 
                            dealDamage(target, 5, caster); 
                            setTimeout(() => healDamage(caster, 2), 200);
                        },
                    },
                    'vampiric_touch_plus': {
                        id: 'vampiric_touch_plus', name: 'å¸è¡€+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 7 ç‚¹ä¼¤å®³ã€‚å›å¤ 3 ç‚¹ç”Ÿå‘½ã€‚',
                        upgraded: true,
                        effect: (caster, target) => { 
                            dealDamage(target, 7, caster);
                            setTimeout(() => healDamage(caster, 3), 200);
                        },
                    },
                    'battle_focus': {
                        id: 'battle_focus', name: 'ä¸“æ³¨', cost: 1, type: 'skill',
                        desc: 'æŠ½ 2 å¼ ç‰Œã€‚',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'battle_focus_plus',
                        effect: (caster, target, card) => drawCards(2, card),
                    },
                    'battle_focus_plus': {
                        id: 'battle_focus_plus', name: 'ä¸“æ³¨+', cost: 1, type: 'skill',
                        desc: 'æŠ½ 3 å¼ ç‰Œã€‚',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        effect: (caster, target, card) => drawCards(3, card),
                    },
                    'break': {
                        id: 'break', name: 'ç ´ç»½', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  2 å±‚<k>æ˜“ä¼¤</k>ã€‚',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'break_plus',
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 2, caster),
                    },
                    'break_plus': {
                        id: 'break_plus', name: 'ç ´ç»½+', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  3 å±‚<k>æ˜“ä¼¤</k>ã€‚',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 3, caster),
                    },
                    'demoralize': {
                        id: 'demoralize', name: 'æŒ«å¿—', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  1 å±‚<k>è™šå¼±</k>ã€‚',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'demoralize_plus',
                        effect: (caster, target) => applyStatus(target, 'weak', 1, caster),
                    },
                    'demoralize_plus': {
                        id: 'demoralize_plus', name: 'æŒ«å¿—+', cost: 1, type: 'skill',
                        desc: 'æ–½åŠ  2 å±‚<k>è™šå¼±</k>ã€‚',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        effect: (caster, target) => applyStatus(target, 'weak', 2, caster),
                    },
                    'bulwark': {
                        id: 'bulwark', name: 'åšå®ˆ', cost: 1, type: 'attack', 
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 7 ç‚¹ä¼¤å®³ã€‚è‹¥ä½ æœ‰æ ¼æŒ¡ï¼ŒæŠ½ 1 å¼ ç‰Œã€‚',
                        upgradesTo: 'bulwark_plus',
                        effect: (caster, target, card) => {
                            dealDamage(target, 7, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200);
                            }
                        },
                    },
                    'bulwark_plus': {
                        id: 'bulwark_plus', name: 'åšå®ˆ+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: 'é€ æˆ 10 ç‚¹ä¼¤å®³ã€‚è‹¥ä½ æœ‰æ ¼æŒ¡ï¼ŒæŠ½ 1 å¼ ç‰Œã€‚',
                        upgraded: true,
                        effect: (caster, target, card) => {
                            dealDamage(target, 10, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200);
                            }
                        },
                    },
                    'energy_burst': {
                        id: 'energy_burst', name: 'èƒ½é‡çˆ†å‘', cost: 0, type: 'skill',
                        desc: 'è·å¾— 2 ç‚¹èƒ½é‡ âš¡ã€‚',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'energy_burst_plus',
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 2;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },
                    'energy_burst_plus': {
                        id: 'energy_burst_plus', name: 'èƒ½é‡çˆ†å‘+', cost: 0, type: 'skill',
                        desc: 'è·å¾— 3 ç‚¹èƒ½é‡ âš¡ã€‚',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 3;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },

                    // --- ç¨€æœ‰å¡ç‰Œ (Rare) ---
                    'adrenaline': { 
                        id: 'adrenaline', name: 'èƒ½é‡çˆ†å‘+', cost: 0, type: 'skill',
                        target: 'self', rarity: CARD_RARITY.RARE,
                        desc: 'è·å¾— 2 ç‚¹èƒ½é‡ âš¡ã€‚æŠ½ 2 å¼ ç‰Œã€‚<k>æ¶ˆè€—</k>ã€‚', 
                        exhaust: true, upgraded: true, 
                        effect: (caster, target, card) => { 
                            caster.energy += 2; 
                            playAnimation(D.game.playerEnergyText, 'anim-pulse'); 
                            drawCards(2, card); 
                        },
                    },
                    'barricade': { 
                        id: 'barricade', name: 'å£å’', cost: 2, type: 'skill',
                        target: 'self', rarity: CARD_RARITY.RARE,
                        desc: 'è·å¾— 15 ç‚¹æ ¼æŒ¡ã€‚ä½ çš„<k>æ ¼æŒ¡</k>ä¸å†äºå›åˆç»“æŸæ—¶æ¶ˆå¤±ã€‚', 
                        upgradesTo: 'barricade_plus',
                        effect: (caster) => { 
                            addBlock(caster, 15); 
                            applyStatus(caster, 'barricade', 1, caster); 
                        },
                    },
                    'barricade_plus': { 
                        id: 'barricade_plus', name: 'å£å’+', cost: 2, type: 'skill',
                        target: 'self', rarity: CARD_RARITY.RARE,
                        desc: 'è·å¾— 20 ç‚¹æ ¼æŒ¡ã€‚ä½ çš„<k>æ ¼æŒ¡</k>ä¸å†äºå›åˆç»“æŸæ—¶æ¶ˆå¤±ã€‚', 
                        upgraded: true, 
                        effect: (caster) => { 
                            addBlock(caster, 20); 
                            applyStatus(caster, 'barricade', 1, caster);
                        },
                    },
                    'annihilate': { 
                        id: 'annihilate', name: 'æ¹®ç­', cost: 3, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.RARE,
                        desc: 'é€ æˆ 30 ç‚¹ä¼¤å®³ã€‚', 
                        upgradesTo: 'annihilate_plus',
                        effect: (caster, target) => dealDamage(target, 30, caster),
                    },
                    'annihilate_plus': { 
                        id: 'annihilate_plus', name: 'æ¹®ç­+', cost: 3, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.RARE,
                        desc: 'é€ æˆ 40 ç‚¹ä¼¤å®³ã€‚', 
                        upgraded: true, 
                        effect: (caster, target) => dealDamage(target, 40, caster),
                    },
                    
                    // --- è¯…å’’ (Curse) ---
                    'slime_curse': {
                        id: 'slime_curse', name: 'é»æ¶²', cost: 0, type: 'curse',
                        target: 'self', rarity: CARD_RARITY.CURSE,
                        desc: 'æ— ç”¨ã€‚',
                        exhaust: true,
                        effect: () => {}, 
                    }
                };
            }
            
            function defineEnemies() {
                enemyDefinitions = {
                    // --- Floor 1 ---
                    'goblin': {
                        name: 'å“¥å¸ƒæ—', hp: 20, sprite: 'ğŸ‘º', currency: 3,
                        moves: [
                            { type: 'attack', val: 6, intent: 'âš”ï¸ 6', intentKey: 'attack' },
                            { type: 'attack', val: 8, intent: 'âš”ï¸ 8', intentKey: 'attack' },
                        ]
                    },
                    'slime': {
                        name: 'å²è±å§†', hp: 15, sprite: 'ğŸ¦ ', currency: 2,
                        moves: [
                            { type: 'attack', val: 5, intent: 'âš”ï¸ 5', intentKey: 'attack' },
                            { type: 'defend', val: 3, intent: 'ğŸ›¡ï¸ 3', intentKey: 'defend' }, 
                            { type: 'pollute', val: 1, intent: 'ğŸ¤® 1', intentKey: 'pollute' }, 
                        ]
                    },
                    'guardian': { // Elite
                        name: 'å®ˆå«', hp: 60, sprite: 'ğŸ—¿', currency: 15,
                        moves: [
                            { type: 'attack', val: 12, intent: 'âš”ï¸ 12', intentKey: 'attack' },
                            { type: 'debuff', status: 'vulnerable', val: 1, intent: 'ğŸ˜µ 1', intentKey: 'debuff_vulnerable' }, 
                            { type: 'defend', val: 15, intent: 'ğŸ›¡ï¸ 15', intentKey: 'defend' },
                        ]
                    },
                    'golem': { // Boss
                        name: 'é­”åƒ', hp: 120, sprite: 'ğŸ¤–', currency: 50, isBoss: true,
                        moves: [
                            { type: 'attack', val: 15, intent: 'âš”ï¸ 15', intentKey: 'attack' },
                            { type: 'attack_multi', val: 8, count: 2, intent: 'âš”ï¸ 8 (2æ¬¡)', intentKey: 'attack_multi' },
                            { type: 'defend', val: 20, intent: 'ğŸ›¡ï¸ 20', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 3, intent: 'ğŸ’ª+3', intentKey: 'buff' }, 
                            { type: 'pollute', val: 2, intent: 'ğŸ¤® 2', intentKey: 'pollute' }, 
                        ],
                        onTurn: (enemy, onEndCallback) => { 
                            const move = enemy.nextMove;
                            if (move.intentKey === 'attack_multi') { 
                                playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                    takeDamage(runState.player, move.val, enemy, 0); 
                                    setTimeout(() => {
                                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                            takeDamage(runState.player, move.val, enemy, 0); 
                                            onEndCallback(); 
                                        });
                                    }, 300); 
                                });
                            } else {
                                executeDefaultEnemyMove(enemy, onEndCallback);
                            }
                        }
                    },
                    // --- Floor 2+ ---
                    'orc': {
                        name: 'å…½äºº', hp: 40, sprite: 'ğŸ‘¹', currency: 8,
                        moves: [
                            { type: 'attack', val: 10, intent: 'âš”ï¸ 10', intentKey: 'attack' },
                            { type: 'defend', val: 8, intent: 'ğŸ›¡ï¸ 8', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 2, intent: 'ğŸ’ª+2', intentKey: 'buff' }, 
                        ]
                    },
                    'shadow': {
                        name: 'æš—å½±', hp: 30, sprite: 'ğŸ‘»', currency: 7,
                        moves: [
                            { type: 'attack', val: 7, intent: 'âš”ï¸ 7', intentKey: 'attack' },
                            { type: 'attack', val: 7, intent: 'âš”ï¸ 7', intentKey: 'attack' },
                            { type: 'debuff', status: 'weak', val: 1, intent: 'ğŸ˜µâ€ğŸ’« 1', intentKey: 'debuff_weak' }, 
                        ]
                    },
                }
            }
            
            function defineEvents() {
                eventDefinitions = {
                    'rest': {
                        id: 'rest',
                        title: 'ç¯ç«',
                        desc: 'ä¸€ä¸ªå¤è€çš„ç¯ç«åœ¨æ‘‡æ›³ã€‚ä½ æ„Ÿåˆ°ä¸€é˜µæ¸©æš–ã€‚',
                        sprite: 'ğŸ”¥',
                        choices: [
                            { text: 'ä¼‘æ¯ (å›å¤ 30% HP)', action: () => {
                                healDamage(runState.player, Math.floor(runState.player.maxHp * 0.3));
                                proceedToNextLevel();
                            }},
                            { text: 'é”»é€  (å‡çº§ä¸€å¼ å¡)', action: () => {
                                // V1.1: é”å®šé€‰æ‹©
                                D.event.description.textContent = 'ä½ é€‰æ‹©åœ¨ç¯ç«æ—é”»é€ ä½ çš„è£…å¤‡ã€‚';
                                D.event.options.innerHTML = ''; // æ¸…ç©ºé€‰é¡¹
                                showSmithScreen();
                            }},
                            { text: 'ç¦»å¼€', action: () => proceedToNextLevel() },
                        ]
                    },
                    'statue': {
                        id: 'statue',
                        title: 'ä½è¯­ç¥åƒ',
                        desc: 'ä¸€ä¸ªç¥åƒåœ¨ä½è¯­ï¼Œå®ƒæ¸´æœ›ä½ çš„ç”Ÿå‘½åŠ›ã€‚',
                        sprite: 'ğŸ™',
                        choices: [
                            { 
                                text: 'çŒ®ç¥­ <span class="event-cost">(å¤±å» 10% æœ€å¤§HP)</span>', 
                                cost: () => runState.player.hp > Math.floor(runState.player.maxHp * 0.1), 
                                action: () => {
                                    const cost = Math.floor(runState.player.maxHp * 0.1);
                                    runState.player.maxHp -= cost;
                                    if (runState.player.hp > runState.player.maxHp) {
                                        runState.player.hp = runState.player.maxHp;
                                    }
                                    applyStatus(runState.player, 'strength', 1, runState.player); 
                                    updateEntityUI(runState.player);
                                    proceedToNextLevel();
                                }
                            },
                            { text: 'å¿½ç•¥', action: () => proceedToNextLevel() },
                        ]
                    },
                    'chest': {
                        id: 'chest',
                        title: 'é»„é‡‘å®ç®±',
                        desc: 'ä¸€ä¸ªæœªä¸Šé”çš„åä¸½å®ç®±ã€‚',
                        sprite: 'ğŸ“¦',
                        choices: [
                            { 
                                text: 'æ‰“å¼€', 
                                action: () => {
                                    if (Math.random() < 0.3) {
                                        // é™·é˜±!
                                        addCardToDeck(cardDefinitions.slime_curse);
                                        D.event.description.textContent = 'æ˜¯é™·é˜±ï¼ä½ è·å¾—äº†ä¸€å¼  <k>è¯…å’’</k>...'; 
                                        D.event.options.innerHTML = `<button class="btn btn-secondary w-full" id="event-leave">ç¦»å¼€</button>`;
                                        $('#event-leave').onclick = () => proceedToNextLevel();
                                    } else {
                                        // å¥–åŠ±!
                                        runState.runCurrency += 20;
                                        addCardToDeck(getRandomCard(CARD_RARITY.COMMON));
                                        D.event.description.textContent = 'ä½ è·å¾—äº† 20ğŸ”¥ å’Œä¸€å¼ æ–°å¡ç‰Œï¼';
                                        D.event.options.innerHTML = `<button class="btn btn-primary w-full" id="event-leave">å¤ªå¥½äº†</button>`;
                                        $('#event-leave').onclick = () => proceedToNextLevel();
                                    }
                                }
                            },
                            { text: 'ç¦»å¼€', action: () => proceedToNextLevel() },
                        ]
                    }
                };
            }
            
            function defineUpgrades() {
                upgradeDefinitions = {
                    'max_hp': {
                        name: 'å¼ºåŒ–ä½“è´¨',
                        desc: 'æœ€å¤§ç”Ÿå‘½å€¼ +5',
                        baseCost: 50,
                        costIncrease: 25,
                        maxLevel: 10,
                        apply: (profile) => profile.baseHp += 5,
                    },
                    'start_energy': {
                        name: 'æ´»åŠ›æºæ³‰',
                        desc: 'åˆå§‹èƒ½é‡ +1',
                        baseCost: 300,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.baseEnergy += 1,
                    },
                    'start_heal': {
                        name: 'åˆå§‹å›å¤',
                        desc: 'å¼€å§‹æ—¶å›å¤ 10 ç‚¹ç”Ÿå‘½',
                        baseCost: 100,
                        costIncrease: 50,
                        maxLevel: 3,
                        apply: (profile) => profile.startHeal += 10,
                    },
                    'greed': { 
                        name: 'è´ªå©ª',
                        desc: 'æˆ˜æ–—èƒœåˆ©æ—¶é¢å¤–è·å¾— 2% ä½™çƒ¬',
                        baseCost: 80,
                        costIncrease: 40,
                        maxLevel: 10,
                        apply: (profile) => profile.greedBonus += 0.02,
                    },
                    'smith_chance': { 
                        name: 'å·¥åŒ ç²¾ç¥',
                        desc: 'é”»é€ æ—¶æœ‰ 5% å‡ ç‡ä¸æ¶ˆè€—ç¯ç«',
                        baseCost: 150,
                        costIncrease: 75,
                        maxLevel: 5,
                        apply: (profile) => profile.smithChance += 0.05,
                    },
                    'reroll_charges': { 
                        name: 'å‘½è¿ä¹‹æ‰‹',
                        desc: 'å¡ç‰Œå¥–åŠ±ç•Œé¢è·å¾— 1 æ¬¡é‡æŠ½æœºä¼š',
                        baseCost: 250,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.rerollCharges += 1,
                    },
                };
            }

            // --- å±€å¤–æˆé•¿ (Profile) & å­˜æ¡£ (Run) ---

            function loadPlayerProfile() {
                const profile = localStorage.getItem(PROFILE_KEY);
                if (profile) {
                    playerProfile = JSON.parse(profile);
                    // ç¡®ä¿æ‰€æœ‰å‡çº§å±æ€§éƒ½å­˜åœ¨
                    if (!playerProfile.upgrades.start_heal) playerProfile.upgrades.start_heal = 0;
                    if (!playerProfile.startHeal) playerProfile.startHeal = 0;
                    if (!playerProfile.upgrades.greed) playerProfile.upgrades.greed = 0;
                    if (!playerProfile.greedBonus) playerProfile.greedBonus = 0;
                    if (!playerProfile.upgrades.smith_chance) playerProfile.upgrades.smith_chance = 0;
                    if (!playerProfile.smithChance) playerProfile.smithChance = 0;
                    if (!playerProfile.upgrades.reroll_charges) playerProfile.upgrades.reroll_charges = 0;
                    if (!playerProfile.rerollCharges) playerProfile.rerollCharges = 0;
                } else {
                    playerProfile = {
                        totalCurrency: 0,
                        highScore: 0,
                        upgrades: { 
                            'max_hp': 0,
                            'start_energy': 0,
                            'start_heal': 0,
                            'greed': 0,
                            'smith_chance': 0,
                            'reroll_charges': 0,
                        },
                        baseHp: 50,
                        baseEnergy: 3,
                        startHeal: 0,
                        greedBonus: 0,
                        smithChance: 0,
                        rerollCharges: 0,
                    };
                    savePlayerProfile();
                }
                updateMainMenuUI();
            }

            function savePlayerProfile() {
                localStorage.setItem(PROFILE_KEY, JSON.stringify(playerProfile));
            }

            function saveRunState() {
                if (!runState || runState.gameState === GAME_STATES.MAIN_MENU || runState.gameState === GAME_STATES.GAME_OVER) {
                    return;
                }
                
                const savableState = { ...runState };
                if (savableState.enemy) {
                    const { dom, ...savableEnemy } = savableState.enemy;
                    savableState.enemy = savableEnemy;
                }
                localStorage.setItem(RUN_KEY, JSON.stringify(savableState));
            }

            function loadRunState() {
                const savedRun = localStorage.getItem(RUN_KEY);
                if (!savedRun) return;

                runState = JSON.parse(savedRun);

                // é‡æ–° "é™„åŠ " (Hydrate) DOM å¼•ç”¨
                if (runState.enemy) {
                    runState.enemy.dom = {
                        container: $(`#enemy-container-0`),
                        intent: $(`#enemy-intent-0`),
                        sprite: $(`#enemy-sprite-0`),
                        hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                        hpText: $(`#enemy-hp-text-0`),
                        blockText: $(`#enemy-block-text-0`),
                        statusIcons: $(`#enemy-status-icons-0`),
                    };
                }
                
                // æ¢å¤æ¸¸æˆ
                updatePathDisplay();
                updateAllUI();
                setGameState(runState.gameState); 
            }
            
            function updateMainMenuUI() {
                D.mainMenu.highScore.textContent = playerProfile.highScore;
            }
            
            function showUpgradeScreen() {
                D.upgrades.currency.textContent = `${playerProfile.totalCurrency} ğŸ”¥`;
                const container = D.upgrades.optionsContainer;
                container.innerHTML = '';
                
                for (const id in upgradeDefinitions) {
                    const def = upgradeDefinitions[id];
                    const level = playerProfile.upgrades[id] || 0;
                    const cost = def.baseCost + (def.costIncrease * level);
                    const canBuy = playerProfile.totalCurrency >= cost && level < def.maxLevel;

                    let buttonText;
                    if (level >= def.maxLevel) {
                        buttonText = 'å·²è¾¾ä¸Šé™';
                    } else {
                        buttonText = `è´­ä¹° (èŠ±è´¹ ${cost} ğŸ”¥)`;
                    }

                    const el = document.createElement('div');
                    el.className = 'p-4 bg-gray-800 rounded-lg border border-gray-700';
                    el.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="text-lg font-bold text-white">${def.name} (Lv ${level}/${def.maxLevel})</h4>
                                <p class="text-sm text-gray-400">${def.desc}</p>
                            </div>
                            <button class="btn ${canBuy ? 'btn-primary' : 'btn-secondary opacity-50'}" data-upgrade-id="${id}" ${!canBuy ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    `;
                    container.appendChild(el);
                }
                
                container.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', (e) => buyUpgrade(e.target.dataset.upgradeId));
                });
                
                setGameState(GAME_STATES.UPGRADES);
            }

            function buyUpgrade(id) {
                const def = upgradeDefinitions[id];
                const level = playerProfile.upgrades[id] || 0;
                const cost = def.baseCost + (def.costIncrease * level);
                
                if (playerProfile.totalCurrency >= cost && level < def.maxLevel) {
                    playerProfile.totalCurrency -= cost;
                    playerProfile.upgrades[id] += 1;
                    def.apply(playerProfile); // åº”ç”¨æ°¸ä¹…å±æ€§
                    
                    savePlayerProfile();
                    showUpgradeScreen(); // åˆ·æ–°UI
                }
            }

            // --- å±€å†…æ¸¸æˆ (Run) ---

            function generateFloorPath(floorNum) {
                let path = [];
                if (floorNum === 1) {
                    path = [
                        NODE_TYPE.MONSTER, NODE_TYPE.MONSTER, NODE_TYPE.EVENT, 
                        NODE_TYPE.ELITE, NODE_TYPE.MONSTER, NODE_TYPE.EVENT,
                        NODE_TYPE.MONSTER, NODE_TYPE.BOSS
                    ];
                } else {
                     path = [
                        NODE_TYPE.MONSTER, NODE_TYPE.MONSTER, NODE_TYPE.EVENT,
                        NODE_TYPE.MONSTER, NODE_TYPE.ELITE, NODE_TYPE.EVENT,
                        NODE_TYPE.ELITE, NODE_TYPE.MONSTER, NODE_TYPE.BOSS
                    ];
                }
                return path;
            }

            function startNewRun() {
                runState = {
                    player: {
                        maxHp: playerProfile.baseHp,
                        hp: Math.min(playerProfile.baseHp, playerProfile.baseHp + playerProfile.startHeal),
                        maxEnergy: playerProfile.baseEnergy,
                        energy: playerProfile.baseEnergy,
                        block: 0,
                        isPlayer: true,
                        status: { vulnerable: 0, weak: 0, strength: 0, barricade: 0 }, 
                        greedBonus: playerProfile.greedBonus,
                        smithChance: playerProfile.smithChance,
                        rerollCharges: playerProfile.rerollCharges,
                    },
                    deck: createStartDeck(),
                    hand: [],
                    discard: [],
                    exhaustPile: [],
                    currentFloor: 1,  
                    currentLevel: 0,  
                    floorPath: [],    
                    runCurrency: 0,
                    gameState: null,
                    selectedCardId: null,
                    selectedRewardCardId: null, 
                    isBossDefeated: false, 
                };
                
                runState.floorPath = generateFloorPath(runState.currentFloor); 
                updatePathDisplay();
                startNextEncounter();
            }
            
            function startNewFloor() {
                runState.currentFloor++;
                runState.currentLevel = 0;
                runState.floorPath = generateFloorPath(runState.currentFloor);
                runState.isBossDefeated = false;
                
                clearPlayerCombatStatus(); 
                
                updatePathDisplay();
                saveRunState(); // ä¿å­˜è¿›åº¦
                startNextEncounter();
            }
            
            function setGameState(newState) {
                if (runState.gameState === GAME_STATES.GAME_OVER && newState !== GAME_STATES.MAIN_MENU) {
                    return; 
                }
                runState.gameState = newState;
                
                // 1. åˆ‡æ¢ä¸»å±å¹•
                Object.values(D.screens).forEach(screen => screen.classList.remove('active'));
                
                // 2. åˆ‡æ¢æ¸¸æˆå­å®¹å™¨
                D.game.combatContainer.style.display = 'none';
                D.game.eventContainer.style.display = 'none';
                D.game.rewardContainer.style.display = 'none';
                
                switch (newState) {
                    case GAME_STATES.MAIN_MENU:
                        D.screens.mainMenu.classList.add('active');
                        break;
                    case GAME_STATES.UPGRADES:
                        D.screens.upgrades.classList.add('active');
                        break;
                    case GAME_STATES.GAME_OVER:
                        D.screens.gameOver.classList.add('active');
                        break;
                    
                    // --- In-Game States ---
                    case GAME_STATES.EVENT:
                        D.screens.game.classList.add('active');
                        D.game.eventContainer.style.display = 'flex';
                        break;
                    case GAME_STATES.REWARD:
                        D.screens.game.classList.add('active');
                        D.game.rewardContainer.style.display = 'flex';
                        break;
                    
                    case GAME_STATES.SMITHING:
                        D.screens.game.classList.add('active');
                        D.game.eventContainer.style.display = 'flex'; // ä¿æŒäº‹ä»¶èƒŒæ™¯å¯è§
                        D.screens.smith.classList.add('active'); // æ¨¡æ€æ¡†
                        break;
                        
                    case GAME_STATES.PLAYER_TURN:
                    case GAME_STATES.PROCESSING_LOGIC:
                    case GAME_STATES.COMBAT_OVER:
                        D.screens.game.classList.add('active');
                        D.game.combatContainer.style.display = 'flex';
                        break;
                }
                
                // 3. ç»“æŸå›åˆæŒ‰é’®
                if (newState === GAME_STATES.PLAYER_TURN) {
                    D.game.endTurnBtn.disabled = false;
                    D.game.endTurnBtn.classList.add('btn-primary');
                    D.game.endTurnBtn.classList.remove('opacity-50');
                } else {
                    D.game.endTurnBtn.disabled = true;
                    D.game.endTurnBtn.classList.remove('btn-primary');
                    D.game.endTurnBtn.classList.add('opacity-50');
                }
                
                // 4. å¥–åŠ±å±å¹•æŒ‰é’®
                if (newState === GAME_STATES.REWARD) {
                    if (runState.player.rerollCharges > 0) {
                        D.rewards.rerollBtn.classList.remove('hidden');
                        D.rewards.rerollBtn.textContent = `é‡æŠ½ (${runState.player.rerollCharges})`;
                        D.rewards.rerollBtn.disabled = false;
                    } else {
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                    D.rewards.confirmBtn.classList.add('hidden'); 
                }
            }

            function createStartDeck() {
                let deck = [];
                for(let i=0; i<6; i++) deck.push(createCardInstance(cardDefinitions.strike));
                for(let i=0; i<4; i++) deck.push(createCardInstance(cardDefinitions.defend));
                return shuffle(deck);
            }
            
            function createCardInstance(cardDef) {
                return { ...cardDef, instanceId: Math.random().toString(36).substring(2, 9) };
            }

            function getEnemyIdForNode(nodeType, floorNum) {
                let pool = [];
                if (nodeType === NODE_TYPE.MONSTER) {
                    pool = (floorNum === 1) ? ['goblin', 'slime'] : ['orc', 'shadow', 'goblin']; 
                } else if (nodeType === NODE_TYPE.ELITE) {
                    pool = ['guardian']; 
                } else if (nodeType === NODE_TYPE.BOSS) {
                    pool = ['golem']; 
                }
                return pool[Math.floor(Math.random() * pool.length)];
            }
            
            function getEventIdForNode(nodeType, floorNum) {
                const pool = ['rest', 'statue', 'chest']; 
                return pool[Math.floor(Math.random() * pool.length)];
            }

            function startNextEncounter() {
                const nodeType = runState.floorPath[runState.currentLevel];
                if (!nodeType) {
                    console.error("è·¯å¾„å·²å°½, ä½†æœªè§¦å‘æ–°æ¥¼å±‚?");
                    gameOver(true); // æ¸¸æˆèƒœåˆ©
                    return;
                }
                
                D.game.floorDisplay.textContent = `ç¬¬ ${runState.currentFloor} å±‚`; 
                
                if (nodeType === NODE_TYPE.MONSTER || nodeType === NODE_TYPE.ELITE || nodeType === NODE_TYPE.BOSS) {
                    const enemyId = getEnemyIdForNode(nodeType, runState.currentFloor);
                    const enemyDef = enemyDefinitions[enemyId];
                    
                    runState.enemy = {
                        ...enemyDef,
                        hp: enemyDef.hp, maxHp: enemyDef.hp,
                        block: 0, nextMove: null, isPlayer: false,
                        status: { vulnerable: 0, weak: 0, strength: 0, barricade: 0 }, 
                        dom: { 
                            container: $(`#enemy-container-0`),
                            intent: $(`#enemy-intent-0`),
                            sprite: $(`#enemy-sprite-0`),
                            hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                            hpText: $(`#enemy-hp-text-0`),
                            blockText: $(`#enemy-block-text-0`),
                            statusIcons: $(`#enemy-status-icons-0`),
                        }
                    };
                    startPlayerTurn();
                } else if (nodeType === NODE_TYPE.EVENT) {
                    const eventId = getEventIdForNode(nodeType, runState.currentFloor);
                    showEventScreen(eventId);
                }
            }
            
            function showEventScreen(eventId) {
                const event = eventDefinitions[eventId];
                if (!event) {
                    console.error(`æœªæ‰¾åˆ°äº‹ä»¶: ${eventId}`);
                    proceedToNextLevel();
                    return;
                }
                
                D.event.title.textContent = event.title;
                D.event.description.innerHTML = formatDescription(event.desc); 
                D.event.options.innerHTML = ''; 
                
                event.choices.forEach(choice => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-event w-full';
                    btn.innerHTML = choice.text; 
                    
                    let disabled = false;
                    if (choice.cost && !choice.cost()) {
                        disabled = true;
                        btn.classList.add('disabled');
                        btn.disabled = true;
                    }
                    
                    if (!disabled) {
                        btn.onclick = choice.action;
                    }
                    D.event.options.appendChild(btn);
                });
                
                setGameState(GAME_STATES.EVENT);
            }
            
            function showSmithScreen() {
                const container = D.smith.container;
                container.innerHTML = '';
                const allCards = [...runState.deck, ...runState.discard, ...runState.hand]
                                 .filter(c => c.type !== 'curse'); 
                
                allCards.forEach(card => {
                    const cardEl = createCardElement(card, card.instanceId);
                    const canUpgrade = !card.upgraded && card.upgradesTo;
                    
                    if (canUpgrade) {
                        cardEl.classList.add('can-upgrade');
                        cardEl.addEventListener('click', () => upgradeCard(card.instanceId));
                    }
                    container.appendChild(cardEl);
                });
                setGameState(GAME_STATES.SMITHING);
            }
            
            function upgradeCard(instanceId) {
                const locations = ['deck', 'discard', 'hand'];
                for (const loc of locations) {
                    const index = runState[loc].findIndex(c => c.instanceId === instanceId);
                    if (index !== -1) {
                        const oldCard = runState[loc][index];
                        if (oldCard.upgradesTo) {
                            const newCardDef = cardDefinitions[oldCard.upgradesTo];
                            runState[loc][index] = { ...newCardDef, instanceId: oldCard.instanceId };
                            
                            // V1.1: å‡çº§åéšè—æ¨¡æ€æ¡†
                            D.screens.smith.classList.remove('active'); 
                            
                            if (Math.random() < runState.player.smithChance) {
                                D.event.description.textContent = "ä½ çµå…‰ä¸€é—ªï¼Œé”»é€ æœªæ¶ˆè€—ç¯ç«ï¼";
                                D.event.options.innerHTML = `<button class="btn btn-primary w-full" id="event-leave">å¤ªå¥½äº†</button>`;
                                $('#event-leave').onclick = () => proceedToNextLevel();
                                setGameState(GAME_STATES.EVENT);
                            } else {
                                proceedToNextLevel(); 
                            }
                            return; 
                        }
                    }
                }
            }
            
            function clearPlayerCombatStatus() {
                runState.player.block = 0;
                runState.player.status.vulnerable = 0;
                runState.player.status.weak = 0;
                updateEntityUI(runState.player);
            }
            
            function proceedToNextLevel() {
                if (runState.gameState !== GAME_STATES.EVENT) {
                    clearPlayerCombatStatus(); 
                }
                
                runState.currentLevel++;
                updatePathDisplay();
                saveRunState(); // ä¿å­˜è¿›åº¦
                startNextEncounter();
            }

            function startPlayerTurn() {
                setGameState(GAME_STATES.PROCESSING_LOGIC); 
                runState.player.energy = runState.player.maxEnergy;
                
                if (!runState.player.status.barricade) {
                    runState.player.block = 0; 
                }
                
                runState.selectedCardId = null;
                
                if (runState.enemy && runState.enemy.hp > 0) { 
                    runState.enemy.nextMove = runState.enemy.moves[Math.floor(Math.random() * runState.enemy.moves.length)];
                }
                
                updateAllUI(); 
                
                drawCards(5, null, () => {
                    setGameState(GAME_STATES.PLAYER_TURN); 
                }); 
            }

            function endPlayerTurn() {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); 
                saveRunState(); 
                
                runState.selectedCardId = null;
                updateTargetHighlights(null); 
                
                runState.discard = [...runState.discard, ...runState.hand];
                runState.hand = [];
                
                tickDownStatus(runState.player);
                
                updateHandUI(); 
                updateEntityUI(runState.player); 
                
                setTimeout(() => enemyTurn(), 500); 
            }
            
            function enemyTurn() {
                const enemy = runState.enemy;
                let onEndCallback = null; 

                onEndCallback = () => {
                    updateAllUI(); 
                    
                    if (runState.player.hp <= 0) {
                        gameOver(false); 
                    } else {
                        setTimeout(() => {
                            if (enemy) {
                                tickDownStatus(enemy); 
                                updateEntityUI(enemy); 
                            }
                            startPlayerTurn(); 
                        }, 500); 
                    }
                };
                
                if (enemy) {
                    if (!enemy.status.barricade) {
                        enemy.block = 0; 
                    }
                    updateEntityUI(enemy); 
                }
                
                if (enemy && enemy.hp > 0) { 
                    if (enemy.onTurn) { 
                        enemy.onTurn(enemy, onEndCallback); 
                    } else if (enemy.nextMove) {
                        executeDefaultEnemyMove(enemy, onEndCallback); 
                    } else {
                        onEndCallback(); 
                    }
                } else {
                    onEndCallback(); 
                }
            }
            
            function executeDefaultEnemyMove(enemy, onEndCallback) {
                const move = enemy.nextMove;
                if (!move) {
                    onEndCallback();
                    return;
                }
                
                let animationDone = false;
                let logicDone = false;
                
                const checkEnd = () => {
                    if (animationDone && logicDone) onEndCallback();
                };
                
                // 1. æ‰§è¡ŒåŠ¨ç”»
                switch (move.type) {
                    case 'attack':
                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                            animationDone = true;
                            checkEnd();
                        });
                        break;
                    case 'defend':
                        addBlock(enemy, move.val); 
                        animationDone = true;
                        break;
                    case 'buff':
                    case 'debuff':
                    case 'pollute':
                        executeEnemyLogic(move, enemy, () => {
                            animationDone = true; 
                            checkEnd();
                        });
                        logicDone = true; 
                        return; 
                    default:
                        animationDone = true;
                }
                
                // 2. æ‰§è¡Œé€»è¾‘
                setTimeout(() => {
                    executeEnemyLogic(move, enemy, () => {
                        logicDone = true;
                        checkEnd();
                    });
                }, 250); 
            }
            
            function executeEnemyLogic(move, enemy, onLogicEnd = () => {}) {
                switch (move.type) {
                    case 'attack':
                        takeDamage(runState.player, move.val, enemy);
                        onLogicEnd();
                        break;
                    case 'defend':
                        onLogicEnd();
                        break;
                    case 'buff':
                        applyStatus(enemy, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'debuff':
                        applyStatus(runState.player, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'pollute':
                        addCardToDiscard(cardDefinitions.slime_curse, move.val, enemy, onLogicEnd);
                        break;
                    default:
                        onLogicEnd();
                }
            }

            // --- å¡ç‰Œé€»è¾‘ ---
            
            function drawCards(amount, sourceCard = null, onAllCardsDrawn = () => {}) {
                let handRect = D.game.handArea.getBoundingClientRect();
                let deckRect = D.game.deckCount.getBoundingClientRect();
                let drawnCardsData = []; 
                
                for (let i = 0; i < amount; i++) {
                    if (runState.deck.length === 0) {
                        if (runState.discard.length === 0) break; 
                        runState.deck = shuffle(runState.discard);
                        runState.discard = [];
                        updateDeckDiscardUI();
                    }
                    const card = runState.deck.pop();
                    runState.hand.push(card);
                    drawnCardsData.push(card);
                }
                
                updateDeckDiscardUI(); 

                if (drawnCardsData.length === 0) {
                    onAllCardsDrawn();
                    return;
                }

                drawnCardsData.forEach((card, index) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    cardEl.classList.add('drawing'); 
                    
                    const startX = (deckRect.left + deckRect.width / 2) - (handRect.left + 40); 
                    const startY = (deckRect.top + deckRect.height / 2) - (handRect.top + handRect.height / 2);
                    cardEl.style.transform = `translate(${startX}px, ${startY}px) scale(0.5)`;
                    
                    D.game.handArea.appendChild(cardEl); 

                    setTimeout(() => {
                        cardEl.classList.remove('drawing');
                        cardEl.style.transform = ``;
                        cardEl.style.position = 'relative'; 
                        
                        if (index === drawnCardsData.length - 1) { 
                            setTimeout(() => {
                                updateHandUI(); 
                                onAllCardsDrawn();
                            }, 400); 
                        }
                    }, (sourceCard ? 0 : index * 100) + 50); 
                });
            }
            
            function addCardToDiscard(cardDef, amount, source = null, onEndCallback = () => {}) {
                const targetEl = D.game.discardCount.parentElement; 
                const sourceEl = source?.dom?.container || D.game.enemyArea;
                
                for(let i = 0; i < amount; i++) {
                    createAndFireProjectile(sourceEl, targetEl, 'ğŸŸ£', () => {
                        runState.discard.push(createCardInstance(cardDef));
                        updateDeckDiscardUI();
                        if (i === amount - 1) onEndCallback();
                    });
                }
            }
            
            function addCardToDeck(cardDef) {
                if (!cardDef) return;
                runState.deck.push(createCardInstance(cardDef));
                updateDeckDiscardUI();
            }
            
            function onCardClick(cardInstanceId) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                const card = runState.hand.find(c => c.instanceId === cardInstanceId);
                if (!card || card.type === 'curse') return; 
                
                if (runState.player.energy < card.cost) return; 

                if (runState.selectedCardId === cardInstanceId) {
                    runState.selectedCardId = null;
                    updateHandUI();
                    updateTargetHighlights(null);
                } else {
                    runState.selectedCardId = cardInstanceId;
                    updateHandUI();
                    updateTargetHighlights(card); 
                }
            }
            
            function onEnemyClick(enemy) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
                const card = runState.hand.find(c => c.instanceId === runState.selectedCardId);
                if (!card) return;
                if (card.target === 'enemy') {
                    playCard(card, enemy);
                }
            }
            
            function onPlayerClick() {
                 if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
                const card = runState.hand.find(c => c.instanceId === runState.selectedCardId);
                if (!card) return;
                if (card.target === 'self') {
                    playCard(card, runState.player);
                }
            }

            function playCard(card, target) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); 
                
                runState.player.energy -= card.cost;
                runState.hand = runState.hand.filter(c => c.instanceId !== card.instanceId);
                
                if (card.exhaust) {
                    runState.exhaustPile.push(card);
                } else {
                    runState.discard.push(card);
                }
                
                runState.selectedCardId = null;
                updateTargetHighlights(null);
                updateHandUI(); 

                card.effect(runState.player, target, card);
                
                let animationTime = 200; 
                if (card.type === 'attack') animationTime = 500;
                if (card.id.includes('double_hit')) animationTime = 700;
                if (card.id.includes('bulwark') && runState.player.block > 0) animationTime = 700; 
                if (card.id.includes('battle_focus')) animationTime = 1000; 
                if (card.id.includes('adrenaline')) animationTime = 1000; 
                
                setTimeout(() => {
                    updateAllUI(); 
                    
                    if (runState.enemy.hp <= 0) {
                        setGameState(GAME_STATES.COMBAT_OVER);
                        enemyKilled();
                    } else if (runState.player.hp <= 0) {
                        gameOver(false);
                    } else {
                        updateHandUI(); 
                        setGameState(GAME_STATES.PLAYER_TURN); 
                    }
                }, animationTime); 
            }
            
            function enemyKilled() {
                const isBoss = runState.enemy.isBoss || false;
                const rewardType = isBoss ? CARD_RARITY.RARE : CARD_RARITY.COMMON;
                runState.isBossDefeated = isBoss;
                
                const currencyGained = Math.floor(runState.enemy.currency * (1 + runState.player.greedBonus));
                runState.runCurrency += currencyGained;
                
                setTimeout(() => showRewardScreen(currencyGained, rewardType), 1000); 
            }
            
            function showRewardScreen(currencyGained, rewardType) {
                D.rewards.currency.textContent = `${currencyGained} ğŸ”¥`;
                if (runState.isBossDefeated) {
                    D.rewards.title.textContent = 'Boss å·²å‡»è´¥ï¼';
                } else {
                    D.rewards.title.textContent = 'æˆ˜æ–—èƒœåˆ©ï¼';
                }
                generateRewardOptions(rewardType);
                setGameState(GAME_STATES.REWARD);
            }
            
            function getCardPool(rarity) {
                return Object.values(cardDefinitions).filter(c => c.rarity === rarity);
            }
            
            function getRandomCard(rarity) {
                const pool = getCardPool(rarity);
                if (pool.length === 0) return null;
                return pool[Math.floor(Math.random() * pool.length)];
            }
            
            function generateRewardOptions(rewardType) {
                const optionsContainer = D.rewards.options;
                optionsContainer.innerHTML = '';
                runState.selectedRewardCardId = null; 
                
                const commonPool = getCardPool(CARD_RARITY.COMMON);
                let options = [];
                
                if (rewardType === CARD_RARITY.RARE) {
                    const rarePool = getCardPool(CARD_RARITY.RARE);
                    if (rarePool.length > 0) {
                        options.push(rarePool[Math.floor(Math.random() * rarePool.length)]);
                    }
                    options = options.concat(shuffle(commonPool).slice(0, 2));
                } else {
                    options = shuffle(commonPool).slice(0, 3);
                }
                
                shuffle(options).forEach(cardDef => {
                    if (!cardDef) return;
                    const cardEl = createCardElement(cardDef);
                    cardEl.classList.add('reward-card'); 
                    cardEl.addEventListener('click', () => onRewardCardClick(cardDef, cardEl)); 
                    optionsContainer.appendChild(cardEl);
                });
            }
            
            function onRewardCardClick(cardDef, cardEl) {
                $$('.reward-card.selected-reward').forEach(el => el.classList.remove('selected-reward'));
                
                cardEl.classList.add('selected-reward');
                runState.selectedRewardCardId = cardDef.id;
                
                D.rewards.confirmBtn.classList.remove('hidden');
            }

            function selectReward(cardDef) {
                addCardToDeck(cardDef); 
                
                runState.selectedRewardCardId = null;
                D.rewards.confirmBtn.classList.add('hidden');
                $$('.reward-card.selected-reward').forEach(el => el.classList.remove('selected-reward'));

                if (runState.isBossDefeated) {
                    startNewFloor();
                } else {
                    proceedToNextLevel();
                }
            }
            
            // --- æˆ˜æ–—æ•°å€¼ ---
            
            function applyStatus(target, status, duration, source, onEndCallback = () => {}) {
                const def = statusDefinitions[status];
                const sourceEl = source.isPlayer ? D.game.playerContainer : source.dom.container;
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                
                let iconHTML = '...';
                switch(status) {
                    case 'vulnerable': iconHTML = 'ğŸŸ '; break;
                    case 'weak': iconHTML = 'ğŸ”˜'; break;
                    case 'strength': iconHTML = 'ğŸ”´'; break;
                    case 'barricade': iconHTML = 'ğŸ”µ'; break;
                }
                
                createAndFireProjectile(sourceEl, targetEl, iconHTML, () => {
                    if (status === 'strength') {
                        target.status.strength = (target.status.strength || 0) + duration;
                    } else if (status === 'barricade') {
                        target.status.barricade = 1; 
                    } else {
                        target.status[status] = (target.status[status] || 0) + duration;
                    }
                    updateEntityUI(target);
                    if (onEndCallback) onEndCallback();
                });
            }

            function tickDownStatus(target) {
                if (target.status.vulnerable > 0) target.status.vulnerable--;
                if (target.status.weak > 0) target.status.weak--;
            }
            
            function dealDamage(target, amount, source, delay = 0) {
                setTimeout(() => {
                    let modifiedAmount = amount;
                    
                    if (source && source.status.strength > 0) {
                        modifiedAmount += source.status.strength;
                    }
                    
                    if (source && source.status.weak > 0) {
                        modifiedAmount = Math.floor(modifiedAmount * 0.5);
                    }
                    
                    let isVulnerable = target.status.vulnerable > 0;
                    if (isVulnerable) {
                        modifiedAmount = Math.floor(modifiedAmount * 1.5);
                    }

                    let damageDealt = modifiedAmount;
                    if (target.block > 0) {
                        if (target.block >= damageDealt) {
                            target.block -= damageDealt;
                            damageDealt = 0;
                        } else {
                            damageDealt -= target.block;
                            target.block = 0;
                        }
                    }
                    
                    target.hp -= damageDealt;
                    if (target.hp < 0) target.hp = 0; 
                    
                    if (damageDealt > 0) {
                        const floatType = isVulnerable ? 'damage vulnerable' : 'damage';
                        showFloatingText(`-${damageDealt}`, target.isPlayer ? D.game.playerContainer : target.dom.container, floatType);
                        playAnimation(target.isPlayer ? D.game.playerContainer : target.dom.sprite, 'anim-shake');
                    }
                    
                    updateEntityUI(target);
                }, delay);
            }
            
            function takeDamage(target, amount, source) {
                dealDamage(target, amount, source, 0);
            }
            
            function addBlock(target, amount) {
                target.block += amount;
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block');
                
                const animEl = document.createElement('div');
                animEl.className = 'anim-block-shield';
                animEl.innerHTML = 'ğŸ›¡ï¸';
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                targetEl.appendChild(animEl);
                animEl.addEventListener('animationend', () => animEl.remove());
                
                updateEntityUI(target);
            }
            
            function healDamage(target, amount) {
                target.hp = Math.min(target.maxHp, target.hp + amount);
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block-float text-green-500'); // ç»¿è‰²
                updateEntityUI(target);
            }
            
            function gameOver(isWin) {
                if (runState.gameState === GAME_STATES.GAME_OVER) return; 
                
                localStorage.removeItem(RUN_KEY); 
                
                playerProfile.totalCurrency += runState.runCurrency;
                if (runState.currentFloor > playerProfile.highScore) {
                    playerProfile.highScore = runState.currentFloor;
                }
                savePlayerProfile();
                
                if (isWin) {
                    D.gameOver.title.textContent = 'ä½ èƒœåˆ©äº†ï¼';
                    D.gameOver.title.classList.remove('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} ğŸ”¥`;
                } else {
                    D.gameOver.title.textContent = 'ä½ å€’ä¸‹äº†';
                    D.gameOver.title.classList.add('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} ğŸ”¥`;
                }
                setGameState(GAME_STATES.GAME_OVER);
            }

            // --- æ¸²æŸ“ / UI ---
            
            function updateAllUI() {
                if (!runState || !runState.player) return; 

                updateEntityUI(runState.player);
                D.game.playerEnergyText.textContent = `${runState.player.energy}/${runState.player.maxEnergy}`;
                
                if (runState.enemy && runState.enemy.hp > 0) {
                    updateEntityUI(runState.enemy);
                    const e = runState.enemy;
                    e.dom.sprite.textContent = e.sprite;
                    if (e.nextMove) {
                        e.dom.intent.innerHTML = `<span>${e.nextMove.intent}</span>`;
                        e.dom.intent.dataset.intentKey = e.nextMove.intentKey;
                        e.dom.intent.dataset.intentVal = e.nextMove.val || 0;
                        e.dom.intent.dataset.intentCount = e.nextMove.count || 0;
                        e.dom.intent.classList.remove('hidden');
                    } else {
                        e.dom.intent.classList.add('hidden');
                    }
                } else if (runState.enemy) {
                    const e = runState.enemy;
                    e.dom.sprite.textContent = e.sprite;
                    e.dom.intent.classList.add('hidden');
                }
                
                updateDeckDiscardUI();
            }
            
            function updateEntityUI(entity) {
                if (!entity) return;

                let hpBar, hpText, blockText, statusIconContainer;
                
                if (entity.isPlayer) {
                    hpBar = D.game.playerHPBar;
                    hpText = D.game.playerHPText;
                    blockText = D.game.playerBlockText;
                    statusIconContainer = D.game.playerStatusIcons; 
                } else if (entity.dom) {
                    hpBar = entity.dom.hpBar;
                    hpText = entity.dom.hpText;
                    blockText = entity.dom.blockText;
                    statusIconContainer = entity.dom.statusIcons;
                } else {
                    return; 
                }
                
                // HP
                if (hpBar) {
                    hpBar.style.width = `${Math.max(0, (entity.hp / entity.maxHp) * 100)}%`;
                }
                if (hpText) {
                    hpText.textContent = `${entity.hp} / ${entity.maxHp}`;
                }
                
                // Block
                if (blockText) {
                    if (entity.block > 0) {
                        blockText.textContent = `ğŸ›¡ï¸ ${entity.block}`;
                        blockText.classList.remove('hidden');
                    } else {
                        blockText.classList.add('hidden');
                    }
                }
                
                // Status Icons
                if (statusIconContainer) {
                    statusIconContainer.innerHTML = ''; // æ¸…ç©ºæ—§å›¾æ ‡
                    for (const statusId in entity.status) {
                        const duration = entity.status[statusId];
                        if (duration > 0) { // åªæ¸²æŸ“æ¿€æ´»çš„çŠ¶æ€
                            const def = statusDefinitions[statusId];
                            if (!def) continue; 

                            let durationText = duration;
                            if (statusId === 'strength') {
                                durationText = `+${duration}`; 
                            } else if (statusId === 'barricade') {
                                durationText = ``; 
                            }

                            const iconEl = document.createElement('div');
                            iconEl.className = `status-icon status-${def.color}`; 
                            iconEl.innerHTML = `<span>${statusId === 'barricade' ? def.icon : durationText}</span>`; 
                            iconEl.dataset.statusId = statusId; 
                            
                            statusIconContainer.appendChild(iconEl);
                        }
                    }
                }
            }
            
            function updateHandUI() {
                const hand = runState.hand;
                const handArea = D.game.handArea;
                
                handArea.innerHTML = ''; 
                
                hand.forEach((card) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    
                    const isPlayable = runState.player.energy >= card.cost;
                    if (isPlayable) cardEl.classList.add('playable');
                    else cardEl.classList.add('unplayable');
                    
                    if (card.instanceId === runState.selectedCardId) {
                        cardEl.classList.add('selected');
                    }
                    
                    handArea.appendChild(cardEl);
                });
            }
            
            function formatDescription(desc) {
                if (!desc) return '';
                return desc
                    .replace(/<k>æ˜“ä¼¤<\/k>/g, '<span class="keyword" data-keyword="vulnerable">æ˜“ä¼¤</span>')
                    .replace(/<k>è™šå¼±<\/k>/g, '<span class="keyword" data-keyword="weak">è™šå¼±</span>')
                    .replace(/<k>æ¶ˆè€—<\/k>/g, '<span class="keyword" data-keyword="exhaust">æ¶ˆè€—</span>')
                    .replace(/<k>è¯…å’’<\/k>/g, '<span class="keyword" data-keyword="curse">è¯…å’’</span>')
                    .replace(/<k>æ ¼æŒ¡<\/k>/g, '<span class="keyword" data-keyword="barricade">æ ¼æŒ¡</span>') 
                    .replace(/<strong>æ˜“ä¼¤<\/strong>/g, '<span class="keyword" data-keyword="vulnerable"><strong>æ˜“ä¼¤</strong></span>')
                    .replace(/<strong>è™šå¼±<\/strong>/g, '<span class="keyword" data-keyword="weak"><strong>è™šå¼±</strong></span>');
            }
            
            function createCardElement(cardDef, instanceId = null) {
                const el = document.createElement('div');
                el.className = 'card';
                if(instanceId) {
                    el.classList.add('hand-card');
                    el.id = `hand-card-${instanceId}`; 
                    el.dataset.instanceId = instanceId;
                }
                
                el.classList.add(`rarity-${cardDef.rarity || 'common'}`);
                
                if(cardDef.upgraded) el.classList.add('upgraded');
                if(cardDef.exhaust) el.classList.add('exhaust');
                if(cardDef.type === 'curse') el.classList.add('curse');
                
                let typeText = '';
                let typeColor = '';
                switch(cardDef.type) {
                    case 'attack': typeText = 'æ”»å‡»'; typeColor = 'text-red-400'; break;
                    case 'skill': typeText = 'æŠ€èƒ½'; typeColor = 'text-blue-400'; break;
                    case 'curse': typeText = 'è¯…å’’'; typeColor = 'text-purple-400'; break;
                }
                
                let descHTML = cardDef.desc;
                if (cardDef.exhaust) descHTML += " (<k>æ¶ˆè€—</k>)";
                if (cardDef.type === 'curse') descHTML += " (<k>è¯…å’’</k>)";
                
                descHTML = formatDescription(descHTML);
                
                let nameClass = `card-name ${cardDef.upgraded ? 'upgraded' : ''}`;
                if (cardDef.rarity === CARD_RARITY.RARE && !cardDef.upgraded) {
                    nameClass += ' rarity-rare'; 
                }
                
                el.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="card-cost">${cardDef.cost}</div>
                        <div class="text-xs ${typeColor}">${typeText}</div>
                    </div>
                    <div class="${nameClass}">${cardDef.name}</div>
                    <div class="card-desc">${descHTML}</div>
                `;
                return el;
            }
            
            function updateDeckDiscardUI() {
                D.game.deckCount.textContent = runState.deck.length;
                D.game.discardCount.textContent = runState.discard.length;
            }
            
            function updatePathDisplay() {
                D.game.pathDisplay.innerHTML = '';
                const { floorPath, currentLevel } = runState;
                
                floorPath.forEach((nodeType, index) => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'path-node';
                    let sprite = '';
                    
                    if (index < currentLevel) {
                        nodeEl.classList.add('cleared');
                        sprite = NODE_SPRITES[nodeType];
                    } else if (index === currentLevel) {
                        nodeEl.classList.add('current');
                        sprite = NODE_SPRITES[nodeType];
                    } else {
                        // æœªæ¢ç´¢
                        if (index === floorPath.length - 1) {
                            // Boss èŠ‚ç‚¹
                            nodeEl.classList.add('boss');
                            sprite = NODE_SPRITES[NODE_TYPE.BOSS];
                        } else {
                            // è¿·é›¾
                            sprite = NODE_SPRITES.FOG;
                        }
                    }
                    
                    nodeEl.textContent = sprite;
                    D.game.pathDisplay.appendChild(nodeEl);
                });
            }
            
            function updateTargetHighlights(card) {
                $$('.targeted').forEach(el => el.classList.remove('targeted'));
                
                if (!card) return; 
                
                if (card.target === 'enemy') {
                    if (runState.enemy) runState.enemy.dom.container.classList.add('targeted');
                } else if (card.target === 'self') { 
                    D.game.playerContainer.classList.add('targeted');
                }
            }
            
            function showFloatingText(text, targetElement, type) {
                const floatEl = document.createElement('div');
                floatEl.className = `damage-float ${type}`; 
                
                floatEl.textContent = text;
                const xOffset = (Math.random() - 0.5) * 40; 
                floatEl.style.left = `calc(50% + ${xOffset}px)`;
                targetElement.appendChild(floatEl);
                floatEl.addEventListener('animationend', () => floatEl.remove());
            }
            
            function playAnimation(target, animationClass, onEndCallback = null) {
                if (!target) {
                    if (onEndCallback) onEndCallback();
                    return;
                }
                target.classList.add(animationClass);
                const onAnimEnd = () => {
                    target.classList.remove(animationClass);
                    target.removeEventListener('animationend', onAnimEnd);
                    if (onEndCallback) onEndCallback();
                };
                target.addEventListener('animationend', onAnimEnd);
            }
            
            function createAndFireProjectile(sourceEl, targetEl, iconHTML, onEndCallback) {
                const proj = document.createElement('div');
                proj.className = 'anim-projectile';
                proj.innerHTML = iconHTML;
                
                const startRect = sourceEl.getBoundingClientRect();
                const endRect = targetEl.getBoundingClientRect();
                const gameRect = D.gameContainer.getBoundingClientRect();
                
                const startX = (startRect.left + startRect.width / 2) - gameRect.left;
                const startY = (startRect.top + startRect.height / 2) - gameRect.top;
                
                const endX = (endRect.left + endRect.width / 2) - gameRect.left;
                const endY = (endRect.top + endRect.height / 2) - gameRect.top;
                
                proj.style.left = `${startX}px`;
                proj.style.top = `${startY}px`;
                proj.style.transform = 'translate(-50%, -50%)';

                D.animationLayer.appendChild(proj);

                requestAnimationFrame(() => {
                    proj.style.transform = `translate(-50%, -50%) translate(${endX - startX}px, ${endY - startY}px)`;
                });
                
                proj.addEventListener('transitionend', () => {
                    proj.remove();
                    if (onEndCallback) onEndCallback();
                });
            }

            // --- å·¥å…·å‡½æ•° ---
            function shuffle(array) {
                let newArr = [...array];
                for (let i = newArr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                }
                return newArr;
            }

            // --- äº‹ä»¶ç»‘å®š ---

            function initTooltipListeners() {
                const tooltip = D.tooltip.el;
                let currentTooltipTarget = null; 

                function showTooltip(target) {
                    if (!target) return;
                    
                    let title = '';
                    let desc = '';
                    currentTooltipTarget = target; 

                    // 1. æ£€æŸ¥æ˜¯ä»€ä¹ˆç±»å‹çš„ç›®æ ‡
                    if (target.dataset.statusId) {
                        const statusId = target.dataset.statusId;
                        const def = statusDefinitions[statusId];
                        if (!def) return;
                        
                        const isPlayer = target.closest('#player-status-area');
                        const entity = isPlayer ? runState.player : runState.enemy;
                        const duration = entity.status[statusId];
                        
                        title = `${def.name} ${def.icon}`;
                        if (statusId === 'strength') {
                            title += ` (${duration} å±‚)`;
                        } else if (statusId !== 'barricade') {
                            title += ` (å‰©ä½™ ${duration} å›åˆ)`;
                        }
                        desc = def.desc;
                        
                    } else if (target.dataset.intentKey) {
                        const key = target.dataset.intentKey;
                        const val = target.dataset.intentVal;
                        const count = target.dataset.intentCount;
                        const def = intentDefinitions[key];
                        if (!def) return;
                        
                        title = def.name;
                        desc = def.desc(val, count); 
                        
                    } else if (target.dataset.keyword) {
                        const key = target.dataset.keyword;
                        let def = statusDefinitions[key]; 
                        if (key === 'barricade' && target.closest('.card-desc')) {
                            def = statusDefinitions['barricade'];
                        }
                        if (!def) return;
                        
                        title = `${def.name} ${def.icon || ''}`;
                        desc = def.desc;
                    } else {
                        return; 
                    }

                    // 2. å¡«å……å†…å®¹
                    D.tooltip.title.innerHTML = title;
                    D.tooltip.desc.innerHTML = formatDescription(desc);
                    
                    tooltip.classList.add('visible'); 

                    // 3. å®‰å…¨å®šä½
                    const gameRect = D.gameContainer.getBoundingClientRect();
                    const ttRect = tooltip.getBoundingClientRect(); 
                    const targetRect = target.getBoundingClientRect();
                    
                    const targetTop = targetRect.top - gameRect.top;
                    const targetLeft = targetRect.left - gameRect.left;
                    
                    let ttLeft = targetLeft + (targetRect.width / 2); 
                    let ttTop = targetTop - 8; 
                    let transform = 'translate(-50%, -100%)'; 
                    
                    if ((targetRect.top - ttRect.height - 10) < gameRect.top) {
                        ttTop = targetTop + targetRect.height + 8; 
                        transform = 'translate(-50%, 0)';
                    }
                    
                    if ((targetLeft + (targetRect.width / 2) - (ttRect.width / 2)) < gameRect.left) {
                        ttLeft = 5; 
                        transform = transform.replace('translate(-50%', 'translate(0%');
                    }
                    
                    if ((targetLeft + (targetRect.width / 2) + (ttRect.width / 2)) > (gameRect.left + gameRect.width)) {
                        ttLeft = gameRect.width - 5; 
                        transform = transform.replace('translate(-50%', 'translate(-100%');
                    }

                    tooltip.style.left = `${ttLeft}px`;
                    tooltip.style.top = `${ttTop}px`;
                    tooltip.style.transform = transform;
                }

                function hideTooltip() {
                    tooltip.classList.remove('visible'); 
                    currentTooltipTarget = null;
                }
                
                D.gameContainer.addEventListener('click', (e) => {
                    const tooltipTarget = e.target.closest('.status-icon, [data-intent-key], .keyword');
                    
                    if (tooltipTarget) {
                        e.stopPropagation(); 
                        
                        if (currentTooltipTarget === tooltipTarget) {
                            hideTooltip();
                        } else {
                            showTooltip(tooltipTarget);
                        }
                        return; 
                    }
                    
                    const cardTarget = e.target.closest('.hand-card, .enemy-container, .player-container, .btn-event');
                    if (!cardTarget) {
                        hideTooltip();
                    }
                });
            }
            
            D.mainMenu.continueBtn.addEventListener('click', () => loadRunState());
            D.mainMenu.startBtn.addEventListener('click', () => {
                localStorage.removeItem(RUN_KEY); 
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = 'å¼€å§‹æ¢ç´¢';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                startNewRun();
            });
            D.mainMenu.upgradesBtn.addEventListener('click', () => showUpgradeScreen());
            
            D.upgrades.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            D.game.endTurnBtn.addEventListener('click', () => endPlayerTurn());
            
            D.game.enemyArea.addEventListener('click', (e) => {
                const enemyContainer = e.target.closest('.enemy-container');
                if (enemyContainer && enemyContainer.id === 'enemy-container-0') {
                    onEnemyClick(runState.enemy);
                }
            });
            D.game.playerContainer.addEventListener('click', () => onPlayerClick());
            
            D.game.handArea.addEventListener('click', (e) => {
                const cardEl = e.target.closest('.hand-card');
                if (cardEl && !e.target.closest('.keyword')) { 
                    onCardClick(cardEl.dataset.instanceId);
                }
            });

            D.rewards.confirmBtn.addEventListener('click', () => {
                if (runState.selectedRewardCardId) {
                    selectReward(cardDefinitions[runState.selectedRewardCardId]);
                }
            });
            D.rewards.skipBtn.addEventListener('click', () => selectReward(null));
            D.rewards.rerollBtn.addEventListener('click', () => {
                if (runState.player.rerollCharges > 0) {
                    runState.player.rerollCharges--;
                    const rewardType = runState.isBossDefeated ? CARD_RARITY.RARE : CARD_RARITY.COMMON;
                    generateRewardOptions(rewardType); 
                    D.rewards.rerollBtn.textContent = `é‡æŠ½ (${runState.player.rerollCharges})`;
                    D.rewards.confirmBtn.classList.add('hidden'); 
                    if (runState.player.rerollCharges === 0) {
                        D.rewards.rerollBtn.disabled = true;
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                }
            });

            D.gameOver.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = 'å¼€å§‹æ¢ç´¢';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            // V1.1: é”»é€ ç•Œé¢çš„ "ç¦»å¼€" æŒ‰é’®
            D.smith.backBtn.addEventListener('click', () => {
                D.screens.smith.classList.remove('active'); // éšè—æ¨¡æ€æ¡†
                proceedToNextLevel(); // ç¦»å¼€äº‹ä»¶
            });

            // --- æ¸¸æˆå¯åŠ¨ ---
            function init() {
                defineStatus();
                defineIntents(); 
                defineCards();
                defineEnemies();
                defineEvents(); 
                defineUpgrades();
                initTooltipListeners(); 
                loadPlayerProfile();
                
                const savedRun = localStorage.getItem(RUN_KEY);
                if (savedRun) {
                    const loadedState = JSON.parse(savedRun);
                    D.mainMenu.startBtn.textContent = 'å¼€å§‹æ–°æ¢ç´¢'; 
                    D.mainMenu.startBtn.classList.replace('btn-primary', 'btn-secondary'); 
                    
                    D.mainMenu.continueBtn.textContent = `ç»§ç»­æ¢ç´¢ (ç¬¬ ${loadedState.currentFloor} å±‚)`; 
                    D.mainMenu.continueBtn.classList.remove('hidden');
                }
                
                setGameState(GAME_STATES.MAIN_MENU);
            }
            
            init();
        });
    </script>
</body>
</html>


