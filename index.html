<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>深径：余烬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    
    <style>
        :root {
            --color-bg: #111827; /* 深灰蓝 */
            --color-surface: #1f2937; /* 表面 */
            --color-border: #374151; /* 边框 */
            --color-text: #e5e7eb; /* 文本 */
            --color-text-dim: #9ca3af; /* 暗文本 */
            --color-accent: #22d3ee; /* 青色 (能量) */
            --color-accent-dark: #0e7490;
            --color-red: #ef4444; /* 红色 (伤害) */
            --color-blue: #3b82f6; /* 蓝色 (格挡) */
            --color-yellow: #eab308; /* 黄色 (奖励) */
            --color-green: #22c55e; /* 绿色 (升级) */
            --color-orange: #f97316; /* 橙色 (易伤) */
            --color-gray: #6b7280; /* 灰色 (虚弱) */
            --color-purple: #a855f7; /* 紫色 (诅咒) */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            overscroll-behavior: none; /* 禁止"拉动刷新" */
            -webkit-user-select: none; /* 禁止文本选择 */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent; 
        }

        /* 游戏主容器，模拟竖屏手机 */
        .game-container {
            width: 100%;
            height: 100vh;
            max-width: 420px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
            position: relative;
        }
        
        /* 游戏主容器内的绝对定位层，用于动画 */
        #animation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 40; /* 必须在UI下面，但在背景之上 */
        }

        /* 隐藏的屏幕 */
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 1; /* 保证屏幕在动画层之上 */
        }
        .screen.active {
            display: flex;
            opacity: 1;
            position: relative;
            pointer-events: auto;
            z-index: 2; /* 激活的屏幕在最前 */
        }
        
        /* 模态框 (用于锻造) */
        .modal-screen {
            position: absolute;
            z-index: 10;
            background-color: rgba(0,0,0,0.5); /* 半透明遮罩 */
            backdrop-filter: blur(4px);
            display: flex; /* 默认隐藏 */
        }
        .modal-screen.active {
            display: flex; /* 激活时显示 */
            opacity: 1;
            pointer-events: auto;
            z-index: 11; /* 模态框在所有之上 */
        }
        .modal-content {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
        }

        /* 卡牌样式 */
        .card {
            width: 80px;
            height: 110px;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease, margin 0.2s ease; /* V1.14: 增加 margin 过渡 */
            cursor: pointer;
            flex-shrink: 0;
            position: relative; 
        }
        .card-cost {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--color-accent);
            color: var(--color-bg);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            border: 1px solid var(--color-accent-dark);
        }
        .card.curse .card-cost {
            background-color: var(--color-purple);
            border-color: var(--color-purple);
            color: var(--color-text);
        }
        .card-name {
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
        }
        .card-name.upgraded {
            color: var(--color-green);
        }
        .card-desc {
            font-size: 0.75rem;
            text-align: center;
            color: var(--color-text-dim);
        }
        .card-desc .keyword {
            color: var(--color-yellow);
            font-weight: 600;
            cursor: help;
        }
        .card.upgraded {
            border-color: var(--color-green);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        .card.exhaust .card-desc::after {
            content: " (消耗)";
            font-style: italic;
            color: var(--color-text-dim);
        }
        .card.curse {
            border-color: var(--color-purple);
        }
        
        /* V1.14: 手牌区域重构 */
        #hand-area {
            height: 160px; /* 增加一点高度 */
            background-color: var(--color-bg); /* 改为更深的背景 */
            border-top: 2px solid var(--color-border);
            padding: 10px 40px; /* V1.14: 增加左右内边距，确保滚动到边缘 */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-x: auto; /* 允许水平滚动 */
            position: relative;
        }
        .hand-card {
            margin-left: -30px; /* V1.14: 负外边距实现卡牌重叠 */
        }
        .hand-card:first-child {
            margin-left: 0; /* 第一张卡没有负外边距 */
        }
        /* V1.14: 悬停/选中时，移除负外边距，使其“弹出” */
        .hand-card:hover {
            transform: translateY(-10px) scale(1.05);
            margin-left: 0;
            margin-right: -30px; /* 补偿右侧卡牌 */
            z-index: 10;
        }
        .hand-card:hover + .hand-card {
            margin-left: 0; /* 悬停时，右侧的卡牌也展开 */
        }
        .hand-card.selected {
            transform: translateY(-20px) scale(1.1);
            border-color: var(--color-accent);
            box-shadow: 0 0 20px 5px rgba(34, 211, 238, 0.3);
            margin-left: 0;
            margin-right: -30px;
            z-index: 20;
        }
        .hand-card.selected + .hand-card {
            margin-left: 0;
        }
        
        .hand-card.playable {
            border-color: var(--color-accent);
        }
        .hand-card.unplayable {
            opacity: 0.6;
            background-color: #333;
        }
        /* V1.14: 抽卡动画的起始状态 */
        .hand-card.drawing {
            opacity: 0;
            position: absolute; /* V1.14: 动画时脱离布局 */
            z-index: 30;
            transition: all 0.4s ease-out;
        }

        /* 卡牌奖励 UI */
        #card-reward-options {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 20px; 
        }
        .reward-card {
            transition: all 0.2s ease-out;
        }
        .reward-card:hover {
            transform: scale(1.1) translateY(-16px) !important; 
            z-index: 20 !important;
            border-color: var(--color-yellow);
        }
        .reward-card:nth-child(1) { transform: rotate(-6deg); z-index: 8; margin-left: -10px; } 
        .reward-card:nth-child(2) { transform: scale(1.05); z-index: 10; }
        .reward-card:nth-child(3) { transform: rotate(6deg); z-index: 9; margin-left: -10px; } 

        /* 敌人 */
        .enemy-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s ease-in-out;
        }
        .enemy-container.targeted {
            transform: scale(1.05);
        }
        .enemy-sprite {
            font-size: 6rem; /* Emoji as sprite */
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        /* 玩家 */
        .player-container {
            transition: transform 0.1s ease-in-out;
            position: relative; /* 为状态图标定位 */
        }
        .player-container.targeted {
            transform: scale(1.05);
        }

        /* 状态条 (HP) */
        .hp-bar-bg {
            background-color: #4b5563;
            border-radius: 99px;
            overflow: hidden;
        }
        .hp-bar-fg {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #ef4444);
            transition: width 0.3s ease;
        }

        /* 敌人状态图标 */
        .enemy-container .status-icon-container {
            position: absolute;
            left: auto;
            right: -10px;
            bottom: 20px;
            display: flex;
            gap: 4px;
        }
        /* V1.13: 玩家状态图标 (移出 player-container) */
        #player-status-area {
            min-height: 38px; /* 留出空间 */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 4px 0;
            background-color: rgba(0,0,0,0.2);
            border-top: 1px solid var(--color-border);
        }
        
        .status-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 0.9rem; 
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(0,0,0,0.5);
            color: white;
            text-shadow: 0 0 3px black;
            cursor: pointer; 
            transition: transform 0.1s ease;
        }
        .status-icon:active { 
            transform: scale(1.15);
        }
        .status-icon.status-orange { background-color: var(--color-orange); }
        .status-icon.status-gray { background-color: var(--color-gray); }
        .status-icon.status-red { background-color: var(--color-red); }

        /* 按钮样式 */
        .btn {
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-align: center;
            cursor: pointer;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: var(--color-accent);
            color: var(--color-bg);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #67e8f9;
        }
        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-border);
        }
        .btn-yellow {
            background: var(--color-yellow);
            color: var(--color-bg);
        }
        .btn-yellow:hover:not(:disabled) {
            background-color: #facc15;
        }
        
        /* 伤害/格挡 浮动文字 */
        .damage-float, .block-float {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 1;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .damage-float { color: var(--color-red); }
        .damage-float.vulnerable {
            color: var(--color-orange);
            font-size: 1.8rem;
            transform: scale(1.2);
        }
        .block-float { color: var(--color-blue); }
        
        @keyframes floatUp {
            from { transform: translateY(0) scale(1); opacity: 1; }
            to { transform: translateY(-60px) scale(1.2); opacity: 0; }
        }
        
        /* 动画 */
        .anim-shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translateX(-4px); }
            20%, 80% { transform: translateX(4px); }
            30%, 50%, 70% { transform: translateX(-4px); }
            40%, 60% { transform: translateX(4px); }
        }
        .anim-lunge {
            animation: lunge 0.5s ease-in-out;
        }
        @keyframes lunge {
            0% { transform: translateY(0); }
            50% { transform: translateY(30px) scale(1.1); }
            100% { transform: translateY(0); }
        }
        .anim-block-shield {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 4rem;
            opacity: 0;
            animation: block-pop 0.6s ease-out;
            transform-origin: center;
        }
        @keyframes block-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; }
        }
        .anim-pulse {
            animation: pulse 0.6s ease-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: var(--color-yellow); }
            100% { transform: scale(1); }
        }
        .anim-projectile {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            z-index: 45;
            transition: all 0.5s cubic-bezier(0.5, -0.5, 0.5, 1.5); /* S型曲线 */
        }
        
        #enemy-intent-0 {
            cursor: help; /* 提示可以点击 */
        }

        /* 路径节点 */
        .path-node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--color-text-dim);
            flex-shrink: 0;
        }
        .path-node.current {
            border-color: var(--color-accent);
            color: var(--color-accent);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .path-node.cleared {
            background-color: var(--color-border);
            opacity: 0.5;
        }
        
        /* 锻造界面卡牌容器 */
        #smith-deck-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }
        #smith-deck-container .card {
            cursor: pointer;
        }
        #smith-deck-container .card:not(.can-upgrade) {
            opacity: 0.4;
            cursor: not-allowed;
        }
        #smith-deck-container .card.can-upgrade:hover {
            transform: scale(1.05);
            border-color: var(--color-green);
        }
        
        /* Tooltip 提示框 */
        #tooltip {
            position: absolute; 
            z-index: 50;
            padding: 12px;
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            max-width: 250px;
            width: max-content; 
            text-align: center;
            pointer-events: none; 
            opacity: 0; 
            transition: opacity 0.1s ease;
        }
        #tooltip.visible {
            opacity: 1; 
        }
        #tooltip-title {
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 4px;
        }
        #tooltip-desc {
            font-size: 0.875rem;
            color: var(--color-text-dim);
        }
        
    </style>
</head>
<body>
    <div id="game-container" class="game-container bg-gray-900">
        
        <div id="animation-layer"></div>

        <!-- 1. 主菜单屏幕 -->
        <div id="main-menu-screen" class="screen active p-6 justify-between">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-white">深径：余烬</h1>
                <p class="text-lg text-gray-400 mt-2">The Deep Path: Embers</p>
            </div>
            
            <div class="space-y-4">
                <button id="continue-run-btn" class="btn btn-primary w-full text-lg hidden">继续探索</button>
                <button id="start-run-btn" class="btn btn-primary w-full text-lg">开始探索</button>
                <button id="upgrades-menu-btn" class="btn btn-secondary w-full text-lg">永久升级</button>
            </div>
            
            <div class="text-center text-gray-500 text-sm">
                <p>最高层数: <span id="high-score-display">0</span></p>
            </div>
        </div>

        <!-- 2. 升级屏幕 -->
        <div id="upgrade-screen" class="screen p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold text-white">永久升级</h2>
                <button id="upgrade-back-btn" class="btn btn-secondary">返回</button>
            </div>
            
            <div class="text-center p-4 bg-gray-800 rounded-lg">
                <p class="text-gray-400">可用余烬</p>
                <p id="currency-display" class="text-3xl font-bold text-yellow-400">0 🔥</p>
            </div>
            
            <!-- 升级选项 -->
            <div id="upgrade-options-container" class="space-y-3 flex-grow overflow-y-auto">
                <!-- 升级项将由JS动态填充 -->
            </div>
        </div>

        <!-- 3. 游戏主屏幕 -->
        <div id="game-screen" class="screen">
            <!-- 路径显示 -->
            <div id="path-display" class="w-full p-2 flex justify-center space-x-1 bg-gray-900/80 backdrop-blur-sm border-b border-gray-700 overflow-x-auto">
                <!-- JS动态填充路径节点 -->
            </div>
            
            <!-- 敌人区域 -->
            <div id="enemy-area" class="flex-grow flex flex-col justify-center items-center space-y-2 p-4">
                <div id="enemy-container-0" class="enemy-container">
                    <div id="enemy-intent-0" class="p-1 px-3 bg-gray-700 rounded-full text-lg font-semibold flex items-center space-x-1.5">
                        <!-- ⚔️ 5 -->
                    </div>
                    <div id="enemy-sprite-0" class="enemy-sprite">😈</div>
                    <div id="enemy-hp-bar-0" class="w-2/3 hp-bar-bg h-4">
                        <div class="hp-bar-fg"></div>
                    </div>
                    <div id="enemy-hp-text-0" class="text-sm">15 / 15</div>
                    <div id="enemy-block-text-0" class="absolute -right-4 top-1/2 text-xl font-bold text-blue-400 bg-gray-800 p-1 px-2 rounded-full hidden">
                        🛡️ 0
                    </div>
                    <!-- 敌人状态图标 -->
                    <div id="enemy-status-icons-0" class="status-icon-container"></div>
                </div>
            </div>
            
            <!-- 玩家区域 -->
            <div id="player-area" class="p-4 border-t border-gray-700 bg-gray-800">
                <div id="player-container" class="player-container flex items-center justify-between">
                    <!-- 玩家状态 -->
                    <div class="space-y-2 w-2/3">
                        <div id="player-hp-bar" class="w-full hp-bar-bg h-5">
                            <div class="hp-bar-fg"></div>
                        </div>
                        <div class="flex justify-between text-sm">
                            <div id="player-hp-text" class="font-bold">50 / 50</div>
                            <div id="player-block-text" class="font-bold text-blue-400">🛡️ 0</div>
                        </div>
                    </div>
                    <!-- 能量 -->
                    <div class="flex flex-col items-center">
                        <div id="player-energy-text" class="text-5xl font-bold text-accent">3/3</div>
                        <div class="text-xs text-gray-400">能量 ⚡</div>
                    </div>
                </div>
            </div>
            
            <!-- V1.13: 玩家状态图标区 (新布局) -->
            <div id="player-status-area">
                <!-- JS动态填充 -->
            </div>

            <!-- V1.14: 手牌区域 (CSS 重构) -->
            <div id="hand-area">
                <!-- 卡牌由JS动态填充 -->
            </div>
            
            <!-- 底部操作栏 -->
            <div class="p-3 bg-gray-800 border-t border-gray-700 flex justify-between items-center">
                <div class="text-center relative">
                    <div id="deck-count" class="font-bold text-lg">10</div>
                    <div class="text-xs text-gray-400">牌堆</div>
                </div>
                <button id="end-turn-btn" class="btn btn-primary text-lg px-8 py-3">结束回合</button>
                <div class="text-center relative">
                    <div id="discard-count" class="font-bold text-lg">0</div>
                    <div class="text-xs text-gray-400">弃牌堆</div>
                </div>
            </div>
        </div>
        
        <!-- 4. 奖励屏幕 -->
        <div id="reward-screen" class="screen p-6 justify-center space-y-6">
            <div class="text-center">
                <h2 class="text-3xl font-bold text-white">深径的回响</h2>
                <p class="text-lg text-yellow-400">获得 <span id="reward-currency">0</span> 🔥</p>
            </div>
            
            <div id="card-reward-options" class="flex-grow">
                <!-- 3张卡牌选项(扇形)由JS填充 -->
            </div>
            
            <div class="flex space-x-4 w-full">
                <button id="skip-reward-btn" class="btn btn-secondary w-1/2">跳过</button>
                <button id="reroll-reward-btn" class="btn btn-yellow w-1/2 hidden">重抽 (1)</button>
            </div>
        </div>

        <!-- 5. 事件屏幕 -->
        <div id="event-screen" class="screen p-6 justify-center items-center space-y-6 text-center">
            <h2 id="event-title" class="text-3xl font-bold text-white">遭遇事件</h2>
            <p id="event-description" class="text-lg text-gray-300">一个古老的篝火在摇曳。</p>
            <div id="event-options" class="w-full space-y-3">
                <!-- 事件选项由JS填充 -->
            </div>
        </div>

        <!-- 6. 游戏结束屏幕 -->
        <div id="game-over-screen" class="screen p-6 justify-center items-center text-center space-y-6">
            <h2 id="game-over-title" class="text-4xl font-bold text-red-500">你倒下了</h2>
            <div class="text-lg space-y-2">
                <p>你深入到了第 <span id="final-floor" class="font-bold text-xl text-white">0</span> 层</p>
                <p>你收集了 <span id="final-currency" class="font-bold text-xl text-yellow-400">0</span> 🔥 余烬</p>
            </div>
            <button id="game-over-back-btn" class="btn btn-primary w-full text-lg">返回主菜单</button>
        </div>
        
        <!-- 7. 锻造屏幕 (模态框) -->
        <div id="smith-screen" class="screen modal-screen p-4 justify-center items-center">
            <div class="modal-content w-full max-w-sm h-3/4 flex flex-col rounded-lg overflow-hidden">
                <h2 class="text-2xl font-bold text-white text-center p-4">选择一张卡牌进行锻造</h2>
                <div id="smith-deck-container" class="flex-grow">
                    <!-- 卡牌列表由JS填充 -->
                </div>
                <div class="p-4 border-t border-gray-700">
                    <button id="smith-back-btn" class="btn btn-secondary w-full">取消</button>
                </div>
            </div>
        </div>

    </div>

    <!-- V1.13: Tooltip 提示框 (HTML) -->
    <div id="tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-desc"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 全局状态和DOM引用 ---
            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);
            
            const PROFILE_KEY = 'deepPathEmbersProfile';
            const RUN_KEY = 'deepPathEmbersRun';

            let playerProfile = {}; // 局外成长
            let runState = {}; // 当前局内状态
            let cardDefinitions = {}; // 卡牌定义
            let enemyDefinitions = {}; // 敌人定义
            let pathDefinition = []; // 路径定义
            let upgradeDefinitions = {}; // 升级定义
            let statusDefinitions = {}; // 状态定义
            let intentDefinitions = {}; // V1.13: 意图定义
            
            const GAME_STATES = {
                MAIN_MENU: 'MAIN_MENU',
                UPGRADES: 'UPGRADES',
                GAME_OVER: 'GAME_OVER',
                EVENT: 'EVENT',
                REWARD: 'REWARD',
                SMITHING: 'SMITHING',
                // Combat Sub-states
                PLAYER_TURN: 'PLAYER_TURN', // 等待玩家输入
                PROCESSING_LOGIC: 'PROCESSING_LOGIC', // 任何卡牌/回合逻辑结算中
                COMBAT_OVER: 'COMBAT_OVER', // 战斗胜利，等待奖励
            };

            const D = { // DOM 引用
                gameContainer: $('#game-container'), 
                animationLayer: $('#animation-layer'), 
                screens: {
                    mainMenu: $('#main-menu-screen'),
                    upgrades: $('#upgrade-screen'),
                    game: $('#game-screen'),
                    rewards: $('#reward-screen'),
                    event: $('#event-screen'),
                    gameOver: $('#game-over-screen'),
                    smith: $('#smith-screen'), 
                },
                mainMenu: {
                    continueBtn: $('#continue-run-btn'),
                    startBtn: $('#start-run-btn'),
                    upgradesBtn: $('#upgrades-menu-btn'),
                    highScore: $('#high-score-display'),
                },
                upgrades: {
                    backBtn: $('#upgrade-back-btn'),
                    currency: $('#currency-display'),
                    optionsContainer: $('#upgrade-options-container'),
                },
                game: {
                    pathDisplay: $('#path-display'),
                    enemyArea: $('#enemy-area'),
                    playerArea: $('#player-area'),
                    handArea: $('#hand-area'),
                    endTurnBtn: $('#end-turn-btn'),
                    playerHPBar: $('#player-hp-bar .hp-bar-fg'),
                    playerHPText: $('#player-hp-text'),
                    playerBlockText: $('#player-block-text'),
                    playerEnergyText: $('#player-energy-text'),
                    playerContainer: $('#player-container'),
                    playerStatusIcons: $('#player-status-area'), 
                    deckCount: $('#deck-count'),
                    discardCount: $('#discard-count'),
                },
                rewards: {
                    options: $('#card-reward-options'),
                    skipBtn: $('#skip-reward-btn'),
                    rerollBtn: $('#reroll-reward-btn'),
                    currency: $('#reward-currency'),
                },
                event: {
                    title: $('#event-title'),
                    description: $('#event-description'),
                    options: $('#event-options'),
                },
                gameOver: {
                    screen: $('#game-over-screen'),
                    title: $('#game-over-title'),
                    backBtn: $('#game-over-back-btn'),
                    finalFloor: $('#final-floor'),
                    finalCurrency: $('#final-currency'),
                },
                smith: { 
                    container: $('#smith-deck-container'),
                    backBtn: $('#smith-back-btn'),
                },
                tooltip: { 
                    el: $('#tooltip'),
                    title: $('#tooltip-title'),
                    desc: $('#tooltip-desc'),
                }
            };

            // --- 游戏数据定义 ---

            function defineStatus() {
                statusDefinitions = {
                    'vulnerable': {
                        name: '易伤',
                        icon: '🛡️',
                        desc: '受到的 <strong>攻击</strong> 伤害 +50%。',
                        color: 'orange' 
                    },
                    'weak': {
                        name: '虚弱',
                        icon: '⚔️',
                        desc: '造成的 <strong>攻击</strong> 伤害 -50%。',
                        color: 'gray'
                    },
                    'strength': {
                        name: '力量',
                        icon: '💪',
                        desc: '增加 <strong>攻击</strong> 造成的伤害。',
                        color: 'red'
                    },
                    'exhaust': { 
                        name: '消耗',
                        icon: '🔥',
                        desc: '此卡牌使用后，在本场战斗中被移除牌组（不会进入弃牌堆）。'
                    },
                    'curse': { 
                        name: '诅咒',
                        icon: '🟣',
                        desc: '一张干扰你牌库的卡牌。'
                    }
                };
            }
            
            function defineIntents() {
                intentDefinitions = {
                    'attack': {
                        name: '攻击',
                        desc: (val) => `敌人将造成 <strong>${val}</strong> 点伤害。`
                    },
                    'attack_multi': {
                        name: '多段攻击',
                        desc: (val, count) => `敌人将造成 <strong>${val}</strong> 点伤害，共 <strong>${count}</strong> 次。`
                    },
                    'defend': {
                        name: '防御',
                        desc: (val) => `敌人将获得 <strong>${val}</strong> 点格挡。`
                    },
                    'buff': {
                        name: '强化 (Buff)',
                        desc: (val) => `敌人将获得 <strong>${val}</strong> 层 <strong>力量</strong>。`
                    },
                    'debuff_vulnerable': {
                        name: '减益 (Debuff)',
                        desc: (val) => `敌人将对你施加 <strong>${val}</strong> 回合 <strong>易伤</strong>。`
                    },
                    'debuff_weak': {
                        name: '减益 (Debuff)',
                        desc: (val) => `敌人将对你施加 <strong>${val}</strong> 回合 <strong>虚弱</strong>。`
                    },
                    'pollute': {
                        name: '污染',
                        desc: (val) => `敌人将 <strong>${val}</strong> 张 <strong>黏液</strong> 塞入你的弃牌堆。`
                    }
                };
            }
            
            function defineCards() {
                cardDefinitions = {
                    // --- 初始卡牌 ---
                    'strike': {
                        id: 'strike', name: '打击', cost: 1, type: 'attack',
                        desc: '造成 6 点伤害。',
                        upgradesTo: 'strike_plus',
                        effect: (caster, target) => dealDamage(target, 6, caster),
                    },
                    'strike_plus': {
                        id: 'strike_plus', name: '打击+', cost: 1, type: 'attack',
                        desc: '造成 9 点伤害。',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 9, caster),
                    },
                    'defend': {
                        id: 'defend', name: '防御', cost: 1, type: 'skill',
                        desc: '获得 5 点格挡。',
                        target: 'self',
                        upgradesTo: 'defend_plus',
                        effect: (caster) => addBlock(caster, 5),
                    },
                    'defend_plus': {
                        id: 'defend_plus', name: '防御+', cost: 1, type: 'skill',
                        desc: '获得 8 点格挡。',
                        target: 'self',
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 8),
                    },
                    
                    // --- 普通卡牌 ---
                    'heavy_strike': {
                        id: 'heavy_strike', name: '重击', cost: 2, type: 'attack',
                        desc: '造成 12 点伤害。',
                        upgradesTo: 'heavy_strike_plus',
                        effect: (caster, target) => dealDamage(target, 12, caster),
                    },
                    'heavy_strike_plus': {
                        id: 'heavy_strike_plus', name: '重击+', cost: 2, type: 'attack',
                        desc: '造成 16 点伤害。',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 16, caster),
                    },
                    'double_hit': {
                        id: 'double_hit', name: '二连击', cost: 1, type: 'attack',
                        desc: '造成 4 点伤害，2次。',
                        upgradesTo: 'double_hit_plus',
                        effect: (caster, target) => {
                            dealDamage(target, 4, caster, 0); // V1.14: 延迟
                            dealDamage(target, 4, caster, 150);
                        },
                    },
                    'double_hit_plus': {
                        id: 'double_hit_plus', name: '二连击+', cost: 1, type: 'attack',
                        desc: '造成 6 点伤害，2次。',
                        upgraded: true,
                        effect: (caster, target) => {
                            dealDamage(target, 6, caster, 0);
                            dealDamage(target, 6, caster, 150);
                        },
                    },
                    'iron_wall': {
                        id: 'iron_wall', name: '铁壁', cost: 2, type: 'skill',
                        desc: '获得 10 点格挡。',
                        target: 'self',
                        upgradesTo: 'iron_wall_plus',
                        effect: (caster) => addBlock(caster, 10),
                    },
                    'iron_wall_plus': {
                        id: 'iron_wall_plus', name: '铁壁+', cost: 2, type: 'skill',
                        desc: '获得 14 点格挡。',
                        target: 'self',
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 14),
                    },
                    'quick_slash': {
                        id: 'quick_slash', name: '快斩', cost: 0, type: 'attack',
                        desc: '造成 3 点伤害。',
                        upgradesTo: 'quick_slash_plus',
                        effect: (caster, target) => dealDamage(target, 3, caster),
                    },
                    'quick_slash_plus': {
                        id: 'quick_slash_plus', name: '快斩+', cost: 0, type: 'attack',
                        desc: '造成 5 点伤害。',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 5, caster),
                    },
                    'vampiric_touch': {
                        id: 'vampiric_touch', name: '吸血', cost: 1, type: 'attack',
                        desc: '造成 5 点伤害。回复 2 点生命。',
                        upgradesTo: 'vampiric_touch_plus',
                        effect: (caster, target) => { 
                            dealDamage(target, 5, caster); 
                            setTimeout(() => healDamage(caster, 2), 200); // 伤害后回血
                        },
                    },
                    'vampiric_touch_plus': {
                        id: 'vampiric_touch_plus', name: '吸血+', cost: 1, type: 'attack',
                        desc: '造成 7 点伤害。回复 3 点生命。',
                        upgraded: true,
                        effect: (caster, target) => { 
                            dealDamage(target, 7, caster);
                            setTimeout(() => healDamage(caster, 3), 200);
                        },
                    },
                    'battle_focus': {
                        id: 'battle_focus', name: '专注', cost: 1, type: 'skill',
                        desc: '抽 2 张牌。',
                        target: 'self',
                        upgradesTo: 'battle_focus_plus',
                        effect: (caster, target, card) => drawCards(2, card),
                    },
                    'battle_focus_plus': {
                        id: 'battle_focus_plus', name: '专注+', cost: 1, type: 'skill',
                        desc: '抽 3 张牌。',
                        target: 'self',
                        upgraded: true,
                        effect: (caster, target, card) => drawCards(3, card),
                    },
                    'break': {
                        id: 'break', name: '破绽', cost: 1, type: 'skill',
                        desc: '施加 2 层<k>易伤</k>。',
                        target: 'enemy', 
                        upgradesTo: 'break_plus',
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 2, caster),
                    },
                    'break_plus': {
                        id: 'break_plus', name: '破绽+', cost: 1, type: 'skill',
                        desc: '施加 3 层<k>易伤</k>。',
                        target: 'enemy',
                        upgraded: true,
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 3, caster),
                    },
                    'demoralize': {
                        id: 'demoralize', name: '挫志', cost: 1, type: 'skill',
                        desc: '施加 1 层<k>虚弱</k>。',
                        target: 'enemy',
                        upgradesTo: 'demoralize_plus',
                        effect: (caster, target) => applyStatus(target, 'weak', 1, caster),
                    },
                    'demoralize_plus': {
                        id: 'demoralize_plus', name: '挫志+', cost: 1, type: 'skill',
                        desc: '施加 2 层<k>虚弱</k>。',
                        target: 'enemy',
                        upgraded: true,
                        effect: (caster, target) => applyStatus(target, 'weak', 2, caster),
                    },
                    'bulwark': {
                        id: 'bulwark', name: '壁垒', cost: 1, type: 'attack',
                        desc: '造成 7 点伤害。若你有格挡，抽 1 张牌。',
                        upgradesTo: 'bulwark_plus',
                        effect: (caster, target, card) => {
                            dealDamage(target, 7, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200); // 伤害后抽卡
                            }
                        },
                    },
                    'bulwark_plus': {
                        id: 'bulwark_plus', name: '壁垒+', cost: 1, type: 'attack',
                        desc: '造成 10 点伤害。若你有格挡，抽 1 张牌。',
                        upgraded: true,
                        effect: (caster, target, card) => {
                            dealDamage(target, 10, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200);
                            }
                        },
                    },
                    'energy_burst': {
                        id: 'energy_burst', name: '能量爆发', cost: 0, type: 'skill',
                        desc: '获得 2 点能量 ⚡。',
                        target: 'self',
                        upgradesTo: 'energy_burst_plus',
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 2;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },
                    'energy_burst_plus': {
                        id: 'energy_burst_plus', name: '能量爆发+', cost: 0, type: 'skill',
                        desc: '获得 3 点能量 ⚡。',
                        target: 'self',
                        upgraded: true,
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 3;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },
                    'slime_curse': {
                        id: 'slime_curse', name: '黏液', cost: 0, type: 'curse',
                        desc: '无用。',
                        target: 'self',
                        exhaust: true,
                        effect: () => {}, 
                    }
                };
            }
            
            function defineEnemies() {
                enemyDefinitions = {
                    'goblin': {
                        name: '哥布林', hp: 20, sprite: '👺', currency: 3,
                        moves: [
                            { type: 'attack', val: 6, intent: '⚔️ 6', intentKey: 'attack' },
                            { type: 'attack', val: 8, intent: '⚔️ 8', intentKey: 'attack' },
                        ]
                    },
                    'slime': {
                        name: '史莱姆', hp: 15, sprite: '🦠', currency: 2,
                        moves: [
                            { type: 'attack', val: 5, intent: '⚔️ 5', intentKey: 'attack' },
                            { type: 'defend', val: 3, intent: '🛡️ 3', intentKey: 'defend' }, 
                            { type: 'pollute', val: 1, intent: '🤮 1', intentKey: 'pollute' }, 
                        ]
                    },
                    'orc': {
                        name: '兽人', hp: 40, sprite: '👹', currency: 8,
                        moves: [
                            { type: 'attack', val: 10, intent: '⚔️ 10', intentKey: 'attack' },
                            { type: 'defend', val: 8, intent: '🛡️ 8', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 2, intent: '💪+2', intentKey: 'buff' }, 
                        ]
                    },
                    'shadow': {
                        name: '暗影', hp: 30, sprite: '👻', currency: 7,
                        moves: [
                            { type: 'attack', val: 7, intent: '⚔️ 7', intentKey: 'attack' },
                            { type: 'attack', val: 7, intent: '⚔️ 7', intentKey: 'attack' },
                            { type: 'debuff', status: 'weak', val: 1, intent: '😵‍💫 1', intentKey: 'debuff_weak' }, 
                        ]
                    },
                    'guardian': {
                        name: '守卫', hp: 60, sprite: '🗿', currency: 15,
                        moves: [
                            { type: 'attack', val: 12, intent: '⚔️ 12', intentKey: 'attack' },
                            { type: 'debuff', status: 'vulnerable', val: 1, intent: '😵 1', intentKey: 'debuff_vulnerable' }, 
                            { type: 'defend', val: 15, intent: '🛡️ 15', intentKey: 'defend' },
                        ]
                    },
                    'golem': {
                        name: '魔像', hp: 120, sprite: '🤖', currency: 50,
                        moves: [
                            { type: 'attack', val: 15, intent: '⚔️ 15', intentKey: 'attack' },
                            { type: 'attack_multi', val: 8, count: 2, intent: '⚔️ 8 (2次)', intentKey: 'attack_multi' },
                            { type: 'defend', val: 20, intent: '🛡️ 20', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 3, intent: '💪+3', intentKey: 'buff' }, 
                            { type: 'pollute', val: 2, intent: '🤮 2', intentKey: 'pollute' }, 
                        ],
                        onTurn: (enemy, onEndCallback) => { 
                            const move = enemy.nextMove;
                            if (move.intentKey === 'attack_multi') { 
                                playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                    takeDamage(runState.player, move.val, enemy, 0); // 第一次攻击
                                    setTimeout(() => {
                                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                            takeDamage(runState.player, move.val, enemy, 0); // 第二次攻击
                                            onEndCallback(); // 两次攻击后结束
                                        });
                                    }, 300); // 两次攻击的间隔
                                });
                            } else {
                                executeDefaultEnemyMove(enemy, onEndCallback);
                            }
                        }
                    },
                }
            }
            
            function definePath() {
                pathDefinition = [
                    { type: 'M', sprite: '👺', enemies: ['goblin', 'slime'] },
                    { type: 'M', sprite: '👺', enemies: ['goblin', 'slime'] },
                    { type: 'M', sprite: '👺', enemies: ['goblin', 'slime'] },
                    { type: 'R', sprite: '🔥', event: 'rest' },
                    { type: 'M', sprite: '👹', enemies: ['orc', 'shadow'] },
                    { type: 'M', sprite: '👹', enemies: ['orc', 'shadow'] },
                    { type: 'E', sprite: '🗿', enemies: ['guardian'] },
                    { type: 'R', sprite: '🔥', event: 'rest' },
                    { type: 'M', sprite: '👹', enemies: ['orc', 'shadow', 'guardian'] },
                    { type: 'B', sprite: '🤖', enemies: ['golem'] },
                ];
            }
            
            function defineUpgrades() {
                upgradeDefinitions = {
                    'max_hp': {
                        name: '强化体质',
                        desc: '最大生命值 +5',
                        baseCost: 50,
                        costIncrease: 25,
                        maxLevel: 10,
                        apply: (profile) => profile.baseHp += 5,
                    },
                    'start_energy': {
                        name: '活力源泉',
                        desc: '初始能量 +1',
                        baseCost: 300,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.baseEnergy += 1,
                    },
                    'start_heal': {
                        name: '初始回复',
                        desc: '开始时回复 10 点生命',
                        baseCost: 100,
                        costIncrease: 50,
                        maxLevel: 3,
                        apply: (profile) => profile.startHeal += 10,
                    },
                    'greed': { 
                        name: '贪婪',
                        desc: '战斗胜利时额外获得 2% 余烬',
                        baseCost: 80,
                        costIncrease: 40,
                        maxLevel: 10,
                        apply: (profile) => profile.greedBonus += 0.02,
                    },
                    'smith_chance': { 
                        name: '工匠精神',
                        desc: '锻造时有 5% 几率不消耗篝火',
                        baseCost: 150,
                        costIncrease: 75,
                        maxLevel: 5,
                        apply: (profile) => profile.smithChance += 0.05,
                    },
                    'reroll_charges': { 
                        name: '命运之手',
                        desc: '卡牌奖励界面获得 1 次重抽机会',
                        baseCost: 250,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.rerollCharges += 1,
                    },
                };
            }

            // --- 局外成长 (Profile) & 存档 (Run) ---

            function loadPlayerProfile() {
                const profile = localStorage.getItem(PROFILE_KEY);
                if (profile) {
                    playerProfile = JSON.parse(profile);
                    // 确保所有升级属性都存在
                    if (!playerProfile.upgrades.start_heal) playerProfile.upgrades.start_heal = 0;
                    if (!playerProfile.startHeal) playerProfile.startHeal = 0;
                    if (!playerProfile.upgrades.greed) playerProfile.upgrades.greed = 0;
                    if (!playerProfile.greedBonus) playerProfile.greedBonus = 0;
                    if (!playerProfile.upgrades.smith_chance) playerProfile.upgrades.smith_chance = 0;
                    if (!playerProfile.smithChance) playerProfile.smithChance = 0;
                    if (!playerProfile.upgrades.reroll_charges) playerProfile.upgrades.reroll_charges = 0;
                    if (!playerProfile.rerollCharges) playerProfile.rerollCharges = 0;
                } else {
                    playerProfile = {
                        totalCurrency: 0,
                        highScore: 0,
                        upgrades: { 
                            'max_hp': 0,
                            'start_energy': 0,
                            'start_heal': 0,
                            'greed': 0,
                            'smith_chance': 0,
                            'reroll_charges': 0,
                        },
                        baseHp: 50,
                        baseEnergy: 3,
                        startHeal: 0,
                        greedBonus: 0,
                        smithChance: 0,
                        rerollCharges: 0,
                    };
                    savePlayerProfile();
                }
                updateMainMenuUI();
            }

            function savePlayerProfile() {
                localStorage.setItem(PROFILE_KEY, JSON.stringify(playerProfile));
            }

            function saveRunState() {
                if (!runState || runState.gameState === GAME_STATES.MAIN_MENU || runState.gameState === GAME_STATES.GAME_OVER) {
                    return;
                }
                
                const savableState = { ...runState };
                if (savableState.enemy) {
                    const { dom, ...savableEnemy } = savableState.enemy;
                    savableState.enemy = savableEnemy;
                }
                localStorage.setItem(RUN_KEY, JSON.stringify(savableState));
            }

            function loadRunState() {
                const savedRun = localStorage.getItem(RUN_KEY);
                if (!savedRun) return;

                runState = JSON.parse(savedRun);

                // 重新 "附加" (Hydrate) DOM 引用
                if (runState.enemy) {
                    runState.enemy.dom = {
                        container: $(`#enemy-container-0`),
                        intent: $(`#enemy-intent-0`),
                        sprite: $(`#enemy-sprite-0`),
                        hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                        hpText: $(`#enemy-hp-text-0`),
                        blockText: $(`#enemy-block-text-0`),
                        statusIcons: $(`#enemy-status-icons-0`),
                    };
                }
                
                // 恢复游戏
                updatePathDisplay();
                updateAllUI();
                setGameState(runState.gameState); 
            }
            
            function updateMainMenuUI() {
                D.mainMenu.highScore.textContent = playerProfile.highScore;
            }
            
            function showUpgradeScreen() {
                D.upgrades.currency.textContent = `${playerProfile.totalCurrency} 🔥`;
                const container = D.upgrades.optionsContainer;
                container.innerHTML = '';
                
                for (const id in upgradeDefinitions) {
                    const def = upgradeDefinitions[id];
                    const level = playerProfile.upgrades[id] || 0;
                    const cost = def.baseCost + (def.costIncrease * level);
                    const canBuy = playerProfile.totalCurrency >= cost && level < def.maxLevel;

                    let buttonText;
                    if (level >= def.maxLevel) {
                        buttonText = '已达上限';
                    } else {
                        buttonText = `购买 (花费 ${cost} 🔥)`;
                    }

                    const el = document.createElement('div');
                    el.className = 'p-4 bg-gray-800 rounded-lg border border-gray-700';
                    el.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="text-lg font-bold text-white">${def.name} (Lv ${level}/${def.maxLevel})</h4>
                                <p class="text-sm text-gray-400">${def.desc}</p>
                            </div>
                            <button class="btn ${canBuy ? 'btn-primary' : 'btn-secondary opacity-50'}" data-upgrade-id="${id}" ${!canBuy ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    `;
                    container.appendChild(el);
                }
                
                container.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', (e) => buyUpgrade(e.target.dataset.upgradeId));
                });
                
                setGameState(GAME_STATES.UPGRADES);
            }

            function buyUpgrade(id) {
                const def = upgradeDefinitions[id];
                const level = playerProfile.upgrades[id] || 0;
                const cost = def.baseCost + (def.costIncrease * level);
                
                if (playerProfile.totalCurrency >= cost && level < def.maxLevel) {
                    playerProfile.totalCurrency -= cost;
                    playerProfile.upgrades[id] += 1;
                    def.apply(playerProfile); // 应用永久属性
                    
                    savePlayerProfile();
                    showUpgradeScreen(); // 刷新UI
                }
            }

            // --- 局内游戏 (Run) ---

            function startNewRun() {
                runState = {
                    player: {
                        maxHp: playerProfile.baseHp,
                        hp: Math.min(playerProfile.baseHp, playerProfile.baseHp + playerProfile.startHeal),
                        maxEnergy: playerProfile.baseEnergy,
                        energy: playerProfile.baseEnergy,
                        block: 0,
                        isPlayer: true,
                        status: { vulnerable: 0, weak: 0, strength: 0 }, 
                        greedBonus: playerProfile.greedBonus,
                        smithChance: playerProfile.smithChance,
                        rerollCharges: playerProfile.rerollCharges,
                    },
                    deck: createStartDeck(),
                    hand: [],
                    discard: [],
                    exhaustPile: [],
                    currentFloor: 0,
                    runCurrency: 0,
                    gameState: null,
                    selectedCardId: null,
                };
                
                updatePathDisplay();
                startNextEncounter();
            }
            
            function setGameState(newState) {
                if (runState.gameState === GAME_STATES.GAME_OVER && newState !== GAME_STATES.MAIN_MENU) {
                    return; 
                }
                
                runState.gameState = newState;
                
                Object.values(D.screens).forEach(screen => screen.classList.remove('active'));
                
                switch (newState) {
                    case GAME_STATES.MAIN_MENU:
                        D.screens.mainMenu.classList.add('active');
                        break;
                    case GAME_STATES.UPGRADES:
                        D.screens.upgrades.classList.add('active');
                        break;
                    case GAME_STATES.GAME_OVER:
                        D.screens.gameOver.classList.add('active');
                        break;
                    case GAME_STATES.EVENT:
                        D.screens.event.classList.add('active');
                        break;
                    case GAME_STATES.REWARD:
                        D.screens.rewards.classList.add('active');
                        break;
                    case GAME_STATES.SMITHING:
                        D.screens.smith.classList.add('active');
                        break;
                    case GAME_STATES.PLAYER_TURN:
                    case GAME_STATES.PROCESSING_LOGIC:
                    case GAME_STATES.COMBAT_OVER:
                        D.screens.game.classList.add('active');
                        break;
                }
                
                if (newState === GAME_STATES.PLAYER_TURN) {
                    D.game.endTurnBtn.disabled = false;
                    D.game.endTurnBtn.classList.add('btn-primary');
                    D.game.endTurnBtn.classList.remove('opacity-50');
                } else {
                    D.game.endTurnBtn.disabled = true;
                    D.game.endTurnBtn.classList.remove('btn-primary');
                    D.game.endTurnBtn.classList.add('opacity-50');
                }
                
                if (newState === GAME_STATES.REWARD) {
                    if (runState.player.rerollCharges > 0) {
                        D.rewards.rerollBtn.classList.remove('hidden');
                        D.rewards.rerollBtn.textContent = `重抽 (${runState.player.rerollCharges})`;
                        D.rewards.rerollBtn.disabled = false;
                    } else {
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                }
            }

            function createStartDeck() {
                let deck = [];
                for(let i=0; i<6; i++) deck.push(createCardInstance(cardDefinitions.strike));
                for(let i=0; i<4; i++) deck.push(createCardInstance(cardDefinitions.defend));
                return shuffle(deck);
            }
            
            function createCardInstance(cardDef) {
                return { ...cardDef, instanceId: Math.random().toString(36).substring(2, 9) };
            }

            function startNextEncounter() {
                const floorData = pathDefinition[runState.currentFloor];
                if (!floorData) {
                    gameOver(true); // 游戏胜利
                    return;
                }
                
                if (floorData.type === 'M' || floorData.type === 'E' || floorData.type === 'B') {
                    const enemyId = floorData.enemies[Math.floor(Math.random() * floorData.enemies.length)];
                    const enemyDef = enemyDefinitions[enemyId];
                    
                    runState.enemy = {
                        ...enemyDef,
                        hp: enemyDef.hp, maxHp: enemyDef.hp,
                        block: 0, nextMove: null, isPlayer: false,
                        status: { vulnerable: 0, weak: 0, strength: 0 }, 
                        dom: { 
                            container: $(`#enemy-container-0`),
                            intent: $(`#enemy-intent-0`),
                            sprite: $(`#enemy-sprite-0`),
                            hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                            hpText: $(`#enemy-hp-text-0`),
                            blockText: $(`#enemy-block-text-0`),
                            statusIcons: $(`#enemy-status-icons-0`),
                        }
                    };
                    startPlayerTurn();
                } else if (floorData.type === 'R') {
                    showEventScreen(floorData.event);
                }
            }
            
            function showEventScreen(eventId) {
                if (eventId === 'rest') {
                    D.event.title.textContent = '篝火';
                    D.event.description.textContent = '一个古老的篝火在摇曳。你感到一阵温暖。';
                    D.event.options.innerHTML = `
                        <button class="btn btn-primary w-full" data-choice="rest">休息 (回复 30% HP)</button>
                        <button class="btn btn-secondary w-full" data-choice="smith">锻造 (升级一张卡)</button>
                        <button class="btn btn-secondary w-full" data-choice="skip">离开</button>
                    `;
                    D.event.options.querySelector('[data-choice="rest"]').onclick = () => {
                        healDamage(runState.player, Math.floor(runState.player.maxHp * 0.3));
                        proceedToNextFloor();
                    };
                    D.event.options.querySelector('[data-choice="smith"]').onclick = () => {
                        showSmithScreen();
                    };
                     D.event.options.querySelector('[data-choice="skip"]').onclick = proceedToNextFloor;
                }
                setGameState(GAME_STATES.EVENT);
            }
            
            function showSmithScreen() {
                const container = D.smith.container;
                container.innerHTML = '';
                const allCards = [...runState.deck, ...runState.discard, ...runState.hand]
                                 .filter(c => c.type !== 'curse'); 
                
                allCards.forEach(card => {
                    const cardEl = createCardElement(card, card.instanceId);
                    const canUpgrade = !card.upgraded && card.upgradesTo;
                    
                    if (canUpgrade) {
                        cardEl.classList.add('can-upgrade');
                        cardEl.addEventListener('click', () => upgradeCard(card.instanceId));
                    }
                    container.appendChild(cardEl);
                });
                setGameState(GAME_STATES.SMITHING);
            }
            
            function upgradeCard(instanceId) {
                const locations = ['deck', 'discard', 'hand'];
                for (const loc of locations) {
                    const index = runState[loc].findIndex(c => c.instanceId === instanceId);
                    if (index !== -1) {
                        const oldCard = runState[loc][index];
                        if (oldCard.upgradesTo) {
                            const newCardDef = cardDefinitions[oldCard.upgradesTo];
                            runState[loc][index] = { ...newCardDef, instanceId: oldCard.instanceId };
                            
                            if (Math.random() < runState.player.smithChance) {
                                D.event.description.textContent = "你灵光一闪，锻造未消耗篝火！";
                                setGameState(GAME_STATES.EVENT);
                            } else {
                                proceedToNextFloor(); 
                            }
                            return; 
                        }
                    }
                }
            }
            
            function clearPlayerCombatStatus() {
                runState.player.block = 0;
                // V1.14: 修正，只清除会衰减的状态
                runState.player.status.vulnerable = 0;
                runState.player.status.weak = 0;
                // runState.player.status.strength = 0; // 力量是永久的
                
                updateEntityUI(runState.player);
            }
            
            function proceedToNextFloor() {
                // 【V1.13 BUG FIX】: 在进入下一层时清除玩家的战斗状态
                clearPlayerCombatStatus(); 
                
                runState.currentFloor++;
                updatePathDisplay();
                saveRunState(); // 保存进度
                startNextEncounter();
            }

            function startPlayerTurn() {
                setGameState(GAME_STATES.PROCESSING_LOGIC); // V1.14: 回合开始时锁定，防止抽卡时点击
                runState.player.energy = runState.player.maxEnergy;
                runState.player.block = 0; // 重置玩家格挡
                
                runState.selectedCardId = null;
                
                if (runState.enemy && runState.enemy.hp > 0) { 
                    runState.enemy.nextMove = runState.enemy.moves[Math.floor(Math.random() * runState.enemy.moves.length)];
                }
                
                updateAllUI(); // 先更新一次UI (显示敌人意图等)
                
                // V1.14: drawCards 现在有动画, 并在结束后设置玩家回合
                drawCards(5, null, () => {
                    setGameState(GAME_STATES.PLAYER_TURN); // <-- 轮到玩家，解锁输入
                }); 
            }

            function endPlayerTurn() {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); // <-- 锁定游戏
                saveRunState(); // 保存进度
                
                runState.selectedCardId = null;
                
                runState.discard = [...runState.discard, ...runState.hand];
                runState.hand = [];
                
                // 在玩家回合结束时结算玩家状态
                tickDownStatus(runState.player);
                
                updateHandUI(); // 清空手牌UI
                updateEntityUI(runState.player); // 更新UI以显示（可能）减少的状态
                
                setTimeout(() => enemyTurn(), 500); // 0.5秒后敌人行动
            }
            
            function enemyTurn() {
                const enemy = runState.enemy;
                let onEndCallback = null; 

                onEndCallback = () => {
                    updateAllUI(); // 确保动画后的UI是最终状态
                    
                    if (runState.player.hp <= 0) {
                        gameOver(false); // 玩家死亡
                    } else {
                        // 将状态结算和UI更新移到 setTimeout *内部*
                        setTimeout(() => {
                            if (enemy) {
                                tickDownStatus(enemy); // 在此结算敌人状态
                                updateEntityUI(enemy); // 更新敌人UI
                            }
                            startPlayerTurn(); // 然后开始玩家回合
                        }, 500); 
                    }
                };
                
                if (enemy) {
                    enemy.block = 0; // 在敌人行动 *之前* 清除他们上一回合的格挡
                    updateEntityUI(enemy); // 立即更新UI
                }
                
                if (enemy && enemy.hp > 0) { // 敌人必须活着才能行动
                    if (enemy.onTurn) { 
                        enemy.onTurn(enemy, onEndCallback); 
                    } else if (enemy.nextMove) {
                        executeDefaultEnemyMove(enemy, onEndCallback); 
                    } else {
                        onEndCallback(); // 敌人没动作 (e.g. 眩晕)
                    }
                } else {
                    onEndCallback(); // 敌人已死
                }
            }
            
            function executeDefaultEnemyMove(enemy, onEndCallback) {
                const move = enemy.nextMove;
                if (!move) {
                    onEndCallback();
                    return;
                }
                
                let animationDone = false;
                let logicDone = false;
                
                const checkEnd = () => {
                    if (animationDone && logicDone) onEndCallback();
                };
                
                // 1. 执行动画
                switch (move.type) {
                    case 'attack':
                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                            animationDone = true;
                            checkEnd();
                        });
                        break;
                    case 'defend':
                        addBlock(enemy, move.val); // addBlock 内部有动画
                        animationDone = true;
                        break;
                    case 'buff':
                    case 'debuff':
                    case 'pollute':
                        executeEnemyLogic(move, enemy, () => {
                            animationDone = true; // 动画在逻辑内部处理
                            checkEnd();
                        });
                        logicDone = true; // 逻辑和动画是一体的
                        return; // 提前返回
                    default:
                        animationDone = true;
                }
                
                // 2. 执行逻辑 (在短暂延迟后, 模拟攻击命中)
                setTimeout(() => {
                    executeEnemyLogic(move, enemy, () => {
                        logicDone = true;
                        checkEnd();
                    });
                }, 250); // 攻击动画中点
            }
            
            function executeEnemyLogic(move, enemy, onLogicEnd = () => {}) {
                switch (move.type) {
                    case 'attack':
                        takeDamage(runState.player, move.val, enemy);
                        onLogicEnd();
                        break;
                    case 'defend':
                        // addBlock 已经在 move 执行时调用了
                        onLogicEnd();
                        break;
                    case 'buff':
                        applyStatus(enemy, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'debuff':
                        applyStatus(runState.player, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'pollute':
                        addCardToDiscard(cardDefinitions.slime_curse, move.val, enemy, onLogicEnd);
                        break;
                    default:
                        onLogicEnd();
                }
            }

            // --- 卡牌逻辑 ---
            
            // V1.14: 重构抽卡动画
            function drawCards(amount, sourceCard = null, onAllCardsDrawn = () => {}) {
                let handRect = D.game.handArea.getBoundingClientRect();
                let deckRect = D.game.deckCount.getBoundingClientRect();
                let drawnCardsData = []; // 存储卡牌数据
                
                for (let i = 0; i < amount; i++) {
                    if (runState.deck.length === 0) {
                        if (runState.discard.length === 0) break; 
                        runState.deck = shuffle(runState.discard);
                        runState.discard = [];
                        updateDeckDiscardUI();
                    }
                    const card = runState.deck.pop();
                    runState.hand.push(card);
                    drawnCardsData.push(card);
                }
                
                updateDeckDiscardUI(); // 更新牌堆数量

                if (drawnCardsData.length === 0) {
                    onAllCardsDrawn();
                    return;
                }

                // V1.14: 播放动画
                drawnCardsData.forEach((card, index) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    cardEl.classList.add('drawing'); // 初始状态 (透明, 在牌堆)
                    
                    const startX = (deckRect.left + deckRect.width / 2) - (handRect.left + handRect.width / 2);
                    const startY = (deckRect.top + deckRect.height / 2) - (handRect.top + handRect.height / 2);
                    cardEl.style.transform = `translate(${startX}px, ${startY}px) scale(0.5)`;
                    
                    D.game.handArea.appendChild(cardEl); // V1.14: 直接添加到 handArea

                    // 延迟播放
                    setTimeout(() => {
                        cardEl.classList.remove('drawing'); // 移除初始状态
                        cardEl.style.transform = ``; // V1.14: 清除 transform, 让 CSS flexbox 接管
                        cardEl.style.position = 'relative'; 
                        
                        // 动画结束后，重新布局
                        if (index === drawnCardsData.length - 1) { // 仅最后一张卡
                            setTimeout(() => {
                                updateHandUI(); // V1.14: 重新渲染所有卡牌以获得正确的 flex 布局
                                onAllCardsDrawn(); // V1.14: 调用回调
                            }, 400); // 动画时长
                        }
                    }, (sourceCard ? 0 : index * 100) + 50); // 如果是卡牌效果抽卡，则立即播放
                });
            }
            
            function addCardToDiscard(cardDef, amount, source = null, onEndCallback = () => {}) {
                const targetEl = D.game.discardCount.parentElement; // 弃牌堆的DOM
                const sourceEl = source?.dom?.container || D.game.enemyArea;
                
                for(let i = 0; i < amount; i++) {
                    createAndFireProjectile(sourceEl, targetEl, '🟣', () => {
                        runState.discard.push(createCardInstance(cardDef));
                        updateDeckDiscardUI();
                        if (i === amount - 1) onEndCallback();
                    });
                }
            }
            
            function onCardClick(cardInstanceId) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                const card = runState.hand.find(c => c.instanceId === cardInstanceId);
                if (!card || runState.player.energy < card.cost) return;
                if (card.type === 'curse') return;

                if (card.target === 'self') {
                    playCard(card, runState.player);
                    return;
                }
                
                if (card.target === 'enemy') { 
                    if (runState.selectedCardId === cardInstanceId) {
                        runState.selectedCardId = null;
                        updateHandUI();
                        updateTargetHighlights(null);
                    } else {
                        runState.selectedCardId = cardInstanceId;
                        updateHandUI();
                        updateTargetHighlights('enemy_skill');
                    }
                     return;
                }
                
                if (card.type === 'attack') {
                    if (runState.selectedCardId === cardInstanceId) {
                        runState.selectedCardId = null;
                        updateHandUI();
                        updateTargetHighlights(null);
                    } else {
                        runState.selectedCardId = cardInstanceId;
                        updateHandUI();
                        updateTargetHighlights(card.type);
                    }
                }
            }
            
            function onEnemyClick(enemy) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
                
                const card = runState.hand.find(c => c.instanceId === runState.selectedCardId);
                if (!card) return;
                
                if (card.type === 'attack' || card.target === 'enemy') {
                    playCard(card, enemy);
                }
            }
            
            function onPlayerClick() {
                 if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
            }

            function playCard(card, target) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); // <-- 锁定游戏
                
                runState.player.energy -= card.cost;
                runState.hand = runState.hand.filter(c => c.instanceId !== card.instanceId);
                
                if (card.exhaust) {
                    runState.exhaustPile.push(card);
                } else {
                    runState.discard.push(card);
                }
                
                runState.selectedCardId = null;
                updateTargetHighlights(null);
                updateHandUI(); // 立即从手中移除卡牌

                card.effect(runState.player, target, card);
                
                // V1.14: 动画时间计算
                let animationTime = 200; // 默认
                if (card.type === 'attack') animationTime = 500;
                if (card.id.includes('double_hit')) animationTime = 700;
                if (card.id.includes('bulwark') && runState.player.block > 0) animationTime = 700; // 攻击+抽卡
                if (card.id.includes('battle_focus')) animationTime = 1000; // 抽卡
                
                setTimeout(() => {
                    updateAllUI(); // 更新UI以显示能量变化和卡牌效果
                    
                    if (runState.enemy.hp <= 0) {
                        setGameState(GAME_STATES.COMBAT_OVER);
                        enemyKilled();
                    } else if (runState.player.hp <= 0) {
                        gameOver(false);
                    } else {
                        updateHandUI(); // 刷新能量高亮
                        setGameState(GAME_STATES.PLAYER_TURN); // 战斗继续
                    }
                }, animationTime); 
            }
            
            function enemyKilled() {
                clearPlayerCombatStatus(); 
                
                const currencyGained = Math.floor(runState.enemy.currency * (1 + runState.player.greedBonus));
                runState.runCurrency += currencyGained;
                setTimeout(() => showRewardScreen(currencyGained), 1000); 
            }
            
            function showRewardScreen(currencyGained) {
                D.rewards.currency.textContent = `${currencyGained} 🔥`;
                generateRewardOptions();
                setGameState(GAME_STATES.REWARD);
            }
            
            function generateRewardOptions() {
                const optionsContainer = D.rewards.options;
                optionsContainer.innerHTML = '';
                
                const cardPool = [
                    'heavy_strike', 'double_hit', 'iron_wall', 'quick_slash', 
                    'vampiric_touch', 'battle_focus',
                    'break', 'demoralize', 'bulwark', 'energy_burst' 
                ];
                const options = shuffle(cardPool).slice(0, 3); 
                
                options.forEach(cardId => {
                    const cardDef = cardDefinitions[cardId];
                    const cardEl = createCardElement(cardDef);
                    cardEl.classList.add('reward-card'); 
                    cardEl.addEventListener('click', () => selectReward(cardDef));
                    optionsContainer.appendChild(cardEl);
                });
            }
            
            function selectReward(cardDef) {
                if (cardDef) { 
                    runState.deck.push(createCardInstance(cardDef)); 
                }
                proceedToNextFloor();
            }
            
            // --- 战斗数值 ---
            
            function applyStatus(target, status, duration, source, onEndCallback = () => {}) {
                const def = statusDefinitions[status];
                const sourceEl = source.isPlayer ? D.game.playerContainer : source.dom.container;
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                
                let iconHTML = '...';
                switch(status) {
                    case 'vulnerable': iconHTML = '🟠'; break;
                    case 'weak': iconHTML = '🔘'; break;
                    case 'strength': iconHTML = '🔴'; break;
                }
                
                createAndFireProjectile(sourceEl, targetEl, iconHTML, () => {
                    if (status === 'strength') {
                        target.status.strength = (target.status.strength || 0) + duration;
                    } else {
                        target.status[status] = (target.status[status] || 0) + duration;
                    }
                    updateEntityUI(target);
                    onEndCallback();
                });
            }

            function tickDownStatus(target) {
                if (target.status.vulnerable > 0) target.status.vulnerable--;
                if (target.status.weak > 0) target.status.weak--;
                // Strength (力量) 不会衰减
            }
            
            // V1.14: 增加 delay
            function dealDamage(target, amount, source, delay = 0) {
                setTimeout(() => {
                    let modifiedAmount = amount;
                    
                    if (source && source.status.strength > 0) {
                        modifiedAmount += source.status.strength;
                    }
                    
                    if (source && source.status.weak > 0) {
                        modifiedAmount = Math.floor(modifiedAmount * 0.5);
                    }
                    
                    let isVulnerable = target.status.vulnerable > 0;
                    if (isVulnerable) {
                        modifiedAmount = Math.floor(modifiedAmount * 1.5);
                    }

                    let damageDealt = modifiedAmount;
                    if (target.block > 0) {
                        if (target.block >= damageDealt) {
                            target.block -= damageDealt;
                            damageDealt = 0;
                        } else {
                            damageDealt -= target.block;
                            target.block = 0;
                        }
                    }
                    
                    target.hp -= damageDealt;
                    if (target.hp < 0) target.hp = 0; 
                    
                    if (damageDealt > 0) {
                        const floatType = isVulnerable ? 'damage vulnerable' : 'damage';
                        showFloatingText(`-${damageDealt}`, target.isPlayer ? D.game.playerContainer : target.dom.container, floatType);
                        playAnimation(target.isPlayer ? D.game.playerContainer : target.dom.sprite, 'anim-shake');
                    }
                    
                    updateEntityUI(target);
                }, delay);
            }
            
            function takeDamage(target, amount, source) {
                dealDamage(target, amount, source, 0);
            }
            
            function addBlock(target, amount) {
                target.block += amount;
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block');
                
                const animEl = document.createElement('div');
                animEl.className = 'anim-block-shield';
                animEl.innerHTML = '🛡️';
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                targetEl.appendChild(animEl);
                animEl.addEventListener('animationend', () => animEl.remove());
                
                updateEntityUI(target);
            }
            
            function healDamage(target, amount) {
                target.hp = Math.min(target.maxHp, target.hp + amount);
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block-float text-green-500'); // 绿色
                updateEntityUI(target);
            }
            
            function gameOver(isWin) {
                if (runState.gameState === GAME_STATES.GAME_OVER) return; 
                
                localStorage.removeItem(RUN_KEY); // 清除存档
                
                playerProfile.totalCurrency += runState.runCurrency;
                if (runState.currentFloor > playerProfile.highScore) {
                    playerProfile.highScore = runState.currentFloor;
                }
                savePlayerProfile();
                
                if (isWin) {
                    D.gameOver.title.textContent = '你胜利了！';
                    D.gameOver.title.classList.remove('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} 🔥`;
                } else {
                    D.gameOver.title.textContent = '你倒下了';
                    D.gameOver.title.classList.add('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} 🔥`;
                }
                setGameState(GAME_STATES.GAME_OVER);
            }

            // --- 渲染 / UI ---
            
            function updateAllUI() {
                if (!runState || !runState.player) return; 

                updateEntityUI(runState.player);
                D.game.playerEnergyText.textContent = `${runState.player.energy}/${runState.player.maxEnergy}`;
                
                if (runState.enemy) {
                    updateEntityUI(runState.enemy);
                    const e = runState.enemy;
                    e.dom.sprite.textContent = e.sprite;
                    if (e.hp > 0 && e.nextMove) {
                        e.dom.intent.innerHTML = `<span>${e.nextMove.intent}</span>`;
                        e.dom.intent.dataset.intentKey = e.nextMove.intentKey;
                        e.dom.intent.dataset.intentVal = e.nextMove.val || 0;
                        e.dom.intent.dataset.intentCount = e.nextMove.count || 0;
                        e.dom.intent.classList.remove('hidden');
                    } else {
                        e.dom.intent.classList.add('hidden');
                    }
                }
                
                updateDeckDiscardUI();
            }
            
            function updateEntityUI(entity) {
                if (!entity) return;

                let hpBar, hpText, blockText, statusIconContainer;
                
                if (entity.isPlayer) {
                    hpBar = D.game.playerHPBar;
                    hpText = D.game.playerHPText;
                    blockText = D.game.playerBlockText;
                    statusIconContainer = D.game.playerStatusIcons; 
                } else if (entity.dom) {
                    hpBar = entity.dom.hpBar;
                    hpText = entity.dom.hpText;
                    blockText = entity.dom.blockText;
                    statusIconContainer = entity.dom.statusIcons;
                } else {
                    return; 
                }
                
                // HP
                if (hpBar) {
                    hpBar.style.width = `${Math.max(0, (entity.hp / entity.maxHp) * 100)}%`;
                }
                if (hpText) {
                    hpText.textContent = `${entity.hp} / ${entity.maxHp}`;
                }
                
                // Block
                if (blockText) {
                    if (entity.block > 0) {
                        blockText.textContent = `🛡️ ${entity.block}`;
                        blockText.classList.remove('hidden');
                    } else {
                        blockText.classList.add('hidden');
                    }
                }
                
                // Status Icons
                if (statusIconContainer) {
                    statusIconContainer.innerHTML = ''; // 清空旧图标
                    for (const statusId in entity.status) {
                        const duration = entity.status[statusId];
                        if (duration > 0) { // 只渲染激活的状态
                            const def = statusDefinitions[statusId];
                            if (!def) continue; 

                            let durationText = duration;
                            if (statusId === 'strength') {
                                durationText = `+${duration}`; // 力量显示层数
                            }

                            const iconEl = document.createElement('div');
                            iconEl.className = `status-icon status-${def.color}`; 
                            iconEl.innerHTML = `<span>${durationText}</span>`; 
                            iconEl.dataset.statusId = statusId; // 用于 tooltip
                            
                            statusIconContainer.appendChild(iconEl);
                        }
                    }
                }
            }
            
            // V1.14: 重构手牌UI
            function updateHandUI() {
                const hand = runState.hand;
                const handArea = D.game.handArea;
                
                // 1. 清空 (V1.14: 简单粗暴, 保证清空动画残留)
                handArea.innerHTML = ''; 
                
                // 2. 重新渲染
                hand.forEach((card, index) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    
                    // 更新高亮
                    const isPlayable = runState.player.energy >= card.cost;
                    if (isPlayable) cardEl.classList.add('playable');
                    else cardEl.classList.add('unplayable');
                    
                    if (card.instanceId === runState.selectedCardId) {
                        cardEl.classList.add('selected');
                    }
                    
                    handArea.appendChild(cardEl);
                });
            }
            
            function createCardElement(cardDef, instanceId = null) {
                const el = document.createElement('div');
                el.className = 'card';
                if(instanceId) {
                    el.classList.add('hand-card');
                    el.id = `hand-card-${instanceId}`; 
                    el.dataset.instanceId = instanceId;
                }
                if(cardDef.upgraded) el.classList.add('upgraded');
                if(cardDef.exhaust) el.classList.add('exhaust');
                if(cardDef.type === 'curse') el.classList.add('curse');
                
                let typeText = '';
                let typeColor = '';
                switch(cardDef.type) {
                    case 'attack': typeText = '攻击'; typeColor = 'text-red-400'; break;
                    case 'skill': typeText = '技能'; typeColor = 'text-blue-400'; break;
                    case 'curse': typeText = '诅咒'; typeColor = 'text-purple-400'; break;
                }
                
                let descHTML = cardDef.desc;
                if (cardDef.exhaust) descHTML += " (<k>消耗</k>)";
                if (cardDef.type === 'curse') descHTML += " (<k>诅咒</k>)";
                
                descHTML = descHTML.replace(/<k>易伤<\/k>/g, '<span class="keyword" data-keyword="vulnerable">易伤</span>');
                descHTML = descHTML.replace(/<k>虚弱<\/k>/g, '<span class="keyword" data-keyword="weak">虚弱</span>');
                descHTML = descHTML.replace(/<k>消耗<\/k>/g, '<span class="keyword" data-keyword="exhaust">消耗</span>');
                descHTML = descHTML.replace(/<k>诅咒<\/k>/g, '<span class="keyword" data-keyword="curse">诅咒</span>');
                
                el.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="card-cost">${cardDef.cost}</div>
                        <div class="text-xs ${typeColor}">${typeText}</div>
                    </div>
                    <div class="card-name ${cardDef.upgraded ? 'upgraded' : ''}">${cardDef.name}</div>
                    <div class="card-desc">${descHTML}</div>
                `;
                return el;
            }
            
            function updateDeckDiscardUI() {
                D.game.deckCount.textContent = runState.deck.length;
                D.game.discardCount.textContent = runState.discard.length;
            }
            
            function updatePathDisplay() {
                D.game.pathDisplay.innerHTML = '';
                pathDefinition.forEach((node, index) => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'path-node';
                    if (index < runState.currentFloor) nodeEl.classList.add('cleared');
                    else if (index === runState.currentFloor) nodeEl.classList.add('current');
                    nodeEl.textContent = node.sprite;
                    D.game.pathDisplay.appendChild(nodeEl);
                });
            }
            
            function updateTargetHighlights(cardType) {
                $$('.targeted').forEach(el => el.classList.remove('targeted'));
                
                if (cardType === 'attack' || cardType === 'enemy_skill') {
                    if (runState.enemy) runState.enemy.dom.container.classList.add('targeted');
                } else if (cardType === 'skill') { 
                    D.game.playerContainer.classList.add('targeted');
                }
            }
            
            function showFloatingText(text, targetElement, type) {
                const floatEl = document.createElement('div');
                floatEl.className = `damage-float ${type}`; 
                
                floatEl.textContent = text;
                const xOffset = (Math.random() - 0.5) * 40; 
                floatEl.style.left = `calc(50% + ${xOffset}px)`;
                targetElement.appendChild(floatEl);
                floatEl.addEventListener('animationend', () => floatEl.remove());
            }
            
            function playAnimation(target, animationClass, onEndCallback = null) {
                if (!target) {
                    if (onEndCallback) onEndCallback();
                    return;
                }
                target.classList.add(animationClass);
                const onAnimEnd = () => {
                    target.classList.remove(animationClass);
                    target.removeEventListener('animationend', onAnimEnd);
                    if (onEndCallback) onEndCallback();
                };
                target.addEventListener('animationend', onAnimEnd);
            }
            
            function createAndFireProjectile(sourceEl, targetEl, iconHTML, onEndCallback) {
                const proj = document.createElement('div');
                proj.className = 'anim-projectile';
                proj.innerHTML = iconHTML;
                
                const startRect = sourceEl.getBoundingClientRect();
                const endRect = targetEl.getBoundingClientRect();
                const gameRect = D.gameContainer.getBoundingClientRect();
                
                // 起点 (相对于 game-container)
                const startX = (startRect.left + startRect.width / 2) - gameRect.left;
                const startY = (startRect.top + startRect.height / 2) - gameRect.top;
                
                // 终点 (相对于 game-container)
                const endX = (endRect.left + endRect.width / 2) - gameRect.left;
                const endY = (endRect.top + endRect.height / 2) - gameRect.top;
                
                proj.style.left = `${startX}px`;
                proj.style.top = `${startY}px`;
                proj.style.transform = 'translate(-50%, -50%)';

                D.animationLayer.appendChild(proj);

                requestAnimationFrame(() => {
                    proj.style.transform = `translate(-50%, -50%) translate(${endX - startX}px, ${endY - startY}px)`;
                });
                
                proj.addEventListener('transitionend', () => {
                    proj.remove();
                    if (onEndCallback) onEndCallback();
                });
            }

            // --- 工具函数 ---
            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // --- 事件绑定 ---

            function initTooltipListeners() {
                const tooltip = D.tooltip.el;
                let currentTarget = null; 

                function showTooltip(e) {
                    if (!currentTarget) return;
                    
                    let title = '';
                    let desc = '';
                    let targetRect = currentTarget.getBoundingClientRect();

                    // 1. 检查是什么类型的目标
                    if (currentTarget.dataset.statusId) {
                        // --- 状态图标 ---
                        const statusId = currentTarget.dataset.statusId;
                        const def = statusDefinitions[statusId];
                        if (!def) return;
                        
                        const isPlayer = currentTarget.closest('#player-status-area');
                        const entity = isPlayer ? runState.player : runState.enemy;
                        const duration = entity.status[statusId];
                        
                        title = `${def.name} ${def.icon}`;
                        if (statusId !== 'strength') {
                            title += ` (剩余 ${duration} 回合)`;
                        } else {
                            title += ` (${duration} 层)`;
                        }
                        desc = def.desc;
                        
                    } else if (currentTarget.dataset.intentKey) {
                        // --- 敌人意图 ---
                        const key = currentTarget.dataset.intentKey;
                        const val = currentTarget.dataset.intentVal;
                        const count = currentTarget.dataset.intentCount;
                        const def = intentDefinitions[key];
                        if (!def) return;
                        
                        title = def.name;
                        desc = def.desc(val, count); // 传递参数
                        
                    } else if (currentTarget.dataset.keyword) {
                         // --- 卡牌关键字 ---
                        const key = currentTarget.dataset.keyword;
                        const def = statusDefinitions[key]; // 复用 statusDefinitions
                        if (!def) return;
                        
                        title = `${def.name} ${def.icon || ''}`;
                        desc = def.desc;
                    } else {
                        return; // 不是有效目标
                    }

                    // 2. 填充内容
                    D.tooltip.title.innerHTML = title;
                    D.tooltip.desc.innerHTML = desc;
                    
                    tooltip.classList.add('visible'); 

                    // 3. 安全定位 (屏幕边缘检测)
                    const gameRect = D.gameContainer.getBoundingClientRect();
                    const ttRect = tooltip.getBoundingClientRect(); 
                    
                    const targetTop = targetRect.top - gameRect.top;
                    const targetLeft = targetRect.left - gameRect.left;
                    
                    let ttLeft = targetLeft + (targetRect.width / 2); // 默认居中
                    let ttTop = targetTop - 8; // 默认在上方
                    let transform = 'translate(-50%, -100%)'; // 默认向上
                    
                    // 检查上方
                    if ((targetRect.top - ttRect.height) < gameRect.top) {
                        ttTop = targetTop + targetRect.height + 8; // 移到下方
                        transform = 'translate(-50%, 0)';
                    }
                    
                    // 检查左侧
                    if ((targetRect.left - (ttRect.width / 2)) < gameRect.left) {
                        ttLeft = 5; // 5px 边距
                        transform = transform.replace('translate(-50%', 'translate(0%');
                    }
                    
                    // 检查右侧
                    if ((targetRect.left + (ttRect.width / 2)) > gameRect.right) {
                        ttLeft = gameRect.width - 5; // 5px 边距
                        transform = transform.replace('translate(-50%', 'translate(-100%');
                    }

                    tooltip.style.left = `${ttLeft}px`;
                    tooltip.style.top = `${ttTop}px`;
                    tooltip.style.transform = transform;
                }

                function hideTooltip() {
                    tooltip.classList.remove('visible'); 
                    currentTarget = null;
                }

                function handlePressStart(e) {
                    const target = e.target.closest('.status-icon, [data-intent-key], .keyword');
                    if (target) {
                        e.preventDefault(); 
                        currentTarget = target; // 存储目标
                        showTooltip(); // 立即显示
                    }
                }

                const gameScreen = D.screens.game;
                
                gameScreen.addEventListener('mousedown', handlePressStart);
                gameScreen.addEventListener('touchstart', handlePressStart, { passive: false });

                window.addEventListener('mouseup', hideTooltip);
                window.addEventListener('touchend', hideTooltip);
                window.addEventListener('touchcancel', hideTooltip);
            }
            
            D.mainMenu.continueBtn.addEventListener('click', () => loadRunState());
            D.mainMenu.startBtn.addEventListener('click', () => {
                localStorage.removeItem(RUN_KEY); 
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = '开始探索';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                startNewRun();
            });
            D.mainMenu.upgradesBtn.addEventListener('click', () => showUpgradeScreen());
            
            D.upgrades.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            D.game.endTurnBtn.addEventListener('click', () => endPlayerTurn());
            
            D.game.enemyArea.addEventListener('click', (e) => {
                const enemyContainer = e.target.closest('.enemy-container');
                if (enemyContainer && enemyContainer.id === 'enemy-container-0') {
                    onEnemyClick(runState.enemy);
                }
            });
            D.game.playerContainer.addEventListener('click', () => onPlayerClick());
            
            // V1.14: 重构手牌点击
            D.game.handArea.addEventListener('click', (e) => {
                const cardEl = e.target.closest('.hand-card');
                if (cardEl && !e.target.closest('.keyword')) { // 确保没点中关键字
                    onCardClick(cardEl.dataset.instanceId);
                }
            });


            D.rewards.skipBtn.addEventListener('click', () => selectReward(null));
            D.rewards.rerollBtn.addEventListener('click', () => {
                if (runState.player.rerollCharges > 0) {
                    runState.player.rerollCharges--;
                    generateRewardOptions(); 
                    D.rewards.rerollBtn.textContent = `重抽 (${runState.player.rerollCharges})`;
                    if (runState.player.rerollCharges === 0) {
                        D.rewards.rerollBtn.disabled = true;
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                }
            });

            D.gameOver.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = '开始探索';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            D.smith.backBtn.addEventListener('click', () => setGameState(GAME_STATES.EVENT));

            // --- 游戏启动 ---
            function init() {
                defineStatus();
                defineIntents(); 
                defineCards();
                defineEnemies();
                definePath();
                defineUpgrades();
                initTooltipListeners();
                loadPlayerProfile();
                
                const savedRun = localStorage.getItem(RUN_KEY);
                if (savedRun) {
                    const loadedState = JSON.parse(savedRun);
                    D.mainMenu.startBtn.textContent = '开始新探索'; 
                    D.mainMenu.startBtn.classList.replace('btn-primary', 'btn-secondary'); 
                    
                    D.mainMenu.continueBtn.textContent = `继续探索 (第 ${loadedState.currentFloor + 1} 层)`;
                    D.mainMenu.continueBtn.classList.remove('hidden');
                }
                
                setGameState(GAME_STATES.MAIN_MENU);
            }
            
            init();
        });
    </script>
</body>
</html>
