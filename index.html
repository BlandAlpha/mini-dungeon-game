<!DOCTYPE html>
<html lang="zh-CN" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>迷你地牢 (V1.1)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    
    <style>
        :root {
            --color-bg: #111827; /* 深灰蓝 */
            --color-surface: #1f2937; /* 表面 */
            --color-border: #374151; /* 边框 */
            --color-text: #e5e7eb; /* 文本 */
            --color-text-dim: #9ca3af; /* 暗文本 */
            --color-accent: #22d3ee; /* 青色 (能量) */
            --color-accent-dark: #0e7490;
            --color-red: #ef4444; /* 红色 (伤害) */
            --color-blue: #3b82f6; /* 蓝色 (格挡) */
            --color-yellow: #eab308; /* 黄色 (奖励) */
            --color-green: #22c55e; /* 绿色 (升级) */
            --color-orange: #f97316; /* 橙色 (易伤) */
            --color-gray: #6b7280; /* 灰色 (虚弱) */
            --color-purple: #a855f7; /* 紫色 (诅咒) */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            overscroll-behavior: none; /* 禁止"拉动刷新" */
            -webkit-user-select: none; /* 禁止文本选择 */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent; 
        }

        /* 游戏主容器，模拟竖屏手机 */
        .game-container {
            width: 100%;
            height: 100vh;
            max-width: 420px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-left: 1px solid var(--color-border);
            border-right: 1px solid var(--color-border);
            position: relative;
        }
        
        #animation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 40; 
        }

        /* 隐藏的屏幕 */
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 1; 
        }
        .screen.active {
            display: flex;
            opacity: 1;
            position: relative;
            pointer-events: auto;
            z-index: 2; 
        }
        
        /* 模态框 (用于锻造) */
        .modal-screen {
            position: absolute;
            z-index: 10;
            background-color: rgba(0,0,0,0.5); 
            backdrop-filter: blur(4px);
            display: flex; 
        }
        .modal-screen.active {
            display: flex; 
            opacity: 1;
            pointer-events: auto;
            z-index: 11; 
        }
        .modal-content {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
        }
        
        /* V1.0: 主内容区域 (用于切换) */
        #main-content-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 确保内容区不会溢出 */
        }
        #combat-container, #event-container, #reward-container {
            display: none; /* JS控制显示/隐藏 */
            flex-grow: 1;
            flex-direction: column;
        }
        #event-container, #reward-container {
            justify-content: center;
        }

        /* 卡牌样式 */
        .card {
            width: 80px;
            height: 110px;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            border-radius: 8px;
            padding: 6px; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            flex-shrink: 0;
            position: relative; 
        }
        .card.rarity-common { border-color: var(--color-border); }
        .card.rarity-rare { 
            border-color: var(--color-yellow); 
            box-shadow: 0 0 10px rgba(234, 179, 8, 0.3);
        }
        .card.upgraded {
            border-color: var(--color-green);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        .card.curse { border-color: var(--color-purple); }

        .card-cost {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--color-accent);
            color: var(--color-bg);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            border: 1px solid var(--color-accent-dark);
        }
        .card.curse .card-cost {
            background-color: var(--color-purple);
            border-color: var(--color-purple);
            color: var(--color-text);
        }
        .card-name {
            font-size: 0.85rem; 
            font-weight: 600;
            text-align: center;
        }
        .card-name.rarity-rare { color: var(--color-yellow); }
        .card-name.upgraded { color: var(--color-green); }

        .card-desc {
            font-size: 0.7rem; 
            line-height: 1.3; 
            text-align: center;
            color: var(--color-text-dim);
        }
        .card-desc .keyword {
            color: var(--color-yellow);
            font-weight: 600;
            cursor: help;
        }
        .card.exhaust .card-desc::after {
            content: " (消耗)";
            font-style: italic;
            color: var(--color-text-dim);
        }

        /* 手牌区域 (Layout V2) */
        #hand-area {
            height: 140px; 
            background-color: var(--color-bg);
            border-top: 2px solid var(--color-border);
            padding: 10px; 
            display: flex;
            justify-content: flex-start; 
            align-items: center;
            overflow-x: auto; 
            position: relative;
            flex-shrink: 0; /* V1.0: 防止手牌区被压缩 */
        }
        .hand-card {
            margin-right: 8px; 
        }
        .hand-card:hover {
            transform: translateY(-10px) scale(1.05);
            z-index: 10;
        }
        .hand-card.selected {
            transform: translateY(-20px) scale(1.1);
            border-color: var(--color-accent);
            box-shadow: 0 0 20px 5px rgba(34, 211, 238, 0.3);
            z-index: 20;
        }
        
        .hand-card.playable {
            border-color: var(--color-accent);
        }
        .hand-card.unplayable {
            opacity: 0.6;
            background-color: #333;
        }
        .hand-card.drawing {
            opacity: 0;
            position: absolute;
            z-index: 30;
            transition: all 0.4s ease-out;
        }

        /* 卡牌奖励 UI (Reward Screen Rework) */
        #card-reward-options {
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 20px; 
            gap: 10px; 
            flex-grow: 1; /* V1.0: 填充空间 */
        }
        .reward-card {
            transition: all 0.2s ease-out;
        }
        .reward-card:hover {
            transform: scale(1.05); 
            z-index: 20;
            border-color: var(--color-yellow);
        }
        .reward-card.selected-reward {
            transform: scale(1.05);
            border-color: var(--color-yellow);
            box-shadow: 0 0 15px rgba(234, 179, 8, 0.4);
        }

        /* 敌人 */
        .enemy-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s ease-in-out;
        }
        .enemy-container.targeted {
            transform: scale(1.05);
            filter: drop-shadow(0 0 10px var(--color-accent));
        }
        .enemy-sprite {
            font-size: 6rem; 
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        #enemy-area {
            flex-grow: 1; /* V1.0: 确保敌人区域填充 */
        }
        
        /* 玩家 */
        .player-container {
            transition: transform 0.1s ease-in-out;
            position: relative; 
        }
        .player-container.targeted {
            transform: scale(1.05);
            filter: drop-shadow(0 0 10px var(--color-accent));
        }

        /* 状态条 (HP) */
        .hp-bar-bg {
            background-color: #4b5563;
            border-radius: 99px;
            overflow: hidden;
        }
        .hp-bar-fg {
            height: 100%;
            background: linear-gradient(90deg, #dc2626, #ef4444);
            transition: width 0.3s ease;
        }

        /* 状态图标 */
        .enemy-container .status-icon-container {
            position: absolute;
            left: auto;
            right: -10px;
            bottom: 20px;
            display: flex;
            gap: 4px;
        }
        #player-status-area {
            min-height: 38px; 
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 4px 0;
            background-color: rgba(0,0,0,0.2);
            border-top: 1px solid var(--color-border);
            flex-shrink: 0; /* V1.0: 防止压缩 */
        }
        .status-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 0.9rem; 
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(0,0,0,0.5);
            color: white;
            text-shadow: 0 0 3px black;
            cursor: pointer; 
            transition: transform 0.1s ease;
        }
        .status-icon:active { 
            transform: scale(1.15);
        }
        .status-icon.status-orange { background-color: var(--color-orange); }
        .status-icon.status-gray { background-color: var(--color-gray); }
        .status-icon.status-red { background-color: var(--color-red); }
        .status-icon.status-blue { background-color: var(--color-blue); } 

        /* 按钮样式 */
        .btn {
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-align: center;
            cursor: pointer;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: var(--color-accent);
            color: var(--color-bg);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #67e8f9;
        }
        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: var(--color-border);
        }
        .btn-yellow {
            background: var(--color-yellow);
            color: var(--color-bg);
        }
        .btn-yellow:hover:not(:disabled) {
            background-color: #facc15;
        }
        .btn-event {
            background: var(--color-surface);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            text-align: left;
            padding: 12px;
        }
        .btn-event:hover:not(:disabled) {
            background-color: var(--color-border);
        }
        .btn-event.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .btn-event .event-cost {
            color: var(--color-red);
            font-weight: 600;
        }
        
        /* 伤害/格挡 浮动文字 */
        .damage-float, .block-float {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            opacity: 1;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .damage-float { color: var(--color-red); }
        .damage-float.vulnerable {
            color: var(--color-orange);
            font-size: 1.8rem;
            transform: scale(1.2);
        }
        .block-float { color: var(--color-blue); }
        
        @keyframes floatUp {
            from { transform: translateY(0) scale(1); opacity: 1; }
            to { transform: translateY(-60px) scale(1.2); opacity: 0; }
        }
        
        /* 动画 */
        .anim-shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translateX(-4px); }
            20%, 80% { transform: translateX(4px); }
            30%, 50%, 70% { transform: translateX(-4px); }
            40%, 60% { transform: translateX(4px); }
        }
        .anim-lunge {
            animation: lunge 0.5s ease-in-out;
        }
        @keyframes lunge {
            0% { transform: translateY(0); }
            50% { transform: translateY(30px) scale(1.1); }
            100% { transform: translateY(0); }
        }
        .anim-block-shield {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 4rem;
            opacity: 0;
            animation: block-pop 0.6s ease-out;
            transform-origin: center;
        }
        @keyframes block-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            80% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; }
        }
        .anim-pulse {
            animation: pulse 0.6s ease-out;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: var(--color-yellow); }
            100% { transform: scale(1); }
        }
        .anim-projectile {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            z-index: 45;
            transition: all 0.5s cubic-bezier(0.5, -0.5, 0.5, 1.5); /* S型曲线 */
        }
        
        #enemy-intent-0 {
            cursor: pointer;
        }

        /* 路径节点 (Path Rework) */
        #path-container { /* V1.0: 新容器 */
            flex-shrink: 0;
        }
        #path-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
            font-size: 1.25rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--color-border);
        }
        #path-display {
            display: flex;
            justify-content: center;
            gap: 6px; /* 节点间距 */
            padding: 10px;
            overflow-x: auto;
            background-color: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--color-border);
        }
        .path-node {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--color-text-dim);
            flex-shrink: 0;
            font-weight: 600;
        }
        .path-node.current {
            border-color: var(--color-accent);
            color: var(--color-accent);
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
            transform: scale(1.1);
        }
        .path-node.cleared {
            background-color: var(--color-border);
            opacity: 0.5;
        }
        .path-node.boss {
            border-color: var(--color-red);
            color: var(--color-red);
        }
        
        /* 锻造界面卡牌容器 */
        #smith-deck-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }
        #smith-deck-container .card {
            cursor: pointer;
        }
        #smith-deck-container .card:not(.can-upgrade) {
            opacity: 0.4;
            cursor: not-allowed;
        }
        #smith-deck-container .card.can-upgrade:hover {
            transform: scale(1.05);
            border-color: var(--color-green);
        }
        
        /* Tooltip 提示框 */
        #tooltip {
            position: absolute; 
            z-index: 50;
            padding: 12px;
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            max-width: 250px;
            width: max-content; 
            text-align: center;
            pointer-events: none; 
            opacity: 0; 
            transition: opacity 0.1s ease;
        }
        #tooltip.visible {
            opacity: 1; 
        }
        #tooltip-title {
            font-weight: 700;
            color: var(--color-text);
            margin-bottom: 4px;
        }
        #tooltip-desc {
            font-size: 0.875rem;
            color: var(--color-text-dim);
        }
        #tooltip-desc .keyword {
            color: var(--color-yellow);
            font-weight: 600;
            pointer-events: all; 
            cursor: help;
        }
        
    </style>
</head>
<body>
    <div id="game-container" class="game-container bg-gray-900">
        
        <div id="animation-layer"></div>

        <!-- 1. 主菜单屏幕 -->
        <div id="main-menu-screen" class="screen active p-6 justify-between">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-white">迷你地牢</h1>
                <p class="text-lg text-gray-400 mt-2">Mini Dungeon</p>
            </div>
            
            <div class="space-y-4">
                <button id="continue-run-btn" class="btn btn-primary w-full text-lg hidden">继续探索</button>
                <button id="start-run-btn" class="btn btn-primary w-full text-lg">开始探索</button>
                <button id="upgrades-menu-btn" class="btn btn-secondary w-full text-lg">永久升级</button>
            </div>
            
            <div class="text-center text-gray-500 text-sm">
                <p>最高层数: <span id="high-score-display">0</span></p>
            </div>
        </div>

        <!-- 2. 升级屏幕 -->
        <div id="upgrade-screen" class="screen p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h2 class="text-2xl font-bold text-white">永久升级</h2>
                <button id="upgrade-back-btn" class="btn btn-secondary">返回</button>
            </div>
            
            <div class="text-center p-4 bg-gray-800 rounded-lg">
                <p class="text-gray-400">可用余烬</p>
                <p id="currency-display" class="text-3xl font-bold text-yellow-400">0 🔥</p>
            </div>
            
            <!-- 升级选项 -->
            <div id="upgrade-options-container" class="space-y-3 flex-grow overflow-y-auto">
                <!-- 升级项将由JS动态填充 -->
            </div>
        </div>

        <!-- 3. 游戏主屏幕 (V1.0: 结构重构) -->
        <div id="game-screen" class="screen">
            
            <!-- V1.0: 路径容器 (始终可见) -->
            <div id="path-container">
                <div id="path-header">
                    <span id="floor-display">第 1 层</span>
                </div>
                <div id="path-display">
                    <!-- JS动态填充路径节点 -->
                </div>
            </div>
            
            <!-- V1.0: 主内容区 (切换战斗/事件/奖励) -->
            <div id="main-content-area">
                
                <!-- 3a. 战斗容器 -->
                <div id="combat-container" class="overflow-hidden">
                    <!-- 敌人区域 -->
                    <div id="enemy-area" class="flex-grow flex flex-col justify-center items-center space-y-2 p-4">
                        <div id="enemy-container-0" class="enemy-container">
                            <div id="enemy-intent-0" class="p-1 px-3 bg-gray-700 rounded-full text-lg font-semibold flex items-center space-x-1.5">
                                <!-- ⚔️ 5 -->
                            </div>
                            <div id="enemy-sprite-0" class="enemy-sprite">😈</div>
                            <div id="enemy-hp-bar-0" class="w-2/3 hp-bar-bg h-4">
                                <div class="hp-bar-fg"></div>
                            </div>
                            <div id="enemy-hp-text-0" class="text-sm">15 / 15</div>
                            <div id="enemy-block-text-0" class="absolute -right-4 top-1/2 text-xl font-bold text-blue-400 bg-gray-800 p-1 px-2 rounded-full hidden">
                                🛡️ 0
                            </div>
                            <div id="enemy-status-icons-0" class="status-icon-container"></div>
                        </div>
                    </div>
                    
                    <!-- 玩家区域 -->
                    <div id="player-area" class="p-4 border-t border-gray-700 bg-gray-800 flex-shrink-0">
                        <div id="player-container" class="player-container flex items-center justify-between">
                            <!-- 玩家状态 -->
                            <div class="space-y-2 w-2/3">
                                <div id="player-hp-bar" class="w-full hp-bar-bg h-5">
                                    <div class="hp-bar-fg"></div>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <div id="player-hp-text" class="font-bold">50 / 50</div>
                                    <div id="player-block-text" class="font-bold text-blue-400">🛡️ 0</div>
                                </div>
                            </div>
                            <!-- 能量 -->
                            <div class="flex flex-col items-center">
                                <div id="player-energy-text" class="text-5xl font-bold text-accent">3/3</div>
                                <div class="text-xs text-gray-400">能量 ⚡</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 玩家状态图标区 -->
                    <div id="player-status-area">
                        <!-- JS动态填充 -->
                    </div>

                    <!-- 手牌区域 (Layout V2) -->
                    <div id="hand-area">
                        <!-- 卡牌由JS动态填充 -->
                    </div>
                    
                    <!-- 底部操作栏 -->
                    <div id="bottom-bar" class="p-3 bg-gray-800 border-t border-gray-700 flex justify-between items-center flex-shrink-0">
                        <div class="text-center relative">
                            <div id="deck-count" class="font-bold text-lg">10</div>
                            <div class="text-xs text-gray-400">牌堆</div>
                        </div>
                        <button id="end-turn-btn" class="btn btn-primary text-lg px-8 py-3">结束回合</button>
                        <div class="text-center relative">
                            <div id="discard-count" class="font-bold text-lg">0</div>
                            <div class="text-xs text-gray-400">弃牌堆</div>
                        </div>
                    </div>
                </div>
                
                <!-- 3b. 事件容器 (V1.0: 从 #event-screen 移入) -->
                <div id="event-container" class="p-6 space-y-6 text-center">
                    <h2 id="event-title" class="text-3xl font-bold text-white">遭遇事件</h2>
                    <p id="event-description" class="text-lg text-gray-300">...</p>
                    <div id="event-options" class="w-full max-w-sm mx-auto space-y-3">
                        <!-- 事件选项由JS (btn-event) 填充 -->
                    </div>
                </div>
                
                <!-- 3c. 奖励容器 (V1.0: 从 #reward-screen 移入) -->
                <div id="reward-container" class="p-6 space-y-6">
                    <div class="text-center">
                        <h2 id="reward-title" class="text-3xl font-bold text-white">战斗胜利！</h2> 
                        <p class="text-lg text-yellow-400">获得 <span id="reward-currency">0</span> 🔥</p>
                    </div>
                    
                    <div id="card-reward-options">
                        <!-- 3张卡牌选项(水平)由JS填充 -->
                    </div>
                    
                    <!-- 奖励按钮 -->
                    <div class="w-full max-w-sm mx-auto space-y-3">
                        <button id="confirm-reward-btn" class="btn btn-primary w-full hidden">确认选择</button>
                        <div class="flex space-x-4 w-full">
                            <button id="skip-reward-btn" class="btn btn-secondary w-1/2">跳过</button>
                            <button id="reroll-reward-btn" class="btn btn-yellow w-1/2 hidden">重抽 (1)</button>
                        </div>
                    </div>
                </div>

            </div> <!-- End #main-content-area -->

        </div> <!-- End #game-screen -->
        
        <!-- 4. 奖励屏幕 (V1.0: 已删除) -->
        
        <!-- 5. 事件屏幕 (V1.0: 已删除) -->

        <!-- 6. 游戏结束屏幕 -->
        <div id="game-over-screen" class="screen p-6 justify-center items-center text-center space-y-6">
            <h2 id="game-over-title" class="text-4xl font-bold text-red-500">你倒下了</h2>
            <div class="text-lg space-y-2">
                <p>你深入到了第 <span id="final-floor" class="font-bold text-xl text-white">0</span> 层</p> 
                <p>你收集了 <span id="final-currency" class="font-bold text-xl text-yellow-400">0</span> 🔥 余烬</p>
            </div>
            <button id="game-over-back-btn" class="btn btn-primary w-full text-lg">返回主菜单</button>
        </div>
        
        <!-- 7. 锻造屏幕 (模态框) -->
        <div id="smith-screen" class="screen modal-screen p-4 justify-center items-center">
            <div class="modal-content w-full max-w-sm h-3/4 flex flex-col rounded-lg overflow-hidden">
                <h2 class="text-2xl font-bold text-white text-center p-4">选择一张卡牌进行锻造</h2>
                <div id="smith-deck-container" class="flex-grow">
                    <!-- 卡牌列表由JS填充 -->
                </div>
                <div class="p-4 border-t border-gray-700">
                    <button id="smith-back-btn" class="btn btn-secondary w-full">离开</button> <!-- V1.1: 文本更改 -->
                </div>
            </div>
        </div>

    </div>

    <!-- Tooltip 提示框 -->
    <div id="tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-desc"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 全局状态和DOM引用 ---
            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);
            
            const PROFILE_KEY = 'miniDungeonProfile'; 
            const RUN_KEY = 'miniDungeonRun'; 

            let playerProfile = {}; // 局外成长
            let runState = {}; // 当前局内状态
            let cardDefinitions = {}; // 卡牌定义
            let enemyDefinitions = {}; // 敌人定义
            let eventDefinitions = {}; // 事件定义
            let upgradeDefinitions = {}; // 升级定义
            let statusDefinitions = {}; // 状态定义
            let intentDefinitions = {}; // 意图定义
            
            const GAME_STATES = {
                MAIN_MENU: 'MAIN_MENU',
                UPGRADES: 'UPGRADES',
                GAME_OVER: 'GAME_OVER',
                EVENT: 'EVENT',
                REWARD: 'REWARD',
                SMITHING: 'SMITHING',
                // Combat Sub-states
                PLAYER_TURN: 'PLAYER_TURN', // 等待玩家输入
                PROCESSING_LOGIC: 'PROCESSING_LOGIC', // 任何卡牌/回合逻辑结算中
                COMBAT_OVER: 'COMBAT_OVER', // 战斗胜利，等待奖励
            };

            const NODE_TYPE = {
                MONSTER: 'M',
                ELITE: 'E',
                EVENT: 'R',
                BOSS: 'B',
            };
            const NODE_SPRITES = {
                [NODE_TYPE.MONSTER]: '👺',
                [NODE_TYPE.ELITE]: '🗿',
                [NODE_TYPE.EVENT]: '🔥', 
                [NODE_TYPE.BOSS]: '🤖',
                FOG: '?', 
            };
            
            const CARD_RARITY = {
                BASIC: 'basic',
                COMMON: 'common',
                RARE: 'rare',
                CURSE: 'curse',
            };

            const D = { // DOM 引用
                gameContainer: $('#game-container'), 
                animationLayer: $('#animation-layer'), 
                screens: {
                    mainMenu: $('#main-menu-screen'),
                    upgrades: $('#upgrade-screen'),
                    game: $('#game-screen'),
                    gameOver: $('#game-over-screen'),
                    smith: $('#smith-screen'), 
                },
                mainMenu: {
                    continueBtn: $('#continue-run-btn'),
                    startBtn: $('#start-run-btn'),
                    upgradesBtn: $('#upgrades-menu-btn'),
                    highScore: $('#high-score-display'),
                },
                upgrades: {
                    backBtn: $('#upgrade-back-btn'),
                    currency: $('#currency-display'),
                    optionsContainer: $('#upgrade-options-container'),
                },
                game: {
                    pathContainer: $('#path-container'),
                    mainContentArea: $('#main-content-area'),
                    combatContainer: $('#combat-container'),
                    eventContainer: $('#event-container'),
                    rewardContainer: $('#reward-container'),
                    bottomBar: $('#bottom-bar'),
                    
                    floorDisplay: $('#floor-display'), 
                    pathDisplay: $('#path-display'),
                    enemyArea: $('#enemy-area'),
                    playerArea: $('#player-area'),
                    handArea: $('#hand-area'),
                    endTurnBtn: $('#end-turn-btn'),
                    playerHPBar: $('#player-hp-bar .hp-bar-fg'),
                    playerHPText: $('#player-hp-text'),
                    playerBlockText: $('#player-block-text'),
                    playerEnergyText: $('#player-energy-text'),
                    playerContainer: $('#player-container'),
                    playerStatusIcons: $('#player-status-area'), 
                    deckCount: $('#deck-count'),
                    discardCount: $('#discard-count'),
                },
                rewards: {
                    title: $('#reward-title'), 
                    options: $('#card-reward-options'),
                    confirmBtn: $('#confirm-reward-btn'), 
                    skipBtn: $('#skip-reward-btn'),
                    rerollBtn: $('#reroll-reward-btn'),
                    currency: $('#reward-currency'),
                },
                event: {
                    title: $('#event-title'),
                    description: $('#event-description'),
                    options: $('#event-options'),
                },
                gameOver: {
                    screen: $('#game-over-screen'),
                    title: $('#game-over-title'),
                    backBtn: $('#game-over-back-btn'),
                    finalFloor: $('#final-floor'),
                    finalCurrency: $('#final-currency'),
                },
                smith: { 
                    container: $('#smith-deck-container'),
                    backBtn: $('#smith-back-btn'),
                },
                tooltip: { 
                    el: $('#tooltip'),
                    title: $('#tooltip-title'),
                    desc: $('#tooltip-desc'),
                }
            };

            // --- 游戏数据定义 ---

            function defineStatus() {
                statusDefinitions = {
                    'vulnerable': {
                        name: '易伤',
                        icon: '🛡️',
                        desc: '受到的 <strong>攻击</strong> 伤害 +50%。',
                        color: 'orange' 
                    },
                    'weak': {
                        name: '虚弱',
                        icon: '⚔️',
                        desc: '造成的 <strong>攻击</strong> 伤害 -50%。',
                        color: 'gray'
                    },
                    'strength': {
                        name: '力量',
                        icon: '💪',
                        desc: '增加 <strong>攻击</strong> 造成的伤害。',
                        color: 'red'
                    },
                    'barricade': { 
                        name: '壁垒',
                        icon: '🛡️',
                        desc: '你的 <strong>格挡</strong> 不会在回合结束时消失。',
                        color: 'blue'
                    },
                    'exhaust': { 
                        name: '消耗',
                        icon: '🔥',
                        desc: '此卡牌使用后，在本场战斗中被移除牌组（不会进入弃牌堆）。'
                    },
                    'curse': { 
                        name: '诅咒',
                        icon: '🟣',
                        desc: '一张干扰你牌库的卡牌。'
                    }
                };
            }
            
            function defineIntents() {
                intentDefinitions = {
                    'attack': {
                        name: '攻击',
                        desc: (val) => `敌人将造成 <strong>${val}</strong> 点伤害。`
                    },
                    'attack_multi': {
                        name: '多段攻击',
                        desc: (val, count) => `敌人将造成 <strong>${val}</strong> 点伤害，共 <strong>${count}</strong> 次。`
                    },
                    'defend': {
                        name: '防御',
                        desc: (val) => `敌人将获得 <strong>${val}</strong> 点格挡。`
                    },
                    'buff': {
                        name: '强化 (Buff)',
                        desc: (val) => `敌人将获得 <strong>${val}</strong> 层 <strong>力量</strong>。`
                    },
                    'debuff_vulnerable': {
                        name: '减益 (Debuff)',
                        desc: (val) => `敌人将对你施加 <strong>${val}</strong> 回合 <k>易伤</k>。`
                    },
                    'debuff_weak': {
                        name: '减益 (Debuff)',
                        desc: (val) => `敌人将对你施加 <strong>${val}</strong> 回合 <k>虚弱</k>。`
                    },
                    'pollute': {
                        name: '污染',
                        desc: (val) => `敌人将 <strong>${val}</strong> 张 <strong>黏液</strong> 塞入你的弃牌堆。`
                    }
                };
            }
            
            function defineCards() {
                cardDefinitions = {
                    // --- 基础卡牌 (Basic) ---
                    'strike': {
                        id: 'strike', name: '打击', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.BASIC,
                        desc: '造成 6 点伤害。',
                        upgradesTo: 'strike_plus',
                        effect: (caster, target) => dealDamage(target, 6, caster),
                    },
                    'strike_plus': {
                        id: 'strike_plus', name: '打击+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.BASIC,
                        desc: '造成 9 点伤害。',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 9, caster),
                    },
                    'defend': {
                        id: 'defend', name: '防御', cost: 1, type: 'skill',
                        desc: '获得 5 点格挡。',
                        target: 'self', rarity: CARD_RARITY.BASIC,
                        upgradesTo: 'defend_plus',
                        effect: (caster) => addBlock(caster, 5),
                    },
                    'defend_plus': {
                        id: 'defend_plus', name: '防御+', cost: 1, type: 'skill',
                        desc: '获得 8 点格挡。',
                        target: 'self', rarity: CARD_RARITY.BASIC,
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 8),
                    },
                    
                    // --- 普通卡牌 (Common) ---
                    'heavy_strike': {
                        id: 'heavy_strike', name: '重击', cost: 2, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 12 点伤害。',
                        upgradesTo: 'heavy_strike_plus',
                        effect: (caster, target) => dealDamage(target, 12, caster),
                    },
                    'heavy_strike_plus': {
                        id: 'heavy_strike_plus', name: '重击+', cost: 2, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 16 点伤害。',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 16, caster),
                    },
                    'double_hit': {
                        id: 'double_hit', name: '二连击', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 4 点伤害，2次。',
                        upgradesTo: 'double_hit_plus',
                        effect: (caster, target) => {
                            dealDamage(target, 4, caster, 0); 
                            dealDamage(target, 4, caster, 150);
                        },
                    },
                    'double_hit_plus': {
                        id: 'double_hit_plus', name: '二连击+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 6 点伤害，2次。',
                        upgraded: true,
                        effect: (caster, target) => {
                            dealDamage(target, 6, caster, 0);
                            dealDamage(target, 6, caster, 150);
                        },
                    },
                    'iron_wall': {
                        id: 'iron_wall', name: '铁壁', cost: 2, type: 'skill',
                        desc: '获得 10 点格挡。',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'iron_wall_plus',
                        effect: (caster) => addBlock(caster, 10),
                    },
                    'iron_wall_plus': {
                        id: 'iron_wall_plus', name: '铁壁+', cost: 2, type: 'skill',
                        desc: '获得 14 点格挡。',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        effect: (caster) => addBlock(caster, 14),
                    },
                    'quick_slash': {
                        id: 'quick_slash', name: '快斩', cost: 0, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 3 点伤害。',
                        upgradesTo: 'quick_slash_plus',
                        effect: (caster, target) => dealDamage(target, 3, caster),
                    },
                    'quick_slash_plus': {
                        id: 'quick_slash_plus', name: '快斩+', cost: 0, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 5 点伤害。',
                        upgraded: true,
                        effect: (caster, target) => dealDamage(target, 5, caster),
                    },
                    'vampiric_touch': {
                        id: 'vampiric_touch', name: '吸血', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 5 点伤害。回复 2 点生命。',
                        upgradesTo: 'vampiric_touch_plus',
                        effect: (caster, target) => { 
                            dealDamage(target, 5, caster); 
                            setTimeout(() => healDamage(caster, 2), 200);
                        },
                    },
                    'vampiric_touch_plus': {
                        id: 'vampiric_touch_plus', name: '吸血+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 7 点伤害。回复 3 点生命。',
                        upgraded: true,
                        effect: (caster, target) => { 
                            dealDamage(target, 7, caster);
                            setTimeout(() => healDamage(caster, 3), 200);
                        },
                    },
                    'battle_focus': {
                        id: 'battle_focus', name: '专注', cost: 1, type: 'skill',
                        desc: '抽 2 张牌。',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'battle_focus_plus',
                        effect: (caster, target, card) => drawCards(2, card),
                    },
                    'battle_focus_plus': {
                        id: 'battle_focus_plus', name: '专注+', cost: 1, type: 'skill',
                        desc: '抽 3 张牌。',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        effect: (caster, target, card) => drawCards(3, card),
                    },
                    'break': {
                        id: 'break', name: '破绽', cost: 1, type: 'skill',
                        desc: '施加 2 层<k>易伤</k>。',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'break_plus',
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 2, caster),
                    },
                    'break_plus': {
                        id: 'break_plus', name: '破绽+', cost: 1, type: 'skill',
                        desc: '施加 3 层<k>易伤</k>。',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        exhaust: true,
                        effect: (caster, target) => applyStatus(target, 'vulnerable', 3, caster),
                    },
                    'demoralize': {
                        id: 'demoralize', name: '挫志', cost: 1, type: 'skill',
                        desc: '施加 1 层<k>虚弱</k>。',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'demoralize_plus',
                        effect: (caster, target) => applyStatus(target, 'weak', 1, caster),
                    },
                    'demoralize_plus': {
                        id: 'demoralize_plus', name: '挫志+', cost: 1, type: 'skill',
                        desc: '施加 2 层<k>虚弱</k>。',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        effect: (caster, target) => applyStatus(target, 'weak', 2, caster),
                    },
                    'bulwark': {
                        id: 'bulwark', name: '坚守', cost: 1, type: 'attack', 
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 7 点伤害。若你有格挡，抽 1 张牌。',
                        upgradesTo: 'bulwark_plus',
                        effect: (caster, target, card) => {
                            dealDamage(target, 7, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200);
                            }
                        },
                    },
                    'bulwark_plus': {
                        id: 'bulwark_plus', name: '坚守+', cost: 1, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.COMMON,
                        desc: '造成 10 点伤害。若你有格挡，抽 1 张牌。',
                        upgraded: true,
                        effect: (caster, target, card) => {
                            dealDamage(target, 10, caster);
                            if (caster.block > 0) {
                                setTimeout(() => drawCards(1, card), 200);
                            }
                        },
                    },
                    'energy_burst': {
                        id: 'energy_burst', name: '能量爆发', cost: 0, type: 'skill',
                        desc: '获得 2 点能量 ⚡。',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgradesTo: 'energy_burst_plus',
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 2;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },
                    'energy_burst_plus': {
                        id: 'energy_burst_plus', name: '能量爆发+', cost: 0, type: 'skill',
                        desc: '获得 3 点能量 ⚡。',
                        target: 'self', rarity: CARD_RARITY.COMMON,
                        upgraded: true,
                        exhaust: true,
                        effect: (caster) => {
                            caster.energy += 3;
                            playAnimation(D.game.playerEnergyText, 'anim-pulse');
                        },
                    },

                    // --- 稀有卡牌 (Rare) ---
                    'adrenaline': { 
                        id: 'adrenaline', name: '能量爆发+', cost: 0, type: 'skill',
                        target: 'self', rarity: CARD_RARITY.RARE,
                        desc: '获得 2 点能量 ⚡。抽 2 张牌。<k>消耗</k>。', 
                        exhaust: true, upgraded: true, 
                        effect: (caster, target, card) => { 
                            caster.energy += 2; 
                            playAnimation(D.game.playerEnergyText, 'anim-pulse'); 
                            drawCards(2, card); 
                        },
                    },
                    'barricade': { 
                        id: 'barricade', name: '壁垒', cost: 2, type: 'skill',
                        target: 'self', rarity: CARD_RARITY.RARE,
                        desc: '获得 15 点格挡。你的<k>格挡</k>不再于回合结束时消失。', 
                        upgradesTo: 'barricade_plus',
                        effect: (caster) => { 
                            addBlock(caster, 15); 
                            applyStatus(caster, 'barricade', 1, caster); 
                        },
                    },
                    'barricade_plus': { 
                        id: 'barricade_plus', name: '壁垒+', cost: 2, type: 'skill',
                        target: 'self', rarity: CARD_RARITY.RARE,
                        desc: '获得 20 点格挡。你的<k>格挡</k>不再于回合结束时消失。', 
                        upgraded: true, 
                        effect: (caster) => { 
                            addBlock(caster, 20); 
                            applyStatus(caster, 'barricade', 1, caster);
                        },
                    },
                    'annihilate': { 
                        id: 'annihilate', name: '湮灭', cost: 3, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.RARE,
                        desc: '造成 30 点伤害。', 
                        upgradesTo: 'annihilate_plus',
                        effect: (caster, target) => dealDamage(target, 30, caster),
                    },
                    'annihilate_plus': { 
                        id: 'annihilate_plus', name: '湮灭+', cost: 3, type: 'attack',
                        target: 'enemy', rarity: CARD_RARITY.RARE,
                        desc: '造成 40 点伤害。', 
                        upgraded: true, 
                        effect: (caster, target) => dealDamage(target, 40, caster),
                    },
                    
                    // --- 诅咒 (Curse) ---
                    'slime_curse': {
                        id: 'slime_curse', name: '黏液', cost: 0, type: 'curse',
                        target: 'self', rarity: CARD_RARITY.CURSE,
                        desc: '无用。',
                        exhaust: true,
                        effect: () => {}, 
                    }
                };
            }
            
            function defineEnemies() {
                enemyDefinitions = {
                    // --- Floor 1 ---
                    'goblin': {
                        name: '哥布林', hp: 20, sprite: '👺', currency: 3,
                        moves: [
                            { type: 'attack', val: 6, intent: '⚔️ 6', intentKey: 'attack' },
                            { type: 'attack', val: 8, intent: '⚔️ 8', intentKey: 'attack' },
                        ]
                    },
                    'slime': {
                        name: '史莱姆', hp: 15, sprite: '🦠', currency: 2,
                        moves: [
                            { type: 'attack', val: 5, intent: '⚔️ 5', intentKey: 'attack' },
                            { type: 'defend', val: 3, intent: '🛡️ 3', intentKey: 'defend' }, 
                            { type: 'pollute', val: 1, intent: '🤮 1', intentKey: 'pollute' }, 
                        ]
                    },
                    'guardian': { // Elite
                        name: '守卫', hp: 60, sprite: '🗿', currency: 15,
                        moves: [
                            { type: 'attack', val: 12, intent: '⚔️ 12', intentKey: 'attack' },
                            { type: 'debuff', status: 'vulnerable', val: 1, intent: '😵 1', intentKey: 'debuff_vulnerable' }, 
                            { type: 'defend', val: 15, intent: '🛡️ 15', intentKey: 'defend' },
                        ]
                    },
                    'golem': { // Boss
                        name: '魔像', hp: 120, sprite: '🤖', currency: 50, isBoss: true,
                        moves: [
                            { type: 'attack', val: 15, intent: '⚔️ 15', intentKey: 'attack' },
                            { type: 'attack_multi', val: 8, count: 2, intent: '⚔️ 8 (2次)', intentKey: 'attack_multi' },
                            { type: 'defend', val: 20, intent: '🛡️ 20', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 3, intent: '💪+3', intentKey: 'buff' }, 
                            { type: 'pollute', val: 2, intent: '🤮 2', intentKey: 'pollute' }, 
                        ],
                        onTurn: (enemy, onEndCallback) => { 
                            const move = enemy.nextMove;
                            if (move.intentKey === 'attack_multi') { 
                                playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                    takeDamage(runState.player, move.val, enemy, 0); 
                                    setTimeout(() => {
                                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                                            takeDamage(runState.player, move.val, enemy, 0); 
                                            onEndCallback(); 
                                        });
                                    }, 300); 
                                });
                            } else {
                                executeDefaultEnemyMove(enemy, onEndCallback);
                            }
                        }
                    },
                    // --- Floor 2+ ---
                    'orc': {
                        name: '兽人', hp: 40, sprite: '👹', currency: 8,
                        moves: [
                            { type: 'attack', val: 10, intent: '⚔️ 10', intentKey: 'attack' },
                            { type: 'defend', val: 8, intent: '🛡️ 8', intentKey: 'defend' },
                            { type: 'buff', status: 'strength', val: 2, intent: '💪+2', intentKey: 'buff' }, 
                        ]
                    },
                    'shadow': {
                        name: '暗影', hp: 30, sprite: '👻', currency: 7,
                        moves: [
                            { type: 'attack', val: 7, intent: '⚔️ 7', intentKey: 'attack' },
                            { type: 'attack', val: 7, intent: '⚔️ 7', intentKey: 'attack' },
                            { type: 'debuff', status: 'weak', val: 1, intent: '😵‍💫 1', intentKey: 'debuff_weak' }, 
                        ]
                    },
                }
            }
            
            function defineEvents() {
                eventDefinitions = {
                    'rest': {
                        id: 'rest',
                        title: '篝火',
                        desc: '一个古老的篝火在摇曳。你感到一阵温暖。',
                        sprite: '🔥',
                        choices: [
                            { text: '休息 (回复 30% HP)', action: () => {
                                healDamage(runState.player, Math.floor(runState.player.maxHp * 0.3));
                                proceedToNextLevel();
                            }},
                            { text: '锻造 (升级一张卡)', action: () => {
                                // V1.1: 锁定选择
                                D.event.description.textContent = '你选择在篝火旁锻造你的装备。';
                                D.event.options.innerHTML = ''; // 清空选项
                                showSmithScreen();
                            }},
                            { text: '离开', action: () => proceedToNextLevel() },
                        ]
                    },
                    'statue': {
                        id: 'statue',
                        title: '低语神像',
                        desc: '一个神像在低语，它渴望你的生命力。',
                        sprite: '🙏',
                        choices: [
                            { 
                                text: '献祭 <span class="event-cost">(失去 10% 最大HP)</span>', 
                                cost: () => runState.player.hp > Math.floor(runState.player.maxHp * 0.1), 
                                action: () => {
                                    const cost = Math.floor(runState.player.maxHp * 0.1);
                                    runState.player.maxHp -= cost;
                                    if (runState.player.hp > runState.player.maxHp) {
                                        runState.player.hp = runState.player.maxHp;
                                    }
                                    applyStatus(runState.player, 'strength', 1, runState.player); 
                                    updateEntityUI(runState.player);
                                    proceedToNextLevel();
                                }
                            },
                            { text: '忽略', action: () => proceedToNextLevel() },
                        ]
                    },
                    'chest': {
                        id: 'chest',
                        title: '黄金宝箱',
                        desc: '一个未上锁的华丽宝箱。',
                        sprite: '📦',
                        choices: [
                            { 
                                text: '打开', 
                                action: () => {
                                    if (Math.random() < 0.3) {
                                        // 陷阱!
                                        addCardToDeck(cardDefinitions.slime_curse);
                                        D.event.description.textContent = '是陷阱！你获得了一张 <k>诅咒</k>...'; 
                                        D.event.options.innerHTML = `<button class="btn btn-secondary w-full" id="event-leave">离开</button>`;
                                        $('#event-leave').onclick = () => proceedToNextLevel();
                                    } else {
                                        // 奖励!
                                        runState.runCurrency += 20;
                                        addCardToDeck(getRandomCard(CARD_RARITY.COMMON));
                                        D.event.description.textContent = '你获得了 20🔥 和一张新卡牌！';
                                        D.event.options.innerHTML = `<button class="btn btn-primary w-full" id="event-leave">太好了</button>`;
                                        $('#event-leave').onclick = () => proceedToNextLevel();
                                    }
                                }
                            },
                            { text: '离开', action: () => proceedToNextLevel() },
                        ]
                    }
                };
            }
            
            function defineUpgrades() {
                upgradeDefinitions = {
                    'max_hp': {
                        name: '强化体质',
                        desc: '最大生命值 +5',
                        baseCost: 50,
                        costIncrease: 25,
                        maxLevel: 10,
                        apply: (profile) => profile.baseHp += 5,
                    },
                    'start_energy': {
                        name: '活力源泉',
                        desc: '初始能量 +1',
                        baseCost: 300,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.baseEnergy += 1,
                    },
                    'start_heal': {
                        name: '初始回复',
                        desc: '开始时回复 10 点生命',
                        baseCost: 100,
                        costIncrease: 50,
                        maxLevel: 3,
                        apply: (profile) => profile.startHeal += 10,
                    },
                    'greed': { 
                        name: '贪婪',
                        desc: '战斗胜利时额外获得 2% 余烬',
                        baseCost: 80,
                        costIncrease: 40,
                        maxLevel: 10,
                        apply: (profile) => profile.greedBonus += 0.02,
                    },
                    'smith_chance': { 
                        name: '工匠精神',
                        desc: '锻造时有 5% 几率不消耗篝火',
                        baseCost: 150,
                        costIncrease: 75,
                        maxLevel: 5,
                        apply: (profile) => profile.smithChance += 0.05,
                    },
                    'reroll_charges': { 
                        name: '命运之手',
                        desc: '卡牌奖励界面获得 1 次重抽机会',
                        baseCost: 250,
                        costIncrease: 0,
                        maxLevel: 1,
                        apply: (profile) => profile.rerollCharges += 1,
                    },
                };
            }

            // --- 局外成长 (Profile) & 存档 (Run) ---

            function loadPlayerProfile() {
                const profile = localStorage.getItem(PROFILE_KEY);
                if (profile) {
                    playerProfile = JSON.parse(profile);
                    // 确保所有升级属性都存在
                    if (!playerProfile.upgrades.start_heal) playerProfile.upgrades.start_heal = 0;
                    if (!playerProfile.startHeal) playerProfile.startHeal = 0;
                    if (!playerProfile.upgrades.greed) playerProfile.upgrades.greed = 0;
                    if (!playerProfile.greedBonus) playerProfile.greedBonus = 0;
                    if (!playerProfile.upgrades.smith_chance) playerProfile.upgrades.smith_chance = 0;
                    if (!playerProfile.smithChance) playerProfile.smithChance = 0;
                    if (!playerProfile.upgrades.reroll_charges) playerProfile.upgrades.reroll_charges = 0;
                    if (!playerProfile.rerollCharges) playerProfile.rerollCharges = 0;
                } else {
                    playerProfile = {
                        totalCurrency: 0,
                        highScore: 0,
                        upgrades: { 
                            'max_hp': 0,
                            'start_energy': 0,
                            'start_heal': 0,
                            'greed': 0,
                            'smith_chance': 0,
                            'reroll_charges': 0,
                        },
                        baseHp: 50,
                        baseEnergy: 3,
                        startHeal: 0,
                        greedBonus: 0,
                        smithChance: 0,
                        rerollCharges: 0,
                    };
                    savePlayerProfile();
                }
                updateMainMenuUI();
            }

            function savePlayerProfile() {
                localStorage.setItem(PROFILE_KEY, JSON.stringify(playerProfile));
            }

            function saveRunState() {
                if (!runState || runState.gameState === GAME_STATES.MAIN_MENU || runState.gameState === GAME_STATES.GAME_OVER) {
                    return;
                }
                
                const savableState = { ...runState };
                if (savableState.enemy) {
                    const { dom, ...savableEnemy } = savableState.enemy;
                    savableState.enemy = savableEnemy;
                }
                localStorage.setItem(RUN_KEY, JSON.stringify(savableState));
            }

            function loadRunState() {
                const savedRun = localStorage.getItem(RUN_KEY);
                if (!savedRun) return;

                runState = JSON.parse(savedRun);

                // 重新 "附加" (Hydrate) DOM 引用
                if (runState.enemy) {
                    runState.enemy.dom = {
                        container: $(`#enemy-container-0`),
                        intent: $(`#enemy-intent-0`),
                        sprite: $(`#enemy-sprite-0`),
                        hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                        hpText: $(`#enemy-hp-text-0`),
                        blockText: $(`#enemy-block-text-0`),
                        statusIcons: $(`#enemy-status-icons-0`),
                    };
                }
                
                // 恢复游戏
                updatePathDisplay();
                updateAllUI();
                setGameState(runState.gameState); 
            }
            
            function updateMainMenuUI() {
                D.mainMenu.highScore.textContent = playerProfile.highScore;
            }
            
            function showUpgradeScreen() {
                D.upgrades.currency.textContent = `${playerProfile.totalCurrency} 🔥`;
                const container = D.upgrades.optionsContainer;
                container.innerHTML = '';
                
                for (const id in upgradeDefinitions) {
                    const def = upgradeDefinitions[id];
                    const level = playerProfile.upgrades[id] || 0;
                    const cost = def.baseCost + (def.costIncrease * level);
                    const canBuy = playerProfile.totalCurrency >= cost && level < def.maxLevel;

                    let buttonText;
                    if (level >= def.maxLevel) {
                        buttonText = '已达上限';
                    } else {
                        buttonText = `购买 (花费 ${cost} 🔥)`;
                    }

                    const el = document.createElement('div');
                    el.className = 'p-4 bg-gray-800 rounded-lg border border-gray-700';
                    el.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="text-lg font-bold text-white">${def.name} (Lv ${level}/${def.maxLevel})</h4>
                                <p class="text-sm text-gray-400">${def.desc}</p>
                            </div>
                            <button class="btn ${canBuy ? 'btn-primary' : 'btn-secondary opacity-50'}" data-upgrade-id="${id}" ${!canBuy ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    `;
                    container.appendChild(el);
                }
                
                container.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', (e) => buyUpgrade(e.target.dataset.upgradeId));
                });
                
                setGameState(GAME_STATES.UPGRADES);
            }

            function buyUpgrade(id) {
                const def = upgradeDefinitions[id];
                const level = playerProfile.upgrades[id] || 0;
                const cost = def.baseCost + (def.costIncrease * level);
                
                if (playerProfile.totalCurrency >= cost && level < def.maxLevel) {
                    playerProfile.totalCurrency -= cost;
                    playerProfile.upgrades[id] += 1;
                    def.apply(playerProfile); // 应用永久属性
                    
                    savePlayerProfile();
                    showUpgradeScreen(); // 刷新UI
                }
            }

            // --- 局内游戏 (Run) ---

            function generateFloorPath(floorNum) {
                let path = [];
                if (floorNum === 1) {
                    path = [
                        NODE_TYPE.MONSTER, NODE_TYPE.MONSTER, NODE_TYPE.EVENT, 
                        NODE_TYPE.ELITE, NODE_TYPE.MONSTER, NODE_TYPE.EVENT,
                        NODE_TYPE.MONSTER, NODE_TYPE.BOSS
                    ];
                } else {
                     path = [
                        NODE_TYPE.MONSTER, NODE_TYPE.MONSTER, NODE_TYPE.EVENT,
                        NODE_TYPE.MONSTER, NODE_TYPE.ELITE, NODE_TYPE.EVENT,
                        NODE_TYPE.ELITE, NODE_TYPE.MONSTER, NODE_TYPE.BOSS
                    ];
                }
                return path;
            }

            function startNewRun() {
                runState = {
                    player: {
                        maxHp: playerProfile.baseHp,
                        hp: Math.min(playerProfile.baseHp, playerProfile.baseHp + playerProfile.startHeal),
                        maxEnergy: playerProfile.baseEnergy,
                        energy: playerProfile.baseEnergy,
                        block: 0,
                        isPlayer: true,
                        status: { vulnerable: 0, weak: 0, strength: 0, barricade: 0 }, 
                        greedBonus: playerProfile.greedBonus,
                        smithChance: playerProfile.smithChance,
                        rerollCharges: playerProfile.rerollCharges,
                    },
                    deck: createStartDeck(),
                    hand: [],
                    discard: [],
                    exhaustPile: [],
                    currentFloor: 1,  
                    currentLevel: 0,  
                    floorPath: [],    
                    runCurrency: 0,
                    gameState: null,
                    selectedCardId: null,
                    selectedRewardCardId: null, 
                    isBossDefeated: false, 
                };
                
                runState.floorPath = generateFloorPath(runState.currentFloor); 
                updatePathDisplay();
                startNextEncounter();
            }
            
            function startNewFloor() {
                runState.currentFloor++;
                runState.currentLevel = 0;
                runState.floorPath = generateFloorPath(runState.currentFloor);
                runState.isBossDefeated = false;
                
                clearPlayerCombatStatus(); 
                
                updatePathDisplay();
                saveRunState(); // 保存进度
                startNextEncounter();
            }
            
            function setGameState(newState) {
                if (runState.gameState === GAME_STATES.GAME_OVER && newState !== GAME_STATES.MAIN_MENU) {
                    return; 
                }
                runState.gameState = newState;
                
                // 1. 切换主屏幕
                Object.values(D.screens).forEach(screen => screen.classList.remove('active'));
                
                // 2. 切换游戏子容器
                D.game.combatContainer.style.display = 'none';
                D.game.eventContainer.style.display = 'none';
                D.game.rewardContainer.style.display = 'none';
                
                switch (newState) {
                    case GAME_STATES.MAIN_MENU:
                        D.screens.mainMenu.classList.add('active');
                        break;
                    case GAME_STATES.UPGRADES:
                        D.screens.upgrades.classList.add('active');
                        break;
                    case GAME_STATES.GAME_OVER:
                        D.screens.gameOver.classList.add('active');
                        break;
                    
                    // --- In-Game States ---
                    case GAME_STATES.EVENT:
                        D.screens.game.classList.add('active');
                        D.game.eventContainer.style.display = 'flex';
                        break;
                    case GAME_STATES.REWARD:
                        D.screens.game.classList.add('active');
                        D.game.rewardContainer.style.display = 'flex';
                        break;
                    
                    case GAME_STATES.SMITHING:
                        D.screens.game.classList.add('active');
                        D.game.eventContainer.style.display = 'flex'; // 保持事件背景可见
                        D.screens.smith.classList.add('active'); // 模态框
                        break;
                        
                    case GAME_STATES.PLAYER_TURN:
                    case GAME_STATES.PROCESSING_LOGIC:
                    case GAME_STATES.COMBAT_OVER:
                        D.screens.game.classList.add('active');
                        D.game.combatContainer.style.display = 'flex';
                        break;
                }
                
                // 3. 结束回合按钮
                if (newState === GAME_STATES.PLAYER_TURN) {
                    D.game.endTurnBtn.disabled = false;
                    D.game.endTurnBtn.classList.add('btn-primary');
                    D.game.endTurnBtn.classList.remove('opacity-50');
                } else {
                    D.game.endTurnBtn.disabled = true;
                    D.game.endTurnBtn.classList.remove('btn-primary');
                    D.game.endTurnBtn.classList.add('opacity-50');
                }
                
                // 4. 奖励屏幕按钮
                if (newState === GAME_STATES.REWARD) {
                    if (runState.player.rerollCharges > 0) {
                        D.rewards.rerollBtn.classList.remove('hidden');
                        D.rewards.rerollBtn.textContent = `重抽 (${runState.player.rerollCharges})`;
                        D.rewards.rerollBtn.disabled = false;
                    } else {
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                    D.rewards.confirmBtn.classList.add('hidden'); 
                }
            }

            function createStartDeck() {
                let deck = [];
                for(let i=0; i<6; i++) deck.push(createCardInstance(cardDefinitions.strike));
                for(let i=0; i<4; i++) deck.push(createCardInstance(cardDefinitions.defend));
                return shuffle(deck);
            }
            
            function createCardInstance(cardDef) {
                return { ...cardDef, instanceId: Math.random().toString(36).substring(2, 9) };
            }

            function getEnemyIdForNode(nodeType, floorNum) {
                let pool = [];
                if (nodeType === NODE_TYPE.MONSTER) {
                    pool = (floorNum === 1) ? ['goblin', 'slime'] : ['orc', 'shadow', 'goblin']; 
                } else if (nodeType === NODE_TYPE.ELITE) {
                    pool = ['guardian']; 
                } else if (nodeType === NODE_TYPE.BOSS) {
                    pool = ['golem']; 
                }
                return pool[Math.floor(Math.random() * pool.length)];
            }
            
            function getEventIdForNode(nodeType, floorNum) {
                const pool = ['rest', 'statue', 'chest']; 
                return pool[Math.floor(Math.random() * pool.length)];
            }

            function startNextEncounter() {
                const nodeType = runState.floorPath[runState.currentLevel];
                if (!nodeType) {
                    console.error("路径已尽, 但未触发新楼层?");
                    gameOver(true); // 游戏胜利
                    return;
                }
                
                D.game.floorDisplay.textContent = `第 ${runState.currentFloor} 层`; 
                
                if (nodeType === NODE_TYPE.MONSTER || nodeType === NODE_TYPE.ELITE || nodeType === NODE_TYPE.BOSS) {
                    const enemyId = getEnemyIdForNode(nodeType, runState.currentFloor);
                    const enemyDef = enemyDefinitions[enemyId];
                    
                    runState.enemy = {
                        ...enemyDef,
                        hp: enemyDef.hp, maxHp: enemyDef.hp,
                        block: 0, nextMove: null, isPlayer: false,
                        status: { vulnerable: 0, weak: 0, strength: 0, barricade: 0 }, 
                        dom: { 
                            container: $(`#enemy-container-0`),
                            intent: $(`#enemy-intent-0`),
                            sprite: $(`#enemy-sprite-0`),
                            hpBar: $(`#enemy-hp-bar-0 .hp-bar-fg`),
                            hpText: $(`#enemy-hp-text-0`),
                            blockText: $(`#enemy-block-text-0`),
                            statusIcons: $(`#enemy-status-icons-0`),
                        }
                    };
                    startPlayerTurn();
                } else if (nodeType === NODE_TYPE.EVENT) {
                    const eventId = getEventIdForNode(nodeType, runState.currentFloor);
                    showEventScreen(eventId);
                }
            }
            
            function showEventScreen(eventId) {
                const event = eventDefinitions[eventId];
                if (!event) {
                    console.error(`未找到事件: ${eventId}`);
                    proceedToNextLevel();
                    return;
                }
                
                D.event.title.textContent = event.title;
                D.event.description.innerHTML = formatDescription(event.desc); 
                D.event.options.innerHTML = ''; 
                
                event.choices.forEach(choice => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-event w-full';
                    btn.innerHTML = choice.text; 
                    
                    let disabled = false;
                    if (choice.cost && !choice.cost()) {
                        disabled = true;
                        btn.classList.add('disabled');
                        btn.disabled = true;
                    }
                    
                    if (!disabled) {
                        btn.onclick = choice.action;
                    }
                    D.event.options.appendChild(btn);
                });
                
                setGameState(GAME_STATES.EVENT);
            }
            
            function showSmithScreen() {
                const container = D.smith.container;
                container.innerHTML = '';
                const allCards = [...runState.deck, ...runState.discard, ...runState.hand]
                                 .filter(c => c.type !== 'curse'); 
                
                allCards.forEach(card => {
                    const cardEl = createCardElement(card, card.instanceId);
                    const canUpgrade = !card.upgraded && card.upgradesTo;
                    
                    if (canUpgrade) {
                        cardEl.classList.add('can-upgrade');
                        cardEl.addEventListener('click', () => upgradeCard(card.instanceId));
                    }
                    container.appendChild(cardEl);
                });
                setGameState(GAME_STATES.SMITHING);
            }
            
            function upgradeCard(instanceId) {
                const locations = ['deck', 'discard', 'hand'];
                for (const loc of locations) {
                    const index = runState[loc].findIndex(c => c.instanceId === instanceId);
                    if (index !== -1) {
                        const oldCard = runState[loc][index];
                        if (oldCard.upgradesTo) {
                            const newCardDef = cardDefinitions[oldCard.upgradesTo];
                            runState[loc][index] = { ...newCardDef, instanceId: oldCard.instanceId };
                            
                            // V1.1: 升级后隐藏模态框
                            D.screens.smith.classList.remove('active'); 
                            
                            if (Math.random() < runState.player.smithChance) {
                                D.event.description.textContent = "你灵光一闪，锻造未消耗篝火！";
                                D.event.options.innerHTML = `<button class="btn btn-primary w-full" id="event-leave">太好了</button>`;
                                $('#event-leave').onclick = () => proceedToNextLevel();
                                setGameState(GAME_STATES.EVENT);
                            } else {
                                proceedToNextLevel(); 
                            }
                            return; 
                        }
                    }
                }
            }
            
            function clearPlayerCombatStatus() {
                runState.player.block = 0;
                runState.player.status.vulnerable = 0;
                runState.player.status.weak = 0;
                updateEntityUI(runState.player);
            }
            
            function proceedToNextLevel() {
                if (runState.gameState !== GAME_STATES.EVENT) {
                    clearPlayerCombatStatus(); 
                }
                
                runState.currentLevel++;
                updatePathDisplay();
                saveRunState(); // 保存进度
                startNextEncounter();
            }

            function startPlayerTurn() {
                setGameState(GAME_STATES.PROCESSING_LOGIC); 
                runState.player.energy = runState.player.maxEnergy;
                
                if (!runState.player.status.barricade) {
                    runState.player.block = 0; 
                }
                
                runState.selectedCardId = null;
                
                if (runState.enemy && runState.enemy.hp > 0) { 
                    runState.enemy.nextMove = runState.enemy.moves[Math.floor(Math.random() * runState.enemy.moves.length)];
                }
                
                updateAllUI(); 
                
                drawCards(5, null, () => {
                    setGameState(GAME_STATES.PLAYER_TURN); 
                }); 
            }

            function endPlayerTurn() {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); 
                saveRunState(); 
                
                runState.selectedCardId = null;
                updateTargetHighlights(null); 
                
                runState.discard = [...runState.discard, ...runState.hand];
                runState.hand = [];
                
                tickDownStatus(runState.player);
                
                updateHandUI(); 
                updateEntityUI(runState.player); 
                
                setTimeout(() => enemyTurn(), 500); 
            }
            
            function enemyTurn() {
                const enemy = runState.enemy;
                let onEndCallback = null; 

                onEndCallback = () => {
                    updateAllUI(); 
                    
                    if (runState.player.hp <= 0) {
                        gameOver(false); 
                    } else {
                        setTimeout(() => {
                            if (enemy) {
                                tickDownStatus(enemy); 
                                updateEntityUI(enemy); 
                            }
                            startPlayerTurn(); 
                        }, 500); 
                    }
                };
                
                if (enemy) {
                    if (!enemy.status.barricade) {
                        enemy.block = 0; 
                    }
                    updateEntityUI(enemy); 
                }
                
                if (enemy && enemy.hp > 0) { 
                    if (enemy.onTurn) { 
                        enemy.onTurn(enemy, onEndCallback); 
                    } else if (enemy.nextMove) {
                        executeDefaultEnemyMove(enemy, onEndCallback); 
                    } else {
                        onEndCallback(); 
                    }
                } else {
                    onEndCallback(); 
                }
            }
            
            function executeDefaultEnemyMove(enemy, onEndCallback) {
                const move = enemy.nextMove;
                if (!move) {
                    onEndCallback();
                    return;
                }
                
                let animationDone = false;
                let logicDone = false;
                
                const checkEnd = () => {
                    if (animationDone && logicDone) onEndCallback();
                };
                
                // 1. 执行动画
                switch (move.type) {
                    case 'attack':
                        playAnimation(enemy.dom.sprite, 'anim-lunge', () => {
                            animationDone = true;
                            checkEnd();
                        });
                        break;
                    case 'defend':
                        addBlock(enemy, move.val); 
                        animationDone = true;
                        break;
                    case 'buff':
                    case 'debuff':
                    case 'pollute':
                        executeEnemyLogic(move, enemy, () => {
                            animationDone = true; 
                            checkEnd();
                        });
                        logicDone = true; 
                        return; 
                    default:
                        animationDone = true;
                }
                
                // 2. 执行逻辑
                setTimeout(() => {
                    executeEnemyLogic(move, enemy, () => {
                        logicDone = true;
                        checkEnd();
                    });
                }, 250); 
            }
            
            function executeEnemyLogic(move, enemy, onLogicEnd = () => {}) {
                switch (move.type) {
                    case 'attack':
                        takeDamage(runState.player, move.val, enemy);
                        onLogicEnd();
                        break;
                    case 'defend':
                        onLogicEnd();
                        break;
                    case 'buff':
                        applyStatus(enemy, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'debuff':
                        applyStatus(runState.player, move.status, move.val, enemy, onLogicEnd);
                        break;
                    case 'pollute':
                        addCardToDiscard(cardDefinitions.slime_curse, move.val, enemy, onLogicEnd);
                        break;
                    default:
                        onLogicEnd();
                }
            }

            // --- 卡牌逻辑 ---
            
            function drawCards(amount, sourceCard = null, onAllCardsDrawn = () => {}) {
                let handRect = D.game.handArea.getBoundingClientRect();
                let deckRect = D.game.deckCount.getBoundingClientRect();
                let drawnCardsData = []; 
                
                for (let i = 0; i < amount; i++) {
                    if (runState.deck.length === 0) {
                        if (runState.discard.length === 0) break; 
                        runState.deck = shuffle(runState.discard);
                        runState.discard = [];
                        updateDeckDiscardUI();
                    }
                    const card = runState.deck.pop();
                    runState.hand.push(card);
                    drawnCardsData.push(card);
                }
                
                updateDeckDiscardUI(); 

                if (drawnCardsData.length === 0) {
                    onAllCardsDrawn();
                    return;
                }

                drawnCardsData.forEach((card, index) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    cardEl.classList.add('drawing'); 
                    
                    const startX = (deckRect.left + deckRect.width / 2) - (handRect.left + 40); 
                    const startY = (deckRect.top + deckRect.height / 2) - (handRect.top + handRect.height / 2);
                    cardEl.style.transform = `translate(${startX}px, ${startY}px) scale(0.5)`;
                    
                    D.game.handArea.appendChild(cardEl); 

                    setTimeout(() => {
                        cardEl.classList.remove('drawing');
                        cardEl.style.transform = ``;
                        cardEl.style.position = 'relative'; 
                        
                        if (index === drawnCardsData.length - 1) { 
                            setTimeout(() => {
                                updateHandUI(); 
                                onAllCardsDrawn();
                            }, 400); 
                        }
                    }, (sourceCard ? 0 : index * 100) + 50); 
                });
            }
            
            function addCardToDiscard(cardDef, amount, source = null, onEndCallback = () => {}) {
                const targetEl = D.game.discardCount.parentElement; 
                const sourceEl = source?.dom?.container || D.game.enemyArea;
                
                for(let i = 0; i < amount; i++) {
                    createAndFireProjectile(sourceEl, targetEl, '🟣', () => {
                        runState.discard.push(createCardInstance(cardDef));
                        updateDeckDiscardUI();
                        if (i === amount - 1) onEndCallback();
                    });
                }
            }
            
            function addCardToDeck(cardDef) {
                if (!cardDef) return;
                runState.deck.push(createCardInstance(cardDef));
                updateDeckDiscardUI();
            }
            
            function onCardClick(cardInstanceId) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                const card = runState.hand.find(c => c.instanceId === cardInstanceId);
                if (!card || card.type === 'curse') return; 
                
                if (runState.player.energy < card.cost) return; 

                if (runState.selectedCardId === cardInstanceId) {
                    runState.selectedCardId = null;
                    updateHandUI();
                    updateTargetHighlights(null);
                } else {
                    runState.selectedCardId = cardInstanceId;
                    updateHandUI();
                    updateTargetHighlights(card); 
                }
            }
            
            function onEnemyClick(enemy) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
                const card = runState.hand.find(c => c.instanceId === runState.selectedCardId);
                if (!card) return;
                if (card.target === 'enemy') {
                    playCard(card, enemy);
                }
            }
            
            function onPlayerClick() {
                 if (runState.gameState !== GAME_STATES.PLAYER_TURN || !runState.selectedCardId) {
                    return;
                }
                const card = runState.hand.find(c => c.instanceId === runState.selectedCardId);
                if (!card) return;
                if (card.target === 'self') {
                    playCard(card, runState.player);
                }
            }

            function playCard(card, target) {
                if (runState.gameState !== GAME_STATES.PLAYER_TURN) return;
                
                setGameState(GAME_STATES.PROCESSING_LOGIC); 
                
                runState.player.energy -= card.cost;
                runState.hand = runState.hand.filter(c => c.instanceId !== card.instanceId);
                
                if (card.exhaust) {
                    runState.exhaustPile.push(card);
                } else {
                    runState.discard.push(card);
                }
                
                runState.selectedCardId = null;
                updateTargetHighlights(null);
                updateHandUI(); 

                card.effect(runState.player, target, card);
                
                let animationTime = 200; 
                if (card.type === 'attack') animationTime = 500;
                if (card.id.includes('double_hit')) animationTime = 700;
                if (card.id.includes('bulwark') && runState.player.block > 0) animationTime = 700; 
                if (card.id.includes('battle_focus')) animationTime = 1000; 
                if (card.id.includes('adrenaline')) animationTime = 1000; 
                
                setTimeout(() => {
                    updateAllUI(); 
                    
                    if (runState.enemy.hp <= 0) {
                        setGameState(GAME_STATES.COMBAT_OVER);
                        enemyKilled();
                    } else if (runState.player.hp <= 0) {
                        gameOver(false);
                    } else {
                        updateHandUI(); 
                        setGameState(GAME_STATES.PLAYER_TURN); 
                    }
                }, animationTime); 
            }
            
            function enemyKilled() {
                const isBoss = runState.enemy.isBoss || false;
                const rewardType = isBoss ? CARD_RARITY.RARE : CARD_RARITY.COMMON;
                runState.isBossDefeated = isBoss;
                
                const currencyGained = Math.floor(runState.enemy.currency * (1 + runState.player.greedBonus));
                runState.runCurrency += currencyGained;
                
                setTimeout(() => showRewardScreen(currencyGained, rewardType), 1000); 
            }
            
            function showRewardScreen(currencyGained, rewardType) {
                D.rewards.currency.textContent = `${currencyGained} 🔥`;
                if (runState.isBossDefeated) {
                    D.rewards.title.textContent = 'Boss 已击败！';
                } else {
                    D.rewards.title.textContent = '战斗胜利！';
                }
                generateRewardOptions(rewardType);
                setGameState(GAME_STATES.REWARD);
            }
            
            function getCardPool(rarity) {
                return Object.values(cardDefinitions).filter(c => c.rarity === rarity);
            }
            
            function getRandomCard(rarity) {
                const pool = getCardPool(rarity);
                if (pool.length === 0) return null;
                return pool[Math.floor(Math.random() * pool.length)];
            }
            
            function generateRewardOptions(rewardType) {
                const optionsContainer = D.rewards.options;
                optionsContainer.innerHTML = '';
                runState.selectedRewardCardId = null; 
                
                const commonPool = getCardPool(CARD_RARITY.COMMON);
                let options = [];
                
                if (rewardType === CARD_RARITY.RARE) {
                    const rarePool = getCardPool(CARD_RARITY.RARE);
                    if (rarePool.length > 0) {
                        options.push(rarePool[Math.floor(Math.random() * rarePool.length)]);
                    }
                    options = options.concat(shuffle(commonPool).slice(0, 2));
                } else {
                    options = shuffle(commonPool).slice(0, 3);
                }
                
                shuffle(options).forEach(cardDef => {
                    if (!cardDef) return;
                    const cardEl = createCardElement(cardDef);
                    cardEl.classList.add('reward-card'); 
                    cardEl.addEventListener('click', () => onRewardCardClick(cardDef, cardEl)); 
                    optionsContainer.appendChild(cardEl);
                });
            }
            
            function onRewardCardClick(cardDef, cardEl) {
                $$('.reward-card.selected-reward').forEach(el => el.classList.remove('selected-reward'));
                
                cardEl.classList.add('selected-reward');
                runState.selectedRewardCardId = cardDef.id;
                
                D.rewards.confirmBtn.classList.remove('hidden');
            }

            function selectReward(cardDef) {
                addCardToDeck(cardDef); 
                
                runState.selectedRewardCardId = null;
                D.rewards.confirmBtn.classList.add('hidden');
                $$('.reward-card.selected-reward').forEach(el => el.classList.remove('selected-reward'));

                if (runState.isBossDefeated) {
                    startNewFloor();
                } else {
                    proceedToNextLevel();
                }
            }
            
            // --- 战斗数值 ---
            
            function applyStatus(target, status, duration, source, onEndCallback = () => {}) {
                const def = statusDefinitions[status];
                const sourceEl = source.isPlayer ? D.game.playerContainer : source.dom.container;
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                
                let iconHTML = '...';
                switch(status) {
                    case 'vulnerable': iconHTML = '🟠'; break;
                    case 'weak': iconHTML = '🔘'; break;
                    case 'strength': iconHTML = '🔴'; break;
                    case 'barricade': iconHTML = '🔵'; break;
                }
                
                createAndFireProjectile(sourceEl, targetEl, iconHTML, () => {
                    if (status === 'strength') {
                        target.status.strength = (target.status.strength || 0) + duration;
                    } else if (status === 'barricade') {
                        target.status.barricade = 1; 
                    } else {
                        target.status[status] = (target.status[status] || 0) + duration;
                    }
                    updateEntityUI(target);
                    if (onEndCallback) onEndCallback();
                });
            }

            function tickDownStatus(target) {
                if (target.status.vulnerable > 0) target.status.vulnerable--;
                if (target.status.weak > 0) target.status.weak--;
            }
            
            function dealDamage(target, amount, source, delay = 0) {
                setTimeout(() => {
                    let modifiedAmount = amount;
                    
                    if (source && source.status.strength > 0) {
                        modifiedAmount += source.status.strength;
                    }
                    
                    if (source && source.status.weak > 0) {
                        modifiedAmount = Math.floor(modifiedAmount * 0.5);
                    }
                    
                    let isVulnerable = target.status.vulnerable > 0;
                    if (isVulnerable) {
                        modifiedAmount = Math.floor(modifiedAmount * 1.5);
                    }

                    let damageDealt = modifiedAmount;
                    if (target.block > 0) {
                        if (target.block >= damageDealt) {
                            target.block -= damageDealt;
                            damageDealt = 0;
                        } else {
                            damageDealt -= target.block;
                            target.block = 0;
                        }
                    }
                    
                    target.hp -= damageDealt;
                    if (target.hp < 0) target.hp = 0; 
                    
                    if (damageDealt > 0) {
                        const floatType = isVulnerable ? 'damage vulnerable' : 'damage';
                        showFloatingText(`-${damageDealt}`, target.isPlayer ? D.game.playerContainer : target.dom.container, floatType);
                        playAnimation(target.isPlayer ? D.game.playerContainer : target.dom.sprite, 'anim-shake');
                    }
                    
                    updateEntityUI(target);
                }, delay);
            }
            
            function takeDamage(target, amount, source) {
                dealDamage(target, amount, source, 0);
            }
            
            function addBlock(target, amount) {
                target.block += amount;
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block');
                
                const animEl = document.createElement('div');
                animEl.className = 'anim-block-shield';
                animEl.innerHTML = '🛡️';
                const targetEl = target.isPlayer ? D.game.playerContainer : target.dom.container;
                targetEl.appendChild(animEl);
                animEl.addEventListener('animationend', () => animEl.remove());
                
                updateEntityUI(target);
            }
            
            function healDamage(target, amount) {
                target.hp = Math.min(target.maxHp, target.hp + amount);
                showFloatingText(`+${amount}`, target.isPlayer ? D.game.playerContainer : target.dom.container, 'block-float text-green-500'); // 绿色
                updateEntityUI(target);
            }
            
            function gameOver(isWin) {
                if (runState.gameState === GAME_STATES.GAME_OVER) return; 
                
                localStorage.removeItem(RUN_KEY); 
                
                playerProfile.totalCurrency += runState.runCurrency;
                if (runState.currentFloor > playerProfile.highScore) {
                    playerProfile.highScore = runState.currentFloor;
                }
                savePlayerProfile();
                
                if (isWin) {
                    D.gameOver.title.textContent = '你胜利了！';
                    D.gameOver.title.classList.remove('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} 🔥`;
                } else {
                    D.gameOver.title.textContent = '你倒下了';
                    D.gameOver.title.classList.add('text-red-500');
                    D.gameOver.finalFloor.textContent = runState.currentFloor;
                    D.gameOver.finalCurrency.textContent = `${runState.runCurrency} 🔥`;
                }
                setGameState(GAME_STATES.GAME_OVER);
            }

            // --- 渲染 / UI ---
            
            function updateAllUI() {
                if (!runState || !runState.player) return; 

                updateEntityUI(runState.player);
                D.game.playerEnergyText.textContent = `${runState.player.energy}/${runState.player.maxEnergy}`;
                
                if (runState.enemy && runState.enemy.hp > 0) {
                    updateEntityUI(runState.enemy);
                    const e = runState.enemy;
                    e.dom.sprite.textContent = e.sprite;
                    if (e.nextMove) {
                        e.dom.intent.innerHTML = `<span>${e.nextMove.intent}</span>`;
                        e.dom.intent.dataset.intentKey = e.nextMove.intentKey;
                        e.dom.intent.dataset.intentVal = e.nextMove.val || 0;
                        e.dom.intent.dataset.intentCount = e.nextMove.count || 0;
                        e.dom.intent.classList.remove('hidden');
                    } else {
                        e.dom.intent.classList.add('hidden');
                    }
                } else if (runState.enemy) {
                    const e = runState.enemy;
                    e.dom.sprite.textContent = e.sprite;
                    e.dom.intent.classList.add('hidden');
                }
                
                updateDeckDiscardUI();
            }
            
            function updateEntityUI(entity) {
                if (!entity) return;

                let hpBar, hpText, blockText, statusIconContainer;
                
                if (entity.isPlayer) {
                    hpBar = D.game.playerHPBar;
                    hpText = D.game.playerHPText;
                    blockText = D.game.playerBlockText;
                    statusIconContainer = D.game.playerStatusIcons; 
                } else if (entity.dom) {
                    hpBar = entity.dom.hpBar;
                    hpText = entity.dom.hpText;
                    blockText = entity.dom.blockText;
                    statusIconContainer = entity.dom.statusIcons;
                } else {
                    return; 
                }
                
                // HP
                if (hpBar) {
                    hpBar.style.width = `${Math.max(0, (entity.hp / entity.maxHp) * 100)}%`;
                }
                if (hpText) {
                    hpText.textContent = `${entity.hp} / ${entity.maxHp}`;
                }
                
                // Block
                if (blockText) {
                    if (entity.block > 0) {
                        blockText.textContent = `🛡️ ${entity.block}`;
                        blockText.classList.remove('hidden');
                    } else {
                        blockText.classList.add('hidden');
                    }
                }
                
                // Status Icons
                if (statusIconContainer) {
                    statusIconContainer.innerHTML = ''; // 清空旧图标
                    for (const statusId in entity.status) {
                        const duration = entity.status[statusId];
                        if (duration > 0) { // 只渲染激活的状态
                            const def = statusDefinitions[statusId];
                            if (!def) continue; 

                            let durationText = duration;
                            if (statusId === 'strength') {
                                durationText = `+${duration}`; 
                            } else if (statusId === 'barricade') {
                                durationText = ``; 
                            }

                            const iconEl = document.createElement('div');
                            iconEl.className = `status-icon status-${def.color}`; 
                            iconEl.innerHTML = `<span>${statusId === 'barricade' ? def.icon : durationText}</span>`; 
                            iconEl.dataset.statusId = statusId; 
                            
                            statusIconContainer.appendChild(iconEl);
                        }
                    }
                }
            }
            
            function updateHandUI() {
                const hand = runState.hand;
                const handArea = D.game.handArea;
                
                handArea.innerHTML = ''; 
                
                hand.forEach((card) => {
                    const cardEl = createCardElement(card, card.instanceId);
                    
                    const isPlayable = runState.player.energy >= card.cost;
                    if (isPlayable) cardEl.classList.add('playable');
                    else cardEl.classList.add('unplayable');
                    
                    if (card.instanceId === runState.selectedCardId) {
                        cardEl.classList.add('selected');
                    }
                    
                    handArea.appendChild(cardEl);
                });
            }
            
            function formatDescription(desc) {
                if (!desc) return '';
                return desc
                    .replace(/<k>易伤<\/k>/g, '<span class="keyword" data-keyword="vulnerable">易伤</span>')
                    .replace(/<k>虚弱<\/k>/g, '<span class="keyword" data-keyword="weak">虚弱</span>')
                    .replace(/<k>消耗<\/k>/g, '<span class="keyword" data-keyword="exhaust">消耗</span>')
                    .replace(/<k>诅咒<\/k>/g, '<span class="keyword" data-keyword="curse">诅咒</span>')
                    .replace(/<k>格挡<\/k>/g, '<span class="keyword" data-keyword="barricade">格挡</span>') 
                    .replace(/<strong>易伤<\/strong>/g, '<span class="keyword" data-keyword="vulnerable"><strong>易伤</strong></span>')
                    .replace(/<strong>虚弱<\/strong>/g, '<span class="keyword" data-keyword="weak"><strong>虚弱</strong></span>');
            }
            
            function createCardElement(cardDef, instanceId = null) {
                const el = document.createElement('div');
                el.className = 'card';
                if(instanceId) {
                    el.classList.add('hand-card');
                    el.id = `hand-card-${instanceId}`; 
                    el.dataset.instanceId = instanceId;
                }
                
                el.classList.add(`rarity-${cardDef.rarity || 'common'}`);
                
                if(cardDef.upgraded) el.classList.add('upgraded');
                if(cardDef.exhaust) el.classList.add('exhaust');
                if(cardDef.type === 'curse') el.classList.add('curse');
                
                let typeText = '';
                let typeColor = '';
                switch(cardDef.type) {
                    case 'attack': typeText = '攻击'; typeColor = 'text-red-400'; break;
                    case 'skill': typeText = '技能'; typeColor = 'text-blue-400'; break;
                    case 'curse': typeText = '诅咒'; typeColor = 'text-purple-400'; break;
                }
                
                let descHTML = cardDef.desc;
                if (cardDef.exhaust) descHTML += " (<k>消耗</k>)";
                if (cardDef.type === 'curse') descHTML += " (<k>诅咒</k>)";
                
                descHTML = formatDescription(descHTML);
                
                let nameClass = `card-name ${cardDef.upgraded ? 'upgraded' : ''}`;
                if (cardDef.rarity === CARD_RARITY.RARE && !cardDef.upgraded) {
                    nameClass += ' rarity-rare'; 
                }
                
                el.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="card-cost">${cardDef.cost}</div>
                        <div class="text-xs ${typeColor}">${typeText}</div>
                    </div>
                    <div class="${nameClass}">${cardDef.name}</div>
                    <div class="card-desc">${descHTML}</div>
                `;
                return el;
            }
            
            function updateDeckDiscardUI() {
                D.game.deckCount.textContent = runState.deck.length;
                D.game.discardCount.textContent = runState.discard.length;
            }
            
            function updatePathDisplay() {
                D.game.pathDisplay.innerHTML = '';
                const { floorPath, currentLevel } = runState;
                
                floorPath.forEach((nodeType, index) => {
                    const nodeEl = document.createElement('div');
                    nodeEl.className = 'path-node';
                    let sprite = '';
                    
                    if (index < currentLevel) {
                        nodeEl.classList.add('cleared');
                        sprite = NODE_SPRITES[nodeType];
                    } else if (index === currentLevel) {
                        nodeEl.classList.add('current');
                        sprite = NODE_SPRITES[nodeType];
                    } else {
                        // 未探索
                        if (index === floorPath.length - 1) {
                            // Boss 节点
                            nodeEl.classList.add('boss');
                            sprite = NODE_SPRITES[NODE_TYPE.BOSS];
                        } else {
                            // 迷雾
                            sprite = NODE_SPRITES.FOG;
                        }
                    }
                    
                    nodeEl.textContent = sprite;
                    D.game.pathDisplay.appendChild(nodeEl);
                });
            }
            
            function updateTargetHighlights(card) {
                $$('.targeted').forEach(el => el.classList.remove('targeted'));
                
                if (!card) return; 
                
                if (card.target === 'enemy') {
                    if (runState.enemy) runState.enemy.dom.container.classList.add('targeted');
                } else if (card.target === 'self') { 
                    D.game.playerContainer.classList.add('targeted');
                }
            }
            
            function showFloatingText(text, targetElement, type) {
                const floatEl = document.createElement('div');
                floatEl.className = `damage-float ${type}`; 
                
                floatEl.textContent = text;
                const xOffset = (Math.random() - 0.5) * 40; 
                floatEl.style.left = `calc(50% + ${xOffset}px)`;
                targetElement.appendChild(floatEl);
                floatEl.addEventListener('animationend', () => floatEl.remove());
            }
            
            function playAnimation(target, animationClass, onEndCallback = null) {
                if (!target) {
                    if (onEndCallback) onEndCallback();
                    return;
                }
                target.classList.add(animationClass);
                const onAnimEnd = () => {
                    target.classList.remove(animationClass);
                    target.removeEventListener('animationend', onAnimEnd);
                    if (onEndCallback) onEndCallback();
                };
                target.addEventListener('animationend', onAnimEnd);
            }
            
            function createAndFireProjectile(sourceEl, targetEl, iconHTML, onEndCallback) {
                const proj = document.createElement('div');
                proj.className = 'anim-projectile';
                proj.innerHTML = iconHTML;
                
                const startRect = sourceEl.getBoundingClientRect();
                const endRect = targetEl.getBoundingClientRect();
                const gameRect = D.gameContainer.getBoundingClientRect();
                
                const startX = (startRect.left + startRect.width / 2) - gameRect.left;
                const startY = (startRect.top + startRect.height / 2) - gameRect.top;
                
                const endX = (endRect.left + endRect.width / 2) - gameRect.left;
                const endY = (endRect.top + endRect.height / 2) - gameRect.top;
                
                proj.style.left = `${startX}px`;
                proj.style.top = `${startY}px`;
                proj.style.transform = 'translate(-50%, -50%)';

                D.animationLayer.appendChild(proj);

                requestAnimationFrame(() => {
                    proj.style.transform = `translate(-50%, -50%) translate(${endX - startX}px, ${endY - startY}px)`;
                });
                
                proj.addEventListener('transitionend', () => {
                    proj.remove();
                    if (onEndCallback) onEndCallback();
                });
            }

            // --- 工具函数 ---
            function shuffle(array) {
                let newArr = [...array];
                for (let i = newArr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                }
                return newArr;
            }

            // --- 事件绑定 ---

            function initTooltipListeners() {
                const tooltip = D.tooltip.el;
                let currentTooltipTarget = null; 

                function showTooltip(target) {
                    if (!target) return;
                    
                    let title = '';
                    let desc = '';
                    currentTooltipTarget = target; 

                    // 1. 检查是什么类型的目标
                    if (target.dataset.statusId) {
                        const statusId = target.dataset.statusId;
                        const def = statusDefinitions[statusId];
                        if (!def) return;
                        
                        const isPlayer = target.closest('#player-status-area');
                        const entity = isPlayer ? runState.player : runState.enemy;
                        const duration = entity.status[statusId];
                        
                        title = `${def.name} ${def.icon}`;
                        if (statusId === 'strength') {
                            title += ` (${duration} 层)`;
                        } else if (statusId !== 'barricade') {
                            title += ` (剩余 ${duration} 回合)`;
                        }
                        desc = def.desc;
                        
                    } else if (target.dataset.intentKey) {
                        const key = target.dataset.intentKey;
                        const val = target.dataset.intentVal;
                        const count = target.dataset.intentCount;
                        const def = intentDefinitions[key];
                        if (!def) return;
                        
                        title = def.name;
                        desc = def.desc(val, count); 
                        
                    } else if (target.dataset.keyword) {
                        const key = target.dataset.keyword;
                        let def = statusDefinitions[key]; 
                        if (key === 'barricade' && target.closest('.card-desc')) {
                            def = statusDefinitions['barricade'];
                        }
                        if (!def) return;
                        
                        title = `${def.name} ${def.icon || ''}`;
                        desc = def.desc;
                    } else {
                        return; 
                    }

                    // 2. 填充内容
                    D.tooltip.title.innerHTML = title;
                    D.tooltip.desc.innerHTML = formatDescription(desc);
                    
                    tooltip.classList.add('visible'); 

                    // 3. 安全定位
                    const gameRect = D.gameContainer.getBoundingClientRect();
                    const ttRect = tooltip.getBoundingClientRect(); 
                    const targetRect = target.getBoundingClientRect();
                    
                    const targetTop = targetRect.top - gameRect.top;
                    const targetLeft = targetRect.left - gameRect.left;
                    
                    let ttLeft = targetLeft + (targetRect.width / 2); 
                    let ttTop = targetTop - 8; 
                    let transform = 'translate(-50%, -100%)'; 
                    
                    if ((targetRect.top - ttRect.height - 10) < gameRect.top) {
                        ttTop = targetTop + targetRect.height + 8; 
                        transform = 'translate(-50%, 0)';
                    }
                    
                    if ((targetLeft + (targetRect.width / 2) - (ttRect.width / 2)) < gameRect.left) {
                        ttLeft = 5; 
                        transform = transform.replace('translate(-50%', 'translate(0%');
                    }
                    
                    if ((targetLeft + (targetRect.width / 2) + (ttRect.width / 2)) > (gameRect.left + gameRect.width)) {
                        ttLeft = gameRect.width - 5; 
                        transform = transform.replace('translate(-50%', 'translate(-100%');
                    }

                    tooltip.style.left = `${ttLeft}px`;
                    tooltip.style.top = `${ttTop}px`;
                    tooltip.style.transform = transform;
                }

                function hideTooltip() {
                    tooltip.classList.remove('visible'); 
                    currentTooltipTarget = null;
                }
                
                D.gameContainer.addEventListener('click', (e) => {
                    const tooltipTarget = e.target.closest('.status-icon, [data-intent-key], .keyword');
                    
                    if (tooltipTarget) {
                        e.stopPropagation(); 
                        
                        if (currentTooltipTarget === tooltipTarget) {
                            hideTooltip();
                        } else {
                            showTooltip(tooltipTarget);
                        }
                        return; 
                    }
                    
                    const cardTarget = e.target.closest('.hand-card, .enemy-container, .player-container, .btn-event');
                    if (!cardTarget) {
                        hideTooltip();
                    }
                });
            }
            
            D.mainMenu.continueBtn.addEventListener('click', () => loadRunState());
            D.mainMenu.startBtn.addEventListener('click', () => {
                localStorage.removeItem(RUN_KEY); 
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = '开始探索';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                startNewRun();
            });
            D.mainMenu.upgradesBtn.addEventListener('click', () => showUpgradeScreen());
            
            D.upgrades.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            D.game.endTurnBtn.addEventListener('click', () => endPlayerTurn());
            
            D.game.enemyArea.addEventListener('click', (e) => {
                const enemyContainer = e.target.closest('.enemy-container');
                if (enemyContainer && enemyContainer.id === 'enemy-container-0') {
                    onEnemyClick(runState.enemy);
                }
            });
            D.game.playerContainer.addEventListener('click', () => onPlayerClick());
            
            D.game.handArea.addEventListener('click', (e) => {
                const cardEl = e.target.closest('.hand-card');
                if (cardEl && !e.target.closest('.keyword')) { 
                    onCardClick(cardEl.dataset.instanceId);
                }
            });

            D.rewards.confirmBtn.addEventListener('click', () => {
                if (runState.selectedRewardCardId) {
                    selectReward(cardDefinitions[runState.selectedRewardCardId]);
                }
            });
            D.rewards.skipBtn.addEventListener('click', () => selectReward(null));
            D.rewards.rerollBtn.addEventListener('click', () => {
                if (runState.player.rerollCharges > 0) {
                    runState.player.rerollCharges--;
                    const rewardType = runState.isBossDefeated ? CARD_RARITY.RARE : CARD_RARITY.COMMON;
                    generateRewardOptions(rewardType); 
                    D.rewards.rerollBtn.textContent = `重抽 (${runState.player.rerollCharges})`;
                    D.rewards.confirmBtn.classList.add('hidden'); 
                    if (runState.player.rerollCharges === 0) {
                        D.rewards.rerollBtn.disabled = true;
                        D.rewards.rerollBtn.classList.add('hidden');
                    }
                }
            });

            D.gameOver.backBtn.addEventListener('click', () => {
                updateMainMenuUI();
                D.mainMenu.continueBtn.classList.add('hidden');
                D.mainMenu.startBtn.textContent = '开始探索';
                D.mainMenu.startBtn.classList.replace('btn-secondary', 'btn-primary');
                setGameState(GAME_STATES.MAIN_MENU);
            });
            
            // V1.1: 锻造界面的 "离开" 按钮
            D.smith.backBtn.addEventListener('click', () => {
                D.screens.smith.classList.remove('active'); // 隐藏模态框
                proceedToNextLevel(); // 离开事件
            });

            // --- 游戏启动 ---
            function init() {
                defineStatus();
                defineIntents(); 
                defineCards();
                defineEnemies();
                defineEvents(); 
                defineUpgrades();
                initTooltipListeners(); 
                loadPlayerProfile();
                
                const savedRun = localStorage.getItem(RUN_KEY);
                if (savedRun) {
                    const loadedState = JSON.parse(savedRun);
                    D.mainMenu.startBtn.textContent = '开始新探索'; 
                    D.mainMenu.startBtn.classList.replace('btn-primary', 'btn-secondary'); 
                    
                    D.mainMenu.continueBtn.textContent = `继续探索 (第 ${loadedState.currentFloor} 层)`; 
                    D.mainMenu.continueBtn.classList.remove('hidden');
                }
                
                setGameState(GAME_STATES.MAIN_MENU);
            }
            
            init();
        });
    </script>
</body>
</html>


